<!DOCTYPE html>
<html>
<head>
    <title>3D Maze Game</title>
    <!-- Load Three.js from local file -->
            <script src="js/three.min.js?v=3"></script>
        <script src="js/maze-generator.js?v=3"></script>
        <script src="js/multiplayer.js?v=3"></script>
    <script>
        // Verify Three.js loaded
        window.addEventListener('load', function() {
            if (typeof THREE === 'undefined') {
                document.body.innerHTML = '<div style="color: red; text-align: center; margin-top: 50px;">Error: Failed to load 3D library. Please try refreshing the page.</div>';
            }
        });
    </script>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: Arial, sans-serif;
            background: #000;
            color: #fff;
        }
        /* Permanent horror vignette overlay - subtle */
        body::after {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 5000;
            background: radial-gradient(circle, transparent 50%, rgba(0, 0, 0, 0.25) 100%);
        }
        #startScreen {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            background: none;
            color: white;
            padding: 30px;
            z-index: 1000;
            pointer-events: auto !important;
        }
        #startScreen h1 {
            color: #4CAF50;
            text-shadow: 0 0 15px rgba(76, 175, 80, 0.7);
            margin-bottom: 30px;
            font-size: 48px;
        }
        #startScreen .instruction {
            color: rgba(255, 255, 255, 0.9);
            margin: 8px 0;
            font-size: 18px;
            text-shadow: 0 0 10px rgba(255, 255, 255, 0.5);
        }
        .gameButton {
            background: rgba(76, 175, 80, 0.8);
            border: 2px solid rgba(255, 255, 255, 0.2);
            color: white;
            padding: 15px 30px;
            font-size: 20px;
            cursor: pointer;
            border-radius: 25px;
            transition: all 0.3s;
            margin: 15px;
            width: 200px;
            backdrop-filter: blur(5px);
            text-shadow: 0 0 5px rgba(0, 0, 0, 0.3);
        }
        .gameButton:hover {
            background: rgba(76, 175, 80, 1);
            transform: scale(1.05);
            box-shadow: 0 0 20px rgba(76, 175, 80, 0.4);
        }
        #multiplayerMenu {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 30px;
            border-radius: 15px;
            z-index: 1000;
            display: none;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
        }
        #roomCodeInput {
            padding: 10px;
            font-size: 18px;
            margin: 10px;
            border-radius: 5px;
            border: none;
            text-align: center;
            width: 180px;
        }
        .backButton {
            background: #666;
            border: none;
            color: white;
            padding: 10px 20px;
            font-size: 16px;
            cursor: pointer;
            border-radius: 5px;
            transition: all 0.3s;
            margin-top: 20px;
        }
        .backButton:hover {
            background: #555;
        }
        #roomCode {
            font-size: 48px;
            margin: 20px;
            padding: 30px;
            background: rgba(0, 0, 0, 0.9);
            border-radius: 15px;
            font-family: monospace;
            letter-spacing: 8px;
            text-align: center;
            border: 3px solid #4CAF50;
            color: #4CAF50;
            cursor: pointer;
            user-select: all;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 9999;
            box-shadow: 0 0 30px rgba(76, 175, 80, 0.5);
            transition: all 0.3s ease;
            animation: pulse 2s infinite;
            display: none;
        }
        @keyframes pulse {
            0% { box-shadow: 0 0 30px rgba(76, 175, 80, 0.5); }
            50% { box-shadow: 0 0 50px rgba(76, 175, 80, 0.8); }
            100% { box-shadow: 0 0 30px rgba(76, 175, 80, 0.5); }
        }
        #roomCodeInstructions {
            color: #fff;
            font-size: 18px;
            margin-top: 20px;
            text-align: center;
            position: fixed;
            top: calc(50% + 100px);
            left: 50%;
            transform: translateX(-50%);
            z-index: 1000;
            background: rgba(0, 0, 0, 0.8);
            padding: 15px 30px;
            border-radius: 10px;
            animation: fadeIn 0.5s ease-out;
        }
        @keyframes fadeIn {
            from { opacity: 0; transform: translate(-50%, 20px); }
            to { opacity: 1; transform: translate(-50%, 0); }
        }
        #loadingScreen {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 20px;
            border-radius: 10px;
            z-index: 2000;
            display: none;
        }
        #loadingMessage {
            margin-top: 10px;
            font-size: 18px;
        }
        #errorScreen {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            background: rgba(255, 0, 0, 0.9);
            color: white;
            padding: 30px;
            border-radius: 15px;
            z-index: 3000;
            display: none;
            max-width: 80%;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
        }
        #errorMessage {
            margin: 20px 0;
            font-size: 16px;
            white-space: pre-wrap;
            text-align: left;
        }
        #debugInfo {
            margin-top: 20px;
            font-size: 14px;
            color: #ddd;
            text-align: left;
            font-family: monospace;
            background: rgba(0, 0, 0, 0.3);
            padding: 10px;
            border-radius: 5px;
            max-height: 200px;
            overflow-y: auto;
        }
        .spinner {
            border: 4px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            border-top: 4px solid white;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 10px auto;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        #winScreen {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 30px;
            border-radius: 15px;
            text-align: center;
            z-index: 2000;
            display: none;
            animation: popIn 0.5s ease-out;
        }
        @keyframes popIn {
            0% { transform: translate(-50%, -50%) scale(0.5); opacity: 0; }
            100% { transform: translate(-50%, -50%) scale(1); opacity: 1; }
        }
        #winScreen h2 {
            color: #4CAF50;
            margin-bottom: 20px;
            font-size: 32px;
            text-shadow: 0 0 10px rgba(76, 175, 80, 0.5);
        }
        #winScreen p {
            font-size: 20px;
            margin: 15px 0;
            color: #fff;
        }
        #winScreen button {
            background: #4CAF50;
            border: none;
            color: white;
            padding: 15px 30px;
            font-size: 24px;
            cursor: pointer;
            border-radius: 8px;
            transition: all 0.3s;
            margin: 10px;
        }
        #winScreen button:hover {
            background: #45a049;
            transform: scale(1.1);
        }
        canvas {
            cursor: default !important;
            outline: none;
            z-index: 1;
        }
        #gameContainer {
            position: relative;
            width: 100%;
            height: 100%;
        }
        .no-cursor {
            cursor: none;
        }
        .game-canvas {
            outline: none;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
        }
        #guideInstructions {
            position: absolute;
            top: 20px;
            left: 20px;
            color: #4CAF50;
            font-size: 18px;
            text-shadow: 0 0 5px rgba(76, 175, 80, 0.5);
        }
        #guideView {
            display: none;
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000;
        }
        #guideCanvas {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: #111;
        }
    </style>
</head>
<body>
    <div id="startScreen">
        <h1>3D Maze Game</h1>
        <div class="instruction">Multiplayer maze game with unique roles</div>
        <div class="instruction">Create or join a room to play with 4 players</div>
        <button class="gameButton" id="multiplayerButton">Play Game</button>
    </div>

    <div id="roomCode" class="room-code"></div>
    <div id="roomCodeInstructions" class="room-code-instructions"></div>

    <div id="multiplayerMenu">
        <h2>Multiplayer Mode</h2>
        <button class="gameButton" id="createRoomButton">Create Room</button>
        <button class="gameButton" id="joinRoomButton">Join Room</button>
        <input type="text" id="roomCodeInput" placeholder="Enter Room Code" style="display: none;">
        <button class="backButton" id="backToMainButton">Back to Main Menu</button>
    </div>

    <div id="loadingScreen">
        <div class="spinner"></div>
        <div id="loadingMessage">Loading Game...</div>
    </div>

    <!-- Add new waiting and role assignment screens -->
    <div id="waitingScreen" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); text-align: center; background: rgba(0, 0, 0, 0.9); color: white; padding: 40px; border-radius: 20px; z-index: 2000; border: 3px solid #4CAF50; box-shadow: 0 0 30px rgba(76, 175, 80, 0.5);">
        <h2 style="color: #4CAF50; font-size: 32px; margin-bottom: 20px; text-shadow: 0 0 10px rgba(76, 175, 80, 0.5);">üéÆ Waiting for Players</h2>
        <div class="spinner"></div>
        <div id="waitingMessage" style="font-size: 20px; margin: 20px 0;">Waiting for players to join...</div>
                        <div id="playerCount" style="font-size: 18px; color: #4CAF50;">Players joined: 1/4</div>
        <div style="margin-top: 30px; text-align: center;">
            <div style="font-size: 18px; color: #ccc; margin-bottom: 10px;">Room Code:</div>
            <div id="waitingRoomCode" style="font-family: monospace; color: #4CAF50; cursor: pointer; padding: 15px 25px; border: 3px solid #4CAF50; border-radius: 10px; font-size: 32px; font-weight: bold; letter-spacing: 4px; background: rgba(76, 175, 80, 0.1); transition: all 0.3s; display: inline-block;" onclick="copyRoomCode(this)" title="Click to copy" onmouseover="this.style.background='rgba(76, 175, 80, 0.2)'" onmouseout="this.style.background='rgba(76, 175, 80, 0.1)'"></div>
            <div style="font-size: 14px; color: #999; margin-top: 10px;">Click to copy ‚Ä¢ Share with other players</div>
        </div>
    </div>

    <div id="roleAssignmentScreen" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); text-align: center; background: rgba(0, 0, 0, 0.9); color: white; padding: 40px; border-radius: 20px; z-index: 2000; border: 3px solid #FFD700; box-shadow: 0 0 30px rgba(255, 215, 0, 0.5);">
        <h2 style="color: #FFD700; font-size: 32px; margin-bottom: 20px; text-shadow: 0 0 10px rgba(255, 215, 0, 0.5);">üé≤ Assigning Roles</h2>
        <div class="spinner" style="border-top-color: #FFD700;"></div>
        <div style="font-size: 20px; margin: 20px 0;">All players joined! Assigning roles...</div>
        <div style="font-size: 16px; color: #ccc;">Please wait while roles are being assigned</div>
    </div>

    <div id="yourRoleScreen" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); text-align: center; background: rgba(0, 0, 0, 0.9); color: white; padding: 40px; border-radius: 20px; z-index: 2000; border: 3px solid #FF6B6B; box-shadow: 0 0 30px rgba(255, 107, 107, 0.5);">
        <h2 style="color: #FF6B6B; font-size: 32px; margin-bottom: 20px; text-shadow: 0 0 10px rgba(255, 107, 107, 0.5);">üé≠ Your Role</h2>
        <div id="assignedRole" style="font-size: 36px; font-weight: bold; margin: 20px 0; color: #4CAF50;"></div>
        <div id="roleDescription" style="font-size: 18px; margin: 20px 0; line-height: 1.5;"></div>
        <div style="font-size: 16px; color: #FFD700; margin-top: 20px;">Game starting in 3 seconds...</div>
    </div>

    <div id="errorScreen">
        <h2>Error</h2>
        <div id="errorMessage"></div>
        <div id="debugInfo"></div>
        <button onclick="location.reload()" style="margin-top: 15px; padding: 10px 20px; cursor: pointer; background: white; color: red; border: none; border-radius: 5px; font-weight: bold;">Reload Game</button>
    </div>

    <div id="winScreen">
        <h2>üéâ You Won! üéâ</h2>
        <p>Congratulations! You made it through the maze!</p>
        <p>Refresh the page to play again</p>
    </div>

    <div id="guideView" style="display: none;">
        <canvas id="guideCanvas"></canvas>
        <div id="guideInstructions">
            <span id="roleTitle">Guide View</span>
        </div>
    </div>

    <!-- Test button removed for cleaner UI -->

    <script>
        let scene, camera, renderer, controls;
        let maze, mazeGroup;
        const MAZE_SIZE = { width: 25, height: 25 };
        let keydownListener, keyupListener;
        let textureLoader;
        let architectWallMaterial = null; // Global material for architect walls
        let handleWallChangedCallCount = 0; // Track how many times handleWallChanged is called
        let gameMode = 'single';
        let multiplayerManager = null;
        let otherPlayers = {};
        let gameStarted = false;
        let playerRole = null;
        let gameTimer = null;
        let gameTimeLimit = 300000; // 5 minutes in milliseconds
        let guideCanvas, guideCtx;
        let playerPositions = {}; // Track positions by player ID
        let monsterPositions = {}; // Track monster positions by player ID
        let allPlayersJoined = false;
        let requiredPlayers = 4;
        let roomCode = null;
        let architectWallChanges = { added: new Set(), removed: new Set() }; // Track architect changes
        
        // Sound effects using Web Audio API
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
        
        function playSound(type) {
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);
            
            switch(type) {
                case 'footstep':
                    oscillator.frequency.value = 100;
                    oscillator.type = 'sine';
                    gainNode.gain.setValueAtTime(0.05, audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.05);
                    oscillator.start(audioContext.currentTime);
                    oscillator.stop(audioContext.currentTime + 0.05);
                    break;
                    
                case 'wall_place':
                    oscillator.frequency.value = 300;
                    oscillator.type = 'square';
                    gainNode.gain.setValueAtTime(0.2, audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.2);
                    oscillator.start(audioContext.currentTime);
                    oscillator.stop(audioContext.currentTime + 0.2);
                    break;
                    
                case 'wall_remove':
                    oscillator.frequency.value = 200;
                    oscillator.type = 'sawtooth';
                    gainNode.gain.setValueAtTime(0.2, audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.15);
                    oscillator.start(audioContext.currentTime);
                    oscillator.stop(audioContext.currentTime + 0.15);
                    break;
                    
                case 'win':
                    // Victory fanfare
                    [440, 554, 659, 880].forEach((freq, i) => {
                        const osc = audioContext.createOscillator();
                        const gain = audioContext.createGain();
                        osc.connect(gain);
                        gain.connect(audioContext.destination);
                        osc.frequency.value = freq;
                        osc.type = 'sine';
                        gain.gain.setValueAtTime(0.3, audioContext.currentTime + i * 0.15);
                        gain.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + i * 0.15 + 0.3);
                        osc.start(audioContext.currentTime + i * 0.15);
                        osc.stop(audioContext.currentTime + i * 0.15 + 0.3);
                    });
                    return; // Skip the default oscillator cleanup
                    
                case 'lose':
                    // Descending tone
                    oscillator.frequency.setValueAtTime(400, audioContext.currentTime);
                    oscillator.frequency.exponentialRampToValueAtTime(100, audioContext.currentTime + 0.5);
                    oscillator.type = 'triangle';
                    gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.5);
                    oscillator.start(audioContext.currentTime);
                    oscillator.stop(audioContext.currentTime + 0.5);
                    break;
                    
                case 'heartbeat':
                    // Double bass thump for heartbeat
                    const heartbeatGain = audioContext.createGain();
                    const heartbeatOsc = audioContext.createOscillator();
                    heartbeatOsc.connect(heartbeatGain);
                    heartbeatGain.connect(audioContext.destination);
                    
                    heartbeatOsc.frequency.value = 40; // Deep bass
                    heartbeatOsc.type = 'sine';
                    
                    // First thump
                    heartbeatGain.gain.setValueAtTime(0.4, audioContext.currentTime);
                    heartbeatGain.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.1);
                    heartbeatOsc.start(audioContext.currentTime);
                    
                    // Second thump
                    heartbeatGain.gain.setValueAtTime(0.3, audioContext.currentTime + 0.15);
                    heartbeatGain.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.25);
                    heartbeatOsc.stop(audioContext.currentTime + 0.3);
                    return;
                    
                case 'ambient_drone':
                    // Low ominous drone sound
                    oscillator.frequency.value = 55; // Very low frequency
                    oscillator.type = 'sawtooth';
                    gainNode.gain.setValueAtTime(0.03, audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 2.0);
                    oscillator.start(audioContext.currentTime);
                    oscillator.stop(audioContext.currentTime + 2.0);
                    break;
                    
                case 'monster_near':
                    // Ominous low rumble
                    oscillator.frequency.value = 50;
                    oscillator.type = 'sawtooth';
                    gainNode.gain.setValueAtTime(0.1, audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.3);
                    oscillator.start(audioContext.currentTime);
                    oscillator.stop(audioContext.currentTime + 0.3);
                    break;
                    
                case 'timer_warning':
                    // Urgent beep
                    oscillator.frequency.value = 800;
                    oscillator.type = 'square';
                    gainNode.gain.setValueAtTime(0.2, audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.1);
                    oscillator.start(audioContext.currentTime);
                    oscillator.stop(audioContext.currentTime + 0.1);
                    break;
            }
        }
        
        // Expose architectWallChanges globally so all players can access it
        window.architectWallChanges = architectWallChanges;
        let lastPositionUpdate = 0;
        const POSITION_UPDATE_INTERVAL = 50; // Reduced throttle for smoother updates
        let monsterTexture = null;
        // Add smoothing state variables at the top of the file, after other variable declarations
        let lastPlayerPos = null;
        let lastMonsterPos = null;
        const positionSmoothingFactor = 0.3;
        const rotationSmoothingFactor = 0.3;
        
        // Position interpolation storage
        let playerTargetPositions = {}; // Store target positions for smooth interpolation
        let monsterTargetPositions = {}; // Store target positions for smooth interpolation
        let lastPositionUpdateTime = {}; // Track last update time per player
        // Performance optimization variables
        let lastArrowUpdate = 0;
        const ARROW_UPDATE_INTERVAL = 100; // Update arrow every 100ms for better performance
        let rotationBuffer = [];
        const ROTATION_BUFFER_SIZE = 3; // Reduce buffer size for memory efficiency

        function createMonsterMesh() {
            // Create a plane geometry that always faces the camera
            const monsterGeometry = new THREE.PlaneGeometry(2, 2);
            const monsterMaterial = new THREE.MeshBasicMaterial({
                map: textureLoader.load('monster.png'),
                transparent: true,
                side: THREE.DoubleSide
            });
            const monster = new THREE.Mesh(monsterGeometry, monsterMaterial);
            
            // Create a container for the monster to handle positioning
            const monsterContainer = new THREE.Object3D();
            monsterContainer.add(monster);
            
            // Make the monster plane always face the camera
            monster.onBeforeRender = function(renderer, scene, camera) {
                monster.quaternion.copy(camera.quaternion);
            };
            
            return monsterContainer;
        }

        // Function to ensure player/monster representations exist
        function ensurePlayerRepresentation(playerId, role, position) {
            if (otherPlayers[playerId] || !scene) {
                return false;
            }
            
            let playerMesh;
            const heightOffset = 1.5; // Proper height above ground
            
            if (role === 'monster') {
                // Monster representation - red glowing cylinder
                playerMesh = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.6, 0.6, 3, 16),
                    new THREE.MeshPhongMaterial({ 
                        color: 0xff0000,
                        emissive: 0xff0000,
                        emissiveIntensity: 1.0
                    })
                );
            } else if (role === 'player') {
                // Player representation - bright green cylinder with yellow ring
                const playerGeometry = new THREE.Group();
                
                const body = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.5, 0.5, 2.5, 16),
                    new THREE.MeshPhongMaterial({ 
                        color: 0x00ff00,
                        emissive: 0x00ff00,
                        emissiveIntensity: 0.8
                    })
                );
                playerGeometry.add(body);
                
                const ring = new THREE.Mesh(
                    new THREE.TorusGeometry(0.6, 0.15, 8, 16),
                    new THREE.MeshPhongMaterial({
                        color: 0xffff00,
                        emissive: 0xffff00,
                        emissiveIntensity: 1.0
                    })
                );
                ring.position.y = 1.5;
                ring.rotation.x = Math.PI / 2;
                playerGeometry.add(ring);
                
                playerMesh = playerGeometry;
            }
            
            if (playerMesh && scene) {
                // Set position with proper height
                playerMesh.position.set(
                    position.x, 
                    position.y || heightOffset,  // Use provided Y or default height
                    position.z
                );
                playerMesh.visible = true;
                otherPlayers[playerId] = playerMesh;
                scene.add(playerMesh);
                return true;
            }
            
            return false;
        }

        // Smooth position interpolation function
        function smoothUpdatePosition(object, targetPosition, targetRotation, playerId, smoothingFactor = 0.2) {
            if (!object || !targetPosition) return;
            
            const now = Date.now();
            const lastUpdate = lastPositionUpdateTime[playerId] || 0;
            const timeDelta = now - lastUpdate;
            
            // Only update if enough time has passed to prevent over-updating
            if (timeDelta < 16) return; // ~60fps limit
            
            lastPositionUpdateTime[playerId] = now;
            
            // Smooth position interpolation
            object.position.x += (targetPosition.x - object.position.x) * smoothingFactor;
            object.position.y += (targetPosition.y - object.position.y) * smoothingFactor;
            object.position.z += (targetPosition.z - object.position.z) * smoothingFactor;
            
            // Smooth rotation interpolation if provided
            if (targetRotation) {
                object.rotation.x += (targetRotation.x - object.rotation.x) * smoothingFactor;
                object.rotation.y += (targetRotation.y - object.rotation.y) * smoothingFactor;
                object.rotation.z += (targetRotation.z - object.rotation.z) * smoothingFactor;
            }
            
            // Ensure object is visible but don't set it every frame
            if (!object.visible) {
                object.visible = true;
            }
        }

        function createRoom() {
            if (gameStarted) {
                return;
            }
            
            showLoadingScreen('Creating Room...');
            
            // Initialize multiplayer manager
            multiplayerManager = new MultiplayerManager();
            
            multiplayerManager.onConnectionSuccess = () => {
                multiplayerManager.createRoom();
            };

            multiplayerManager.onMazeDataReceived = (mazeData) => {
                maze = mazeData;
                maze.wallPositions = maze.wallPositions || [];
                
                if (playerRole && playerRole !== 'waiting') {
                    if (playerRole === 'guide' || playerRole === 'architect') {
                        initGuideView(mazeData);
                        if (playerRole === 'architect') {
                            try {
                                setupArchitectControls();
                            } catch (error) {
                                console.error('Error setting up architect controls:', error);
                            }
                        }
                    } else {
                        init(false);
                    }
                }
            };

            multiplayerManager.onRoomCreated = (roomCode) => {
                hideLoadingScreen();
                
                // Hide all menus
                hideAllMenus();
                
                // Show waiting screen
                document.getElementById('waitingScreen').style.display = 'block';
                document.getElementById('waitingRoomCode').textContent = roomCode;
                document.getElementById('playerCount').textContent = 'Players joined: 1/4';
                document.getElementById('waitingMessage').textContent = 'Waiting for 3 more players to join...';
                
                // Set the game mode but don't start yet
                gameMode = 'multiplayer';
                playerRole = 'waiting';
                allPlayersJoined = false;
                gameStarted = false;
                
                const generator = new MazeGenerator(MAZE_SIZE.width, MAZE_SIZE.height);
                maze = generator.generate();
                
                multiplayerManager.socket.send(JSON.stringify({
                    type: 'maze_data',
                    maze: maze
                }));
            };

            multiplayerManager.onGameReady = () => {
                allPlayersJoined = true;
                gameStarted = true;
                hideAllMenus();
                
                if (!maze) {
                    setTimeout(() => {
                        if (maze) {
                            multiplayerManager.onGameReady();
                        }
                    }, 100);
                    return;
                }
                
                setTimeout(() => {
                    if (playerRole === 'guide') {
                        initGuideView(maze);
                    } else if (playerRole === 'architect') {
                        initGuideView(maze);
                        try {
                            setupArchitectControls();
                        } catch (error) {
                            console.error('Error in architect setup:', error);
                        }
                    } else if (playerRole === 'player' || playerRole === 'monster') {
                        if (!isInitialized || !scene || !controls) {
                            init(true);
                        } else {
                            gameStarted = true;
                            if (controls) {
                                controls.enabled = true;
                            }
                        }
                    }
                }, 3000);
            };

            multiplayerManager.onRoleAssigned = (role, message) => {
                playerRole = role;
                
                document.getElementById('roleAssignmentScreen').style.display = 'none';
                document.getElementById('yourRoleScreen').style.display = 'block';
                document.getElementById('assignedRole').textContent = role.toUpperCase();
                
                let description = '';
                switch(role) {
                    case 'player':
                        description = 'Navigate through the maze to find the green exit. Use WASD to move and mouse to look around. Avoid the monster!';
                        break;
                    case 'guide':
                        description = 'Help the player reach the exit using your top-down 2D view. You can see the entire maze layout and all player positions.';
                        break;
                    case 'architect':
                        description = 'Architect: Click to add/remove walls.';
                        break;
                    case 'monster':
                        description = 'Hunt the player in first-person view! Use WASD to move and mouse to look around. Catch the player before they escape!';
                        break;
                    default:
                        description = message || 'Unknown role';
                }
                document.getElementById('roleDescription').textContent = description;
            };

            multiplayerManager.onPlayerJoined = (playerId, role) => {
                if (typeof window.playerJoinCount === 'undefined') {
                    window.playerJoinCount = 1;
                }
                window.playerJoinCount++;
                
                document.getElementById('playerCount').textContent = `Players joined: ${window.playerJoinCount}/4`;
                
                const playersNeeded = requiredPlayers - window.playerJoinCount;
                if (playersNeeded > 0) {
                    document.getElementById('waitingMessage').textContent = `Waiting for ${playersNeeded} more player${playersNeeded > 1 ? 's' : ''} to join...`;
                } else {
                    document.getElementById('waitingScreen').style.display = 'none';
                    document.getElementById('roleAssignmentScreen').style.display = 'block';
                    document.getElementById('waitingMessage').textContent = 'All players joined! Assigning roles...';
                }
                
                if (false && !otherPlayers[playerId] && (playerRole === 'player' || playerRole === 'monster' || playerRole === 'architect')) {
                    
                    // Create a more visible representation for players
                    let playerMesh;
                    if (role === 'monster') {
                        // Monster representation - red cylinder for all viewers
                        playerMesh = new THREE.Mesh(
                            new THREE.CylinderGeometry(0.5, 0.5, 3, 16), // Made bigger and more detailed
                            new THREE.MeshPhongMaterial({ 
                                color: 0xff0000,
                                emissive: 0xff0000,
                                emissiveIntensity: 0.8 // Increased glow
                            })
                        );
                    } else if (role === 'player') {
                        // Player representation - bright green cylinder for all viewers
                        const playerGeometry = new THREE.Group();
                        
                        // Main body - taller and brighter cylinder
                        const body = new THREE.Mesh(
                            new THREE.CylinderGeometry(0.4, 0.4, 2.5, 8),
                            new THREE.MeshPhongMaterial({ 
                                color: 0x00ff00,
                                emissive: 0x00ff00,
                                emissiveIntensity: 0.5
                            })
                        );
                        playerGeometry.add(body);
                        
                        // Add glowing ring at the top
                        const ring = new THREE.Mesh(
                            new THREE.TorusGeometry(0.5, 0.1, 8, 16),
                            new THREE.MeshPhongMaterial({
                                color: 0xffff00,
                                emissive: 0xffff00,
                                emissiveIntensity: 0.7
                            })
                        );
                        ring.position.y = 1.5;
                        ring.rotation.x = Math.PI / 2;
                        playerGeometry.add(ring);
                        
                        playerMesh = playerGeometry;
                    }
                    
                    if (playerMesh && scene) {
                        otherPlayers[playerId] = playerMesh;
                        otherPlayers[playerId].position.set(0, 2, 0); // Raised higher for visibility
                        otherPlayers[playerId].visible = true;
                        scene.add(otherPlayers[playerId]);
                    } else {
                        console.error('‚ùå Failed to add player representation - scene not ready:', !!scene, 'playerMesh:', !!playerMesh);
                        
                        // Store for later addition when scene is ready
                        if (playerMesh) {
                            if (!window.pendingPlayers) window.pendingPlayers = [];
                            window.pendingPlayers.push({
                                playerId: playerId,
                                role: role,
                                mesh: playerMesh
                            });
                        }
                    }
                }
            };

            multiplayerManager.onRoleAssigned = (role, message) => {
                playerRole = role;
                
                // Hide role assignment screen and show your role screen
                document.getElementById('roleAssignmentScreen').style.display = 'none';
                document.getElementById('yourRoleScreen').style.display = 'block';
                
                // Update role information
                document.getElementById('assignedRole').textContent = role.toUpperCase();
                
                // Set role descriptions
                let description = '';
                switch(role) {
                    case 'player':
                        description = 'Navigate through the maze to find the green exit. Use WASD to move and mouse to look around. Avoid the monster!';
                        break;
                    case 'guide':
                        description = 'Help the player reach the exit using your top-down 2D view. You can see the entire maze layout and all player positions.';
                        break;
                    case 'architect':
                        description = 'Architect: Click to add/remove walls.';
                        break;
                    case 'monster':
                        description = 'Hunt the player in first-person view! Use WASD to move and mouse to look around. Catch the player before they escape!';
                        break;
                    default:
                        description = message || 'Unknown role';
                }
                document.getElementById('roleDescription').textContent = description;
                
                // DON'T initialize the scene yet - wait for onGameReady
                // This prevents race conditions with maze data loading
            };

            multiplayerManager.onGameReady = () => {
                allPlayersJoined = true;
                gameStarted = true;
                
                // Hide all UI screens
                hideAllMenus();
                
                // Wait for maze data if not available
                if (!maze) {
                    setTimeout(() => {
                        if (maze) {
                            multiplayerManager.onGameReady();
                        } else {
                            console.error('üéÆ Still no maze data after waiting');
                        }
                    }, 100);
                    return;
                }
                
                // REMOVED DUPLICATE onGameReady HANDLER - Using the complete one below
            };

            multiplayerManager.onPlayerLeft = (playerId) => {
                if (otherPlayers[playerId]) {
                    scene.remove(otherPlayers[playerId]);
                    delete otherPlayers[playerId];
                }
                
                // Clean up position tracking for disconnected player
                delete playerPositions[playerId];
                delete monsterPositions[playerId];
                
                // Update UI to show disconnection and waiting state
                const currentPlayers = Object.keys(otherPlayers).length + 1;
                if (currentPlayers < requiredPlayers) {
                    allPlayersJoined = false;
                    gameStarted = false;
                    
                    // Show waiting message
                    const instructionsElement = document.getElementById('roomCodeInstructions');
                    instructionsElement.style.display = 'block';
                    instructionsElement.textContent = `A player has disconnected ‚Ä¢ Waiting for ${requiredPlayers - currentPlayers} more player${requiredPlayers - currentPlayers > 1 ? 's' : ''}...`;
                    
                    // Show room code again
                    const roomCodeElement = document.getElementById('roomCode');
                    roomCodeElement.style.display = 'block';
                }
            };

            multiplayerManager.onError = (error) => {
                console.error('Error in multiplayer:', error);
                hideLoadingScreen();
                alert(error);
                showMultiplayerMenu();
            };

            // Start connection
            multiplayerManager.connect();
        }

        function startMultiplayerGame() {
            if (!gameStarted) {
                gameStarted = true;
                
                // Hide all menus
                document.getElementById('startScreen').style.display = 'none';
                document.getElementById('multiplayerMenu').style.display = 'none';
                document.getElementById('winScreen').style.display = 'none';
                
                // Set up multiplayer components
                setupMultiplayer();
                
                // Start the animation loop
                animate();
            }
        }

        // Single player removed - multiplayer only game

        function hideAllMenus() {
            const menuElements = [
                'startScreen',
                'multiplayerMenu',
                'winScreen',
                'roomCode',
                'roomCodeInstructions',
                'loadingScreen',
                'errorScreen',
                'guideView',
                'waitingScreen',
                'roleAssignmentScreen',
                'yourRoleScreen',
                'simple-waiting'
            ];
            
            menuElements.forEach(elementId => {
                const element = document.getElementById(elementId);
                if (element) {
                    element.style.display = 'none';
                }
            });
        }

        function cleanupRenderer() {
            if (window.animationFrameId) {
                cancelAnimationFrame(window.animationFrameId);
                window.animationFrameId = null;
            }
            
            if (renderer && renderer.domElement && renderer.domElement.parentNode) {
                // Remove pointer lock event listeners
                document.removeEventListener('pointerlockchange', onPointerLockChange);
                document.removeEventListener('pointerlockerror', onPointerLockError);
                document.removeEventListener('mousemove', onMouseMove);
                
                // Exit pointer lock if active
                if (document.pointerLockElement === renderer.domElement) {
                    document.exitPointerLock();
                }
                
                renderer.domElement.parentNode.removeChild(renderer.domElement);
                renderer.dispose();
                renderer = null;
            }
            
            // Clean up event listeners
            if (keydownListener) {
                document.removeEventListener('keydown', keydownListener);
                keydownListener = null;
            }
            if (keyupListener) {
                document.removeEventListener('keyup', keyupListener);
                keyupListener = null;
            }
            
            // Reset initialization flags
            isInitialized = false;
            animateDebugCount = 0;
        }

        function cleanupMultiplayer() {
            if (multiplayerManager) {
                multiplayerManager.disconnect();
                multiplayerManager = null;
            }
        }

        let isInitialized = false;
        
        function init(shouldStartAnimation = true) {
            // Prevent initialization for waiting/unassigned roles
            if (!playerRole || playerRole === 'waiting') {
                return;
            }
            
            // Allow proper re-initialization when needed
            if (isInitialized && (playerRole === 'player' || playerRole === 'monster') && scene && controls && !shouldStartAnimation) {
                gameStarted = true;
                if (controls) {
                    controls.enabled = true;
                }
                return;
            }
            
            try {
                // Guide and architect both get only 2D view
                if (playerRole === 'guide' || playerRole === 'architect') {
                    // Initialize guide view
                    document.body.style.cursor = 'default';
                    if (maze) {
                        initGuideView(maze);
                    } else {
                        console.error('‚ùå No maze data available for 2D view');
                        document.body.innerHTML = '<div style="color: red; text-align: center; margin-top: 50px;">Error: No maze data available. Please try refreshing the page.</div>';
                    }
                    return;
                }


                // Both player and monster get the same 3D setup
                scene = new THREE.Scene();
                scene.background = new THREE.Color(0x1a1a1a); // Dark gray for better visibility
                
                // Create renderer
                renderer = new THREE.WebGLRenderer({ 
                    antialias: true,
                    powerPreference: "high-performance"
                });
                renderer.setSize(window.innerWidth, window.innerHeight);
                renderer.setPixelRatio(window.devicePixelRatio);
                
                // Style the renderer canvas properly
                renderer.domElement.style.position = 'fixed';
                renderer.domElement.style.top = '0';
                renderer.domElement.style.left = '0';
                renderer.domElement.style.width = '100%';
                renderer.domElement.style.height = '100%';
                renderer.domElement.style.zIndex = '1';
                renderer.domElement.style.display = 'block';
                
                // For architect, make the canvas slightly transparent so they can see both views
                if (playerRole === 'architect') {
                    renderer.domElement.style.opacity = '0.8';
                    renderer.domElement.style.zIndex = '10';
                }
                
                document.body.appendChild(renderer.domElement);
                
                // Create first-person camera
                camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
                
                // Add FLASHLIGHT for player/monster - bright and wide for good visibility
                const flashlight = new THREE.SpotLight(0xffffee, 7.0, 60, Math.PI / 2.5, 0.2, 1.2);
                flashlight.position.set(0, 0, 0);
                flashlight.target.position.set(0, 0, -1);
                camera.add(flashlight);
                camera.add(flashlight.target);
                
                // Make scene, camera, and renderer globally accessible for wall updates
                window.scene = scene;
                window.camera = camera;
                window.renderer = renderer;
                window.flashlight = flashlight;
                
                // Load textures
                textureLoader = new THREE.TextureLoader();
                
                // Generate new maze only for single player mode
                if (gameMode === 'single' && !maze) {
                    const generator = new MazeGenerator(MAZE_SIZE.width, MAZE_SIZE.height);
                    maze = generator.generate();
                }
                
                if (!maze) {
                    console.error('‚ùå No maze data available when trying to init 3D view');
                    throw new Error('No maze data available');
                }

                // Clean up any existing role labels first
                const existingLabels = document.querySelectorAll('.role-label');
                existingLabels.forEach(label => label.remove());

                // Set starting position based on role
                if (playerRole === 'monster') {
                    // Place monster at a random position
                    const randomCell = getRandomEmptyCell(maze);
                    camera.position.set(
                        randomCell.x * maze.cellSize,
                        1.5,
                        randomCell.z * maze.cellSize
                    );
                    
                    // Ensure game is started for monster
                    gameStarted = true;

                    // Add monster UI overlay
                    const monsterInstructions = document.createElement('div');
                    monsterInstructions.className = 'role-label';
                    monsterInstructions.style.cssText = `
                        position: fixed;
                        top: 20px;
                        left: 20px;
                        color: #ff0000;
                        font-size: 18px;
                        text-shadow: 0 0 5px rgba(255, 0, 0, 0.5);
                        z-index: 1000;
                    `;
                    monsterInstructions.innerHTML = `Monster View`;
                    document.body.appendChild(monsterInstructions);

                    // Timer will be started by game_ready message for sync
                } else if (playerRole === 'player') {
                    // Set player starting position
                    camera.position.set(
                        maze.startPosition.x,
                        1.5,
                        maze.startPosition.z
                    );
                    
                    // CRITICAL: Enable game for player
                    gameStarted = true;

                    // Add player UI overlay
                    const playerInstructions = document.createElement('div');
                    playerInstructions.className = 'role-label';
                    playerInstructions.style.cssText = `
                        position: fixed;
                        top: 20px;
                        left: 20px;
                        color: #4CAF50;
                        font-size: 18px;
                        text-shadow: 0 0 5px rgba(76, 175, 80, 0.5);
                        z-index: 1000;
                    `;
                    playerInstructions.innerHTML = `Player - Enhanced Horror Effects Active`;
                    document.body.appendChild(playerInstructions);
                }

                // Hide guide view for all 3D roles (player, monster only, not architect)
                const guideView = document.getElementById('guideView');
                if (guideView) {
                    guideView.style.display = 'none';
                }
                
                // Add camera to scene (needed for attached flashlight to work)
                scene.add(camera);
                
                // Generate maze geometry
                mazeGroup = new THREE.Group();
                generateNewMaze();
                
                // Set up controls - only for non-player/monster roles
                if (playerRole !== 'player' && playerRole !== 'monster') {
                    controls = setupControls();
                } else {
                    // Player and monster use simple movement system only
                    controls = { enabled: true, update: function() {} }; // Dummy controls object
                }
                
                // Start ambient horror sounds for player
                if (playerRole === 'player') {
                    setInterval(() => {
                        if (gameStarted && playerRole === 'player') {
                            playSound('ambient_drone');
                        }
                    }, 8000); // Play ambient drone every 8 seconds
                }
                
                // ALWAYS start animation for 3D views to prevent black screen
                animate();
                
                // Set initial game state - controls will be enabled when game is ready
                gameStarted = shouldStartAnimation;
                if (shouldStartAnimation) {
                    
                    // Request pointer lock for player and monster, but not architect - DISABLED
                    // if (playerRole !== 'architect') {
                    //     renderer.domElement.requestPointerLock();
                    //     console.log('üé¨ Pointer lock requested');
                    // }
                } else {
                }
                
                if (playerRole !== 'architect') {
                }
                
                // Mark as initialized for 3D roles
                if (playerRole === 'player' || playerRole === 'monster') {
                    isInitialized = true;
                    
                    // Add any pending player representations that were waiting for scene
                    addPendingPlayers();
                }
            } catch (error) {
                console.error('‚ùå Error initializing game:', error);
                // Show detailed error information
                const errorDiv = document.createElement('div');
                errorDiv.style.cssText = `
                    position: fixed;
                    top: 50%;
                    left: 50%;
                    transform: translate(-50%, -50%);
                    background: rgba(0, 0, 0, 0.9);
                    color: white;
                    padding: 20px;
                    border-radius: 10px;
                    text-align: center;
                    z-index: 9999;
                    max-width: 80%;
                `;
                errorDiv.innerHTML = `
                    <h3>üö® Game Initialization Error</h3>
                    <p>Role: ${playerRole || 'Unknown'}</p>
                    <p>Maze available: ${!!maze ? 'Yes' : 'No'}</p>
                    <p>Scene exists: ${!!scene ? 'Yes' : 'No'}</p>
                    <p>Error: ${error.message}</p>
                    <button onclick="location.reload()" style="margin-top: 15px; padding: 10px 20px; background: #ff4444; color: white; border: none; border-radius: 5px; cursor: pointer;">
                        Reload Game
                    </button>
                `;
                document.body.appendChild(errorDiv);
            }
        }

        function generateNewMaze() {
            if (mazeGroup) {
                // Remove all objects from the scene
                while(scene.children.length > 0){ 
                    scene.remove(scene.children[0]); 
                }
                mazeGroup = new THREE.Group();
            }

            // Initialize maze.wallPositions array
            if (!maze.wallPositions) {
                maze.wallPositions = [];
            }

            mazeGroup = new THREE.Group();
            
            // Add static lights in a sparser grid pattern
            const mazeWidth = MAZE_SIZE.width * maze.cellSize;
            const mazeHeight = MAZE_SIZE.height * maze.cellSize;
            
            // Calculate positions for a few strategic lights
            const lights = [
                // Center light
                {x: 0, z: 0, intensity: 8.0, distance: 70},
                
                // Four quadrant lights
                {x: -mazeWidth/4, z: -mazeHeight/4, intensity: 6.0, distance: 50},
                {x: mazeWidth/4, z: -mazeHeight/4, intensity: 6.0, distance: 50},
                {x: -mazeWidth/4, z: mazeHeight/4, intensity: 6.0, distance: 50},
                {x: mazeWidth/4, z: mazeHeight/4, intensity: 6.0, distance: 50},
                
                // Additional corner lights
                {x: -mazeWidth/2, z: -mazeHeight/2, intensity: 5.0, distance: 40},
                {x: mazeWidth/2, z: -mazeHeight/2, intensity: 5.0, distance: 40},
                {x: -mazeWidth/2, z: mazeHeight/2, intensity: 5.0, distance: 40},
                {x: mazeWidth/2, z: mazeHeight/2, intensity: 5.0, distance: 40}
            ];
            
            // HORROR ATMOSPHERIC LIGHTING - Balanced for gameplay
            const ambientLight = new THREE.AmbientLight(0x4a4a4a, 0.45); // Better visibility
            scene.add(ambientLight);
            
            // Directional light for good visibility
            const directionalLight = new THREE.DirectionalLight(0x5a5a6a, 0.5);
            directionalLight.position.set(10, 20, 10);
            directionalLight.target.position.set(0, 0, 0);
            scene.add(directionalLight);
            scene.add(directionalLight.target);
            
            // Add light fog for atmosphere
            scene.fog = new THREE.FogExp2(0x000000, 0.025); // Light fog
            
            // Add red flickering lights spread throughout the entire maze
            const flickeringLights = [];
            
            // Create lights throughout the entire maze area with better distribution
            const lightMazeWidth = MAZE_SIZE.width * maze.cellSize;
            const lightMazeHeight = MAZE_SIZE.height * maze.cellSize;
            
            // Use smaller spacing for more lights - every 2 blocks instead of 4
            const spacing = maze.cellSize * 2; // Every 2 blocks for better coverage
            
            // Calculate the actual maze boundaries
            const startX = -lightMazeWidth/2;
            const endX = lightMazeWidth/2;
            const startZ = -lightMazeHeight/2;
            const endZ = lightMazeHeight/2;
            
            // Create ominous red flickering lights - bright for good visibility
            for (let x = startX; x <= endX; x += spacing) {
                for (let z = startZ; z <= endZ; z += spacing) {
                    const flickerLight = new THREE.PointLight(0xdd2222, 4.5, 55); // Much brighter red lights
                    flickerLight.position.set(x, 7, z);
                    
                    flickeringLights.push({
                        light: flickerLight,
                        baseIntensity: 4.5,
                        isOn: Math.random() > 0.3, // Most lights start ON (70%)
                        lastChange: 0,
                        changeInterval: 300 + Math.random() * 1000 // Slower, ominous flickering
                    });
                    scene.add(flickerLight);
                }
            }
            
            
            // Store flickering lights globally for animation
            window.flickeringLights = flickeringLights;

            // Load simple wall texture for performance
            const wallTexture = textureLoader.load('wall.jpg');
            wallTexture.wrapS = wallTexture.wrapT = THREE.RepeatWrapping;
            wallTexture.repeat.set(1, 1);

            // Create wall geometry and material - using simple material for performance
            const wallGeometry = new THREE.BoxGeometry(maze.cellSize, maze.wallHeight, maze.cellSize);
            const wallMaterial = new THREE.MeshLambertMaterial({
                map: wallTexture,
                color: 0xffffff
            });

            // Create architect wall material for reuse
            const architectWallTexture = textureLoader.load('wall.jpg');
            architectWallTexture.wrapS = architectWallTexture.wrapT = THREE.RepeatWrapping;
            architectWallTexture.repeat.set(1, 1);
            
            architectWallMaterial = new THREE.MeshPhongMaterial({
                map: architectWallTexture,
                color: 0xff0000, // Red color for architect walls
                specular: 0x222222,
                shininess: 10,
                transparent: false,
                opacity: 1.0,
                side: THREE.FrontSide,
                depthWrite: true,
                depthTest: true
            });

            // Clear existing walls array
            maze.wallPositions = [];

            function addWall(x, z) {
                const wall = new THREE.Mesh(wallGeometry, wallMaterial);
                wall.position.set(x * maze.cellSize, maze.wallHeight / 2, z * maze.cellSize);
                wall.castShadow = true;
                wall.receiveShadow = true;
                wall.matrixAutoUpdate = false; // Optimize performance
                wall.userData = { gridX: x, gridZ: z }; // Store grid coordinates for architect functionality
                wall.updateMatrix();
                mazeGroup.add(wall);
                
                maze.wallPositions.push({ x: x * maze.cellSize, z: z * maze.cellSize });
            }

            // Clear existing walls
            while(mazeGroup.children.length > 0) {
                const obj = mazeGroup.children[0];
                obj.geometry.dispose();
                obj.material.dispose();
                mazeGroup.remove(obj);
            }

            // Add maze walls
            for (let y = 0; y < MAZE_SIZE.height; y++) {
                for (let x = 0; x < MAZE_SIZE.width; x++) {
                    if (maze.maze[y][x] === 1) {
                        addWall(x, y);
                    }
                }
            }

            // Add boundary walls
            for (let x = -1; x <= MAZE_SIZE.width; x++) {
                addWall(x, -1);
                addWall(x, MAZE_SIZE.height);
            }

            for (let z = -1; z <= MAZE_SIZE.height; z++) {
                addWall(-1, z);
                addWall(MAZE_SIZE.width, z);
            }

            // Add textured floor
            const floorGeometry = new THREE.PlaneGeometry(
                (MAZE_SIZE.width + 2) * maze.cellSize,
                (MAZE_SIZE.height + 2) * maze.cellSize
            );
            
            // Load simple floor texture for performance
            const floorTexture = textureLoader.load('floor.webp');
            floorTexture.wrapS = floorTexture.wrapT = THREE.RepeatWrapping;
            floorTexture.repeat.set(4, 4);
            
            const floorMaterial = new THREE.MeshLambertMaterial({
                map: floorTexture,
                color: 0xffffff
            });
            const floor = new THREE.Mesh(floorGeometry, floorMaterial);
            floor.rotation.x = -Math.PI / 2;
            floor.position.set(
                (MAZE_SIZE.width * maze.cellSize) / 2,
                0,
                (MAZE_SIZE.height * maze.cellSize) / 2
            );
            mazeGroup.add(floor);

            // Dark patches will be added dynamically when walls are removed

            // Add textured ceiling
            const ceilingGeometry = new THREE.PlaneGeometry(
                (MAZE_SIZE.width + 2) * maze.cellSize,
                (MAZE_SIZE.height + 2) * maze.cellSize
            );
            
            // Load simple ceiling texture for performance
            const ceilingTexture = textureLoader.load('ceiling.jpg');
            ceilingTexture.wrapS = ceilingTexture.wrapT = THREE.RepeatWrapping;
            ceilingTexture.repeat.set(3, 3);
            
            const ceilingMaterial = new THREE.MeshLambertMaterial({
                map: ceilingTexture,
                color: 0xffffff,
                side: THREE.DoubleSide
            });
            const ceiling = new THREE.Mesh(ceilingGeometry, ceilingMaterial);
            ceiling.rotation.x = -Math.PI / 2; // Face downward correctly
            ceiling.position.set(
                (MAZE_SIZE.width * maze.cellSize) / 2,
                maze.wallHeight - 0.5, // Just below the top of walls
                (MAZE_SIZE.height * maze.cellSize) / 2
            );
            mazeGroup.add(ceiling);

            // Add end marker with improved material
            const endMarkerGeometry = new THREE.CylinderGeometry(0.4, 0.4, 0.1, 32);
            const endMarkerMaterial = new THREE.MeshPhongMaterial({ 
                color: 0x00ff00,
                emissive: 0x00ff00,
                emissiveIntensity: 0.5,
                transparent: false,
                opacity: 1.0,
                depthWrite: true
            });
            const endMarker = new THREE.Mesh(endMarkerGeometry, endMarkerMaterial);
            
            // Place end marker at the correct world position (don't multiply by cellSize again)
            endMarker.position.set(
                maze.endPosition.x,
                0.05,
                maze.endPosition.z
            );
            
            // Add point light to end marker for glow
            const endLight = new THREE.PointLight(0x00ff00, 1, 5);
            endLight.position.copy(endMarker.position);
            endLight.position.y = 1;
            
            mazeGroup.add(endMarker);
            mazeGroup.add(endLight);

            // Add the entire maze group to the scene
            scene.add(mazeGroup);
        }

        function checkCollision(position) {
            if (!maze || !maze.wallPositions || !Array.isArray(maze.wallPositions)) {
                return { x: false, z: false };
            }

            const playerRadius = 0.5;
            const wallBuffer = 0.3;
            let collisionX = false;
            let collisionZ = false;
            let nearestWallDist = Infinity;
            let slideX = 0;
            let slideZ = 0;
            
            // Check collision with each wall
            for (const wall of maze.wallPositions) {
                // Calculate distances for each axis
                const dx = position.x - wall.x;
                const dz = position.z - wall.z;
                const distance = Math.sqrt(dx * dx + dz * dz);
                
                // Calculate the minimum distance needed to avoid collision
                const minDistance = maze.cellSize / 2 + playerRadius + wallBuffer;
                
                // If we're within collision range
                if (distance < minDistance) {
                    // Update nearest wall distance
                    if (distance < nearestWallDist) {
                        nearestWallDist = distance;
                        
                        // Calculate normalized direction from wall to player
                        const nx = dx / distance;
                        const nz = dz / distance;
                        
                        // Calculate slide vector
                        const penetration = minDistance - distance;
                        slideX = nx * penetration;
                        slideZ = nz * penetration;
                    }
                    
                    // Set collision flags based on approach angle
                    const dotX = Math.abs(dx / distance);
                    const dotZ = Math.abs(dz / distance);
                    
                    if (dotX > 0.7) collisionX = true;
                    if (dotZ > 0.7) collisionZ = true;
                }
            }
            
            return {
                x: collisionX,
                z: collisionZ,
                slideX: slideX,
                slideZ: slideZ
            };
        }

        function setupControls() {
            const moveSpeed = playerRole === 'architect' ? 0.2 : 0.15; // Same speed for monster and player
            const turnSpeed = 0.06;
            let isPointerLocked = false;
            
            const controls = {
                enabled: true,
                update: null
            };
            
            const keys = {
                forward: false,
                backward: false,
                left: false,
                right: false
            };

            // Remove any existing listeners
            if (keydownListener) document.removeEventListener('keydown', keydownListener);
            if (keyupListener) document.removeEventListener('keyup', keyupListener);

            function onMouseMove(event) {
                if (isPointerLocked && (playerRole === 'player' || playerRole === 'monster')) {
                    camera.rotation.y -= event.movementX * 0.002;
                }
                // Architect doesn't need mouse look - they have fixed overhead view
            }

            function onPointerLockChange() {
                isPointerLocked = document.pointerLockElement === renderer.domElement;
            }

            function onPointerLockError() {
                console.error('Pointer lock error');
            }

            document.addEventListener('pointerlockchange', onPointerLockChange);
            document.addEventListener('pointerlockerror', onPointerLockError);
            document.addEventListener('mousemove', onMouseMove);

            if (renderer && renderer.domElement) {
                renderer.domElement.addEventListener('click', (event) => {
                                    // Architect uses 2D view, so no 3D clicking
                if (playerRole !== 'architect') {
                        // Mouse lock disabled - user prefers free mouse movement
                    }
                });
                
                // Handle right-click for 3D view only (architect uses 2D)
                renderer.domElement.addEventListener('contextmenu', (event) => {
                    if (playerRole !== 'architect') {
                        // Only handle 3D right-click for non-architects
                    }
                });
            }

            document.addEventListener('keydown', (e) => {
                if (e.key === 'Escape' && isPointerLocked) {
                    document.exitPointerLock();
                }
            });

            keydownListener = (e) => {
                // Debug key presses for player and monster
                if ((playerRole === 'player' || playerRole === 'monster') && ['w','s','a','d','arrowup','arrowdown','arrowleft','arrowright'].includes(e.key.toLowerCase())) {
                }
                
                switch(e.key.toLowerCase()) {
                    case 'w':
                    case 'arrowup':
                        keys.forward = true;
                        break;
                    case 's':
                    case 'arrowdown':
                        keys.backward = true;
                        break;
                    case 'a':
                    case 'arrowleft':
                        keys.left = true;
                        break;
                    case 'd':
                    case 'arrowright':
                        keys.right = true;
                        break;
                }
            };

            keyupListener = (e) => {
                switch(e.key.toLowerCase()) {
                    case 'w':
                    case 'arrowup':
                        keys.forward = false;
                        break;
                    case 's':
                    case 'arrowdown':
                        keys.backward = false;
                        break;
                    case 'a':
                    case 'arrowleft':
                        keys.left = false;
                        break;
                    case 'd':
                    case 'arrowright':
                        keys.right = false;
                        break;
                }
            };

            document.addEventListener('keydown', keydownListener);
            document.addEventListener('keyup', keyupListener);

            controls.update = function updateControls() {
                if (!controls.enabled || !camera || !maze) {
                    // Debug why controls aren't updating
                    if (playerRole === 'monster' && animateDebugCount < 5) {
                        // Debug check removed
                    }
                    return;
                }

                const moveSpeed = 0.15; // Same speed for both monster and player
                const turnSpeed = 0.06;
                const newPosition = camera.position.clone();
                const oldPosition = camera.position.clone();
                
                // Debug movement for both roles
                if (animateDebugCount === 2) {
                    if (playerRole === 'player' || playerRole === 'monster') {
                        console.log({
                            enabled: controls.enabled,
                            keysPressed: Object.entries(keys).filter(([k,v]) => v),
                            position: {x: camera.position.x, z: camera.position.z}
                        });
                    }
                }

                // First-person movement for player and monster (WITH collision detection)
                let moveVector = new THREE.Vector3(0, 0, 0);
                    if (keys.forward) {
                        moveVector.x -= Math.sin(camera.rotation.y) * moveSpeed;
                        moveVector.z -= Math.cos(camera.rotation.y) * moveSpeed;
                    }
                    if (keys.backward) {
                        moveVector.x += Math.sin(camera.rotation.y) * moveSpeed;
                        moveVector.z += Math.cos(camera.rotation.y) * moveSpeed;
                    }
                    if (keys.left) {
                        camera.rotation.y += turnSpeed;
                    }
                    if (keys.right) {
                        camera.rotation.y -= turnSpeed;
                    }
                    
                    // Apply movement and check collision for non-architects
                    if (moveVector.length() > 0) {
                        // Try to move to new position
                        const targetPos = {
                            x: newPosition.x + moveVector.x,
                            z: newPosition.z + moveVector.z
                        };
                        
                        // Check collision at target position
                        const collision = checkCollision(targetPos);
                        
                        // If there's a collision, try to slide along walls
                        if (collision.x || collision.z) {
                            if (!collision.x) newPosition.x = targetPos.x;
                            if (!collision.z) newPosition.z = targetPos.z;
                            
                            // Apply sliding motion if available
                            if (collision.slideX || collision.slideZ) {
                                newPosition.x += collision.slideX * 0.5;
                                newPosition.z += collision.slideZ * 0.5;
                            }
                        } else {
                            // No collision, move freely
                            newPosition.x = targetPos.x;
                            newPosition.z = targetPos.z;
                        }
                    }

                // Update position and send update if changed
                camera.position.copy(newPosition);
                
                // Debug successful movement (once)
                if ((camera.position.x !== oldPosition.x || camera.position.z !== oldPosition.z) && animateDebugCount === 1) {
                }
                
                if (camera.position.x !== oldPosition.x || camera.position.z !== oldPosition.z) {
                    if (multiplayerManager && multiplayerManager.connected) {
                        multiplayerManager.sendPosition(camera.position, camera.rotation);
                    }
                }
            };

            return controls;
        }

        function showWinScreen() {
            document.getElementById('winScreen').style.display = 'block';
            // Reset game state
            gameStarted = false;
        }

        // Show the multiplayer menu
        function showMultiplayerMenu() {
            if (gameStarted) {
                cleanupRenderer();
                cleanupMultiplayer();
            }
            
            gameStarted = false;
            gameMode = 'single'; // Reset game mode
            hideAllMenus();
            document.getElementById('multiplayerMenu').style.display = 'block';
            document.getElementById('createRoomButton').style.display = 'block';
            document.getElementById('joinRoomButton').style.display = 'block';
        }

        // Show join room input
        function showJoinRoom() {
            document.getElementById('createRoomButton').style.display = 'none';
            document.getElementById('joinRoomButton').style.display = 'none';
            document.getElementById('roomCodeInput').style.display = 'block';
            document.getElementById('roomCodeInput').value = '';
        }

        function joinRoom() {
            const roomCode = document.getElementById('roomCodeInput').value.trim().toUpperCase();
            if (!roomCode) {
                alert('Please enter a room code');
                return;
            }

            showLoadingScreen('Joining Room...');
            
            // Initialize multiplayer manager
            multiplayerManager = new MultiplayerManager();
            
            // Set up callbacks
            multiplayerManager.onConnectionSuccess = () => {
                multiplayerManager.joinRoom(roomCode);
            };

            multiplayerManager.onMazeDataReceived = (mazeData) => {
                maze = mazeData;
                maze.wallPositions = maze.wallPositions || [];
                
                // Now that we have maze data, we can safely initialize the scene
                // But only if we have a proper role assigned
                if (playerRole && playerRole !== 'waiting') {
                    if (playerRole === 'guide' || playerRole === 'architect') {
                        initGuideView(mazeData);
                        if (playerRole === 'architect') {
                            try {
                                setupArchitectControls();
                            } catch (error) {
                                console.error('Error setting up architect controls:', error);
                            }
                        }
                    } else {
                        init(false);
                    }
                } else {
                }
            };

            multiplayerManager.onRoomJoined = () => {
                hideLoadingScreen();
                
                // Hide all menus
                hideAllMenus();
                
                // Show simple waiting message
                const waitingDiv = document.createElement('div');
                waitingDiv.id = 'simple-waiting';
                waitingDiv.style.cssText = `
                    position: fixed;
                    top: 50%;
                    left: 50%;
                    transform: translate(-50%, -50%);
                    color: white;
                    font-size: 24px;
                    text-align: center;
                    z-index: 1000;
                `;
                waitingDiv.innerHTML = 'Waiting for players...';
                document.body.appendChild(waitingDiv);
                
                // Set the game mode but don't start yet
                gameMode = 'multiplayer';
                playerRole = 'waiting';
                allPlayersJoined = false;
                gameStarted = false;
                
            };

            // Add the same event handlers as createRoom
            multiplayerManager.onPlayerJoined = (playerId, role) => {
                
                // For joinRoom, just wait silently - no UI updates needed
                const currentPlayers = Object.keys(otherPlayers).length + 2;
                const playersNeeded = requiredPlayers - currentPlayers;
                
                if (playersNeeded > 0) {
                } else {
                }
            };

            multiplayerManager.onRoleAssigned = (role, message) => {
                playerRole = role;
                
                // Remove simple waiting message if it exists
                const simpleWaiting = document.getElementById('simple-waiting');
                if (simpleWaiting) {
                    simpleWaiting.remove();
                }
                
                // Hide role assignment screen and show your role screen
                document.getElementById('roleAssignmentScreen').style.display = 'none';
                document.getElementById('yourRoleScreen').style.display = 'block';
                
                // Update role information
                document.getElementById('assignedRole').textContent = role.toUpperCase();
                
                // Set role descriptions
                let description = '';
                switch(role) {
                    case 'player':
                        description = 'Navigate through the maze to find the green exit. Use WASD to move and mouse to look around. Avoid the monster!';
                        break;
                    case 'guide':
                        description = 'Help the player reach the exit using your top-down 2D view. You can see the entire maze layout and all player positions.';
                        break;
                    case 'architect':
                        description = 'Architect: Click to add/remove walls.';
                        break;
                    case 'monster':
                        description = 'Hunt the player in first-person view! Use WASD to move and mouse to look around. Catch the player before they escape!';
                        break;
                    default:
                        description = message || 'Unknown role';
                }
                document.getElementById('roleDescription').textContent = description;
                
                // DON'T initialize the scene yet - wait for onGameReady
            };

            multiplayerManager.onGameReady = () => {
                allPlayersJoined = true;
                gameStarted = true;
                
                // Hide all UI screens
                hideAllMenus();
                
                // Wait for maze data if not available
                if (!maze) {
                    setTimeout(() => {
                        if (maze) {
                            multiplayerManager.onGameReady();
                        } else {
                            console.error('üéÆ Still no maze data after waiting');
                        }
                    }, 100);
                    return;
                }
                
                // Add a 3-second countdown before starting
                setTimeout(() => {
                    // Force game start based on role
                    if (playerRole === 'guide') {
                        initGuideView(maze);
                    } else if (playerRole === 'architect') {
                        // Architect gets 2D view with wall editing
                        initGuideView(maze);
                        
                        // Setup architect click controls
                        try {
                            setupArchitectControls();
                        } catch (error) {
                            console.error('‚ùå Error in architect setup:', error);
                            console.error('‚ùå Error stack:', error.stack);
                        }
                    } else if (playerRole === 'player' || playerRole === 'monster') {
                        
                        // Ensure scene is initialized first
                        if (!isInitialized || !scene || !controls) {
                            init(true); // Initialize with game started
                        } else {
                            gameStarted = true;
                            if (controls) {
                                controls.enabled = true;
                            }
                            
                            // Request pointer lock for player and monster - DISABLED
                            // if (renderer && renderer.domElement) {
                            //     renderer.domElement.requestPointerLock();
                            //     console.log('üé¨ Pointer lock requested for game start');
                            // }
                        }
                        
                        // FORCED FIX: Ensure controls are definitely enabled for movement
                        setTimeout(() => {
                            if (controls) {
                                controls.enabled = true;
                                gameStarted = true;
                                
                                // Extra debug for monster
                                if (playerRole === 'monster') {
                                    // Monster role setup complete
                                }
                                
                                // Extra debug for player role
                                if (playerRole === 'player') {
                                    // Player role setup complete
                                }
                            } else {
                                console.error('‚ùå NO CONTROLS OBJECT FOUND for', playerRole, '!');
                                // Try to create controls if missing
                                if (scene && camera && maze) {
                                    controls = setupControls();
                                    if (controls) {
                                        controls.enabled = true;
                                        gameStarted = true;
                                    }
                                }
                            }
                        }, 500);
                        
                    } else {
                    }
                }, 3000);
            };

            multiplayerManager.onError = (error) => {
                console.error('Error joining room:', error);
                hideLoadingScreen();
                alert('Error joining room: ' + error);
                showMultiplayerMenu();
            };

            // Start connection
            multiplayerManager.connect();
        }

        function showLoadingScreen(message = 'Loading Game...') {
            document.getElementById('loadingMessage').textContent = message;
            document.getElementById('loadingScreen').style.display = 'block';
        }

        function hideLoadingScreen() {
            document.getElementById('loadingScreen').style.display = 'none';
        }

        function setupMultiplayer() {
            
            // Create other player representation based on role
            if (playerRole === 'player' || playerRole === 'monster') {
                let otherPlayerMesh;
                if (playerRole === 'monster') {
                    // Create player representation for monster's view
                    const playerGeometry = new THREE.Group();
                    
                    // Main body - taller and brighter cylinder
                    const body = new THREE.Mesh(
                        new THREE.CylinderGeometry(0.4, 0.4, 2.5, 8),
                        new THREE.MeshPhongMaterial({ 
                            color: 0x00ff00,
                            emissive: 0x00ff00,
                            emissiveIntensity: 0.5
                        })
                    );
                    playerGeometry.add(body);
                    
                    // Add glowing ring at the top
                    const ring = new THREE.Mesh(
                        new THREE.TorusGeometry(0.5, 0.1, 8, 16),
                        new THREE.MeshPhongMaterial({
                            color: 0xffff00,
                            emissive: 0xffff00,
                            emissiveIntensity: 0.7
                        })
                    );
                    ring.position.y = 1.5;
                    ring.rotation.x = Math.PI / 2;
                    playerGeometry.add(ring);
                    
                    otherPlayerMesh = playerGeometry;
                } else {
                    // Monster representation for player's view
                    otherPlayerMesh = new THREE.Mesh(
                        new THREE.CylinderGeometry(0.3, 0.3, 2, 8),
                        new THREE.MeshPhongMaterial({ 
                            color: 0xff0000,
                            emissive: 0xff0000,
                            emissiveIntensity: 0.5
                        })
                    );
                }
                
                otherPlayers[multiplayerManager.playerId] = otherPlayerMesh;
                otherPlayers[multiplayerManager.playerId].position.set(0, 1, 0);
                otherPlayers[multiplayerManager.playerId].visible = true;
                scene.add(otherPlayers[multiplayerManager.playerId]);
            }

            // Set up multiplayer event handlers
            multiplayerManager.onPlayerJoined = (playerId, role) => {
                
                // Update player count for host's waiting screen
                if (multiplayerManager.isHost) {
                    // Initialize player count only once when first player joins
                    if (typeof window.playerJoinCount === 'undefined') {
                        window.playerJoinCount = 1; // Start with host
                    }
                    window.playerJoinCount++; // Add the newly joined player
                    
                    const playerCountElement = document.getElementById('playerCount');
                    if (playerCountElement) {
                        playerCountElement.textContent = `Players joined: ${window.playerJoinCount}/4`;
                    }
                    
                    const playersNeeded = requiredPlayers - window.playerJoinCount;
                    const waitingMessageElement = document.getElementById('waitingMessage');
                    if (waitingMessageElement && playersNeeded > 0) {
                        waitingMessageElement.textContent = `Waiting for ${playersNeeded} more player${playersNeeded > 1 ? 's' : ''} to join...`;
                    } else if (waitingMessageElement && playersNeeded <= 0) {
                        // All players joined - show role assignment screen
                        document.getElementById('waitingScreen').style.display = 'none';
                        document.getElementById('roleAssignmentScreen').style.display = 'block';
                        waitingMessageElement.textContent = 'All players joined! Assigning roles...';
                    }
                }
                
                if (!otherPlayers[playerId] && (playerRole === 'player' || playerRole === 'monster')) {
                    
                    // Create a more visible representation for players
                    let playerMesh;
                    if (role === 'monster') {
                        // Monster representation
                        playerMesh = new THREE.Mesh(
                            new THREE.CylinderGeometry(0.3, 0.3, 2, 8),
                            new THREE.MeshPhongMaterial({ 
                                color: 0xff0000,
                                emissive: 0xff0000,
                                emissiveIntensity: 0.5
                            })
                        );
                    } else {
                        // Player representation - more visible for monster
                        const playerGeometry = new THREE.Group();
                        
                        // Main body - taller and brighter cylinder
                        const body = new THREE.Mesh(
                            new THREE.CylinderGeometry(0.4, 0.4, 2.5, 8),
                            new THREE.MeshPhongMaterial({ 
                                color: 0x00ff00,
                                emissive: 0x00ff00,
                                emissiveIntensity: 0.5
                            })
                        );
                        playerGeometry.add(body);
                        
                        // Add glowing ring at the top
                        const ring = new THREE.Mesh(
                            new THREE.TorusGeometry(0.5, 0.1, 8, 16),
                            new THREE.MeshPhongMaterial({
                                color: 0xffff00,
                                emissive: 0xffff00,
                                emissiveIntensity: 0.7
                            })
                        );
                        ring.position.y = 1.5;
                        ring.rotation.x = Math.PI / 2;
                        playerGeometry.add(ring);
                        
                        playerMesh = playerGeometry;
                    }
                    
                    otherPlayers[playerId] = playerMesh;
                    otherPlayers[playerId].position.set(0, 1, 0);
                    otherPlayers[playerId].visible = true;
                    scene.add(otherPlayers[playerId]);
                    
                }
            };

            multiplayerManager.onPlayerLeft = (playerId) => {
                if (otherPlayers[playerId]) {
                    scene.remove(otherPlayers[playerId]);
                    delete otherPlayers[playerId];
                }
            };

            multiplayerManager.onPlayerMove = (playerId, position, rotation) => {
                if (otherPlayers[playerId]) {
                    // Store target position for smooth interpolation
                    playerTargetPositions[playerId] = {
                        position: position,
                        rotation: rotation
                    };
                    
                    // Apply smooth interpolation instead of direct setting
                    smoothUpdatePosition(
                        otherPlayers[playerId], 
                        position, 
                        rotation, 
                        playerId,
                        0.3 // Smoothing factor
                    );
                }
            };
        }

        function copyRoomCode(element) {
            const code = element.textContent;
            navigator.clipboard.writeText(code).then(() => {
                element.classList.add('copied');
                setTimeout(() => element.classList.remove('copied'), 500);
            });
        }

        function initGuideView(mazeData) {
            try {
                if (!mazeData) throw new Error('No maze data provided');

                // Update role title based on actual player role
                const roleTitleElement = document.getElementById('roleTitle');
                if (roleTitleElement) {
                    if (playerRole === 'architect') {
                        roleTitleElement.textContent = 'Architect View';
                    } else {
                        roleTitleElement.textContent = 'Guide View';
                    }
                }

                // Clean up
                if (renderer?.domElement?.parentNode) {
                    renderer.domElement.parentNode.removeChild(renderer.domElement);
                    renderer.dispose();
                }

                // Hide other screens
                ['startScreen', 'multiplayerMenu', 'winScreen', 'loadingScreen'].forEach(id => {
                    const element = document.getElementById(id);
                    if (element) element.style.display = 'none';
                });

                // Setup guide container
                const guideView = document.getElementById('guideView');
                guideView.style.cssText = `
                    position: fixed;
                    top: 0;
                    left: 0;
                    width: 100vw;
                    height: 100vh;
                    display: flex;
                    justify-content: center;
                    align-items: center;
                    background-color: #000000;
                `;
                guideView.style.display = 'block';

                // Setup canvas
                guideCanvas = document.getElementById('guideCanvas');
                guideCtx = guideCanvas.getContext('2d', { alpha: false });

                // Calculate optimal size
                const margin = 80;
                const maxWidth = window.innerWidth - margin * 2;
                const maxHeight = window.innerHeight - margin * 2;
                
                // Calculate cell size to maintain aspect ratio
                const mazeWidth = mazeData.maze[0].length;
                const mazeHeight = mazeData.maze.length;
                const cellSizeX = Math.floor(maxWidth / mazeWidth);
                const cellSizeY = Math.floor(maxHeight / mazeHeight);
                const cellSize = Math.min(cellSizeX, cellSizeY);

                // Set canvas size
                guideCanvas.width = mazeWidth * cellSize + margin * 2;
                guideCanvas.height = mazeHeight * cellSize + margin * 2;

                // Store settings globally
                window.guideViewConfig = {
                    cellSize,
                    margin,
                    mazeWidth,
                    mazeHeight,
                    worldCellSize: mazeData.cellSize
                };

                // Initial draw
                drawGuideView(mazeData, null, null);
                
                // Add architect-specific functionality
                if (playerRole === 'architect') {
                    // setupArchitectControls(); // Removed - will be called in onGameReady
                }
                
                // Timer will be started by game_ready message for sync
                
                gameStarted = true;

            } catch (error) {
                console.error('Guide view error:', error);
                const msg = document.createElement('div');
                msg.style.cssText = 'position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);background:rgba(0,0,0,0.8);color:red;padding:20px;border-radius:10px;text-align:center;';
                msg.innerHTML = `Error: ${error.message}<br><button onclick="location.reload()" style="margin-top:15px;padding:10px;background:white;color:red;border:none;border-radius:5px;cursor:pointer;">Reload</button>`;
                document.body.appendChild(msg);
            }
        }

        function smoothPosition(current, last) {
            if (!last) return current;
            return {
                x: last.x + (current.x - last.x) * positionSmoothingFactor,
                y: last.y + (current.y - last.y) * positionSmoothingFactor,
                z: last.z + (current.z - last.z) * positionSmoothingFactor,
                rotation: {
                    x: last.rotation?.x + (current.rotation?.x - last.rotation?.x) * rotationSmoothingFactor || current.rotation?.x,
                    y: last.rotation?.y + (current.rotation?.y - last.rotation?.y) * rotationSmoothingFactor || current.rotation?.y,
                    z: last.rotation?.z + (current.rotation?.z - last.rotation?.z) * rotationSmoothingFactor || current.rotation?.z
                }
            };
        }

        function drawGuideView(mazeData, playerPos, monsterPos) {
            if (!mazeData || !mazeData.maze) return;
            
            const config = window.guideViewConfig;
            if (!config) return;

            // Apply position smoothing
            if (playerPos) {
                if (!lastPlayerPos) {
                    lastPlayerPos = { ...playerPos };
                } else {
                    playerPos = smoothPosition(playerPos, lastPlayerPos);
                    lastPlayerPos = { ...playerPos };
                }
            }
            
            if (monsterPos) {
                if (!lastMonsterPos) {
                    lastMonsterPos = { ...monsterPos };
                } else {
                    monsterPos = smoothPosition(monsterPos, lastMonsterPos);
                    lastMonsterPos = { ...monsterPos };
                }
            }

            const { cellSize, margin, worldCellSize } = config;

            // Create an off-screen canvas for double buffering
            const offscreenCanvas = document.createElement('canvas');
            offscreenCanvas.width = guideCanvas.width;
            offscreenCanvas.height = guideCanvas.height;
            const offscreenCtx = offscreenCanvas.getContext('2d', { alpha: false });
            
            // Enable image smoothing for smoother rendering
            offscreenCtx.imageSmoothing = true;
            offscreenCtx.imageSmoothingQuality = 'high';

            // Clear offscreen canvas with a solid color
            offscreenCtx.fillStyle = '#000000';
            offscreenCtx.fillRect(0, 0, offscreenCanvas.width, offscreenCanvas.height);

            // Draw floor with anti-aliasing
            offscreenCtx.fillStyle = '#e0e0e0';
            offscreenCtx.fillRect(
                Math.round(margin),
                Math.round(margin),
                Math.round(mazeData.maze[0].length * cellSize),
                Math.round(mazeData.maze.length * cellSize)
            );

            // Draw walls with special colors for architect changes - flip the z-axis by using (mazeData.maze.length - 1 - z)
            for (let z = 0; z < mazeData.maze.length; z++) {
                for (let x = 0; x < mazeData.maze[z].length; x++) {
                    const coordKey = `${x},${z}`;
                    const canvasX = (mazeData.maze[z].length - 1 - x) * cellSize + margin;
                    const canvasY = (mazeData.maze.length - 1 - z) * cellSize + margin;
                    
                    if (mazeData.maze[z][x] === 1) {
                        // Check if this is an architect-added wall
                        if (window.architectWallChanges?.added.has(coordKey)) {
                            offscreenCtx.fillStyle = '#ff0000'; // Red for architect-added walls
                        } else {
                            offscreenCtx.fillStyle = '#1a1a1a'; // Very dark gray for original walls
                        }
                        offscreenCtx.fillRect(canvasX, canvasY, cellSize, cellSize);
                    } else {
                        // Check if this is an architect-removed area
                        if (window.architectWallChanges?.removed.has(coordKey)) {
                            offscreenCtx.fillStyle = '#bbbbbb'; // Light grey for removed walls
                            offscreenCtx.fillRect(canvasX, canvasY, cellSize, cellSize);
                        }
                    }
                }
            }

            // Draw exit - flip both x and z coordinates
            const exitX = Math.floor((mazeData.maze[0].length - 1 - (mazeData.endPosition.x / worldCellSize))) * cellSize + margin;
            const exitZ = Math.floor(mazeData.maze.length - 1 - (mazeData.endPosition.z / worldCellSize)) * cellSize + margin;
            
            // Draw exit marker with glow effect
            offscreenCtx.shadowColor = '#4CAF50';
            offscreenCtx.shadowBlur = 15;
            offscreenCtx.fillStyle = '#4CAF50';
            offscreenCtx.fillRect(exitX - cellSize/4, exitZ - cellSize/4, cellSize/2, cellSize/2);

            // Draw player position if available
            if (playerPos && typeof playerPos.x === 'number' && typeof playerPos.z === 'number') {
                const squareSize = cellSize * 0.6;
                
                // Calculate canvas coordinates for player
                const canvasX = ((mazeData.maze[0].length - 1) - (playerPos.x / worldCellSize)) * cellSize + margin + cellSize/2;
                const canvasZ = ((mazeData.maze.length - 1) - (playerPos.z / worldCellSize)) * cellSize + margin + cellSize/2;
                
                // Draw player marker
                offscreenCtx.shadowColor = '#2196F3';
                offscreenCtx.shadowBlur = 10;
                offscreenCtx.strokeStyle = '#2196F3';
                offscreenCtx.lineWidth = 3;
                
                // Draw player square
                offscreenCtx.strokeRect(
                    canvasX - squareSize/2,
                    canvasZ - squareSize/2,
                    squareSize,
                    squareSize
                );

                // Direction indicator removed - was causing flickering
            }

            // Draw monster position if available
            if (monsterPos && typeof monsterPos.x === 'number' && typeof monsterPos.z === 'number') {
                const diamondSize = cellSize * 0.6;
                
                // Calculate canvas coordinates for monster
                const canvasX = ((mazeData.maze[0].length - 1) - (monsterPos.x / worldCellSize)) * cellSize + margin + cellSize/2;
                const canvasZ = ((mazeData.maze.length - 1) - (monsterPos.z / worldCellSize)) * cellSize + margin + cellSize/2;
                
                // Draw monster marker
                offscreenCtx.shadowColor = '#ff0000';
                offscreenCtx.shadowBlur = 10;
                offscreenCtx.strokeStyle = '#ff0000';
                offscreenCtx.lineWidth = 3;
                
                // Draw diamond shape
                offscreenCtx.beginPath();
                offscreenCtx.moveTo(canvasX, canvasZ - diamondSize/2);
                offscreenCtx.lineTo(canvasX + diamondSize/2, canvasZ);
                offscreenCtx.lineTo(canvasX, canvasZ + diamondSize/2);
                offscreenCtx.lineTo(canvasX - diamondSize/2, canvasZ);
                offscreenCtx.closePath();
                offscreenCtx.stroke();
            }

            // Reset shadow
            offscreenCtx.shadowBlur = 0;

            // Copy the offscreen canvas to the visible canvas
            guideCtx.clearRect(0, 0, guideCanvas.width, guideCanvas.height);
            guideCtx.drawImage(offscreenCanvas, 0, 0);
        }

        function setupArchitectControls() {
            // Prevent duplicate setup
            if (window.architectControlsSetup) {
                return;
            }
            window.architectControlsSetup = true;
            
            // Create cooldown timer display
            const cooldownTimer = document.createElement('div');
            cooldownTimer.id = 'architectCooldownTimer';
            cooldownTimer.style.cssText = `
                position: fixed;
                bottom: 20px;
                left: 50%;
                transform: translateX(-50%);
                background: rgba(0, 255, 0, 0.9);
                color: white;
                padding: 15px 30px;
                border-radius: 25px;
                font-size: 24px;
                font-weight: bold;
                z-index: 10000;
                display: block;
                text-shadow: 0 0 5px rgba(0, 0, 0, 0.8);
                box-shadow: 0 4px 20px rgba(0, 255, 0, 0.4);
                pointer-events: none;
                border: 3px solid white;
            `;
            cooldownTimer.textContent = `üèóÔ∏è Moves Left: ${architectMovesRemaining}/${MAX_ARCHITECT_MOVES}`;
            document.body.appendChild(cooldownTimer);
            
            // Update moves display initially
            updateArchitectMovesDisplay();
            
            // Instructions panel disabled - user prefers clean interface
            // const instructions = document.createElement('div');
            // instructions.id = 'architectInstructions';
            // instructions.style.cssText = `... (disabled)`;
            // document.body.appendChild(instructions);
            
            // Add click handlers to guide canvas
            
            // Remove any existing event listeners first
            guideCanvas.removeEventListener('click', handleArchitectClick);
            guideCanvas.removeEventListener('contextmenu', handleArchitectRightClick);
            
            // Ensure canvas is properly clickable
            guideCanvas.style.position = 'relative';
            guideCanvas.style.zIndex = '5000';
            guideCanvas.style.display = 'block';
            guideCanvas.style.pointerEvents = 'auto';
            
            guideCanvas.addEventListener('click', handleArchitectClick);
            guideCanvas.addEventListener('contextmenu', handleArchitectRightClick);
            
            // Add a test click handler to see if ANY clicks are being detected
            guideCanvas.addEventListener('mousedown', (e) => {
                // Mouse event detected
            });
            
            // Add visual feedback for architect interactions
            guideCanvas.style.cursor = 'crosshair';
            guideCanvas.style.border = '3px solid #FF4500';
            guideCanvas.style.boxShadow = '0 0 15px rgba(255, 69, 0, 0.5)';
            
            // Add hover effects
            guideCanvas.addEventListener('mouseenter', () => {
                guideCanvas.style.boxShadow = '0 0 25px rgba(255, 69, 0, 0.8)';
            });
            
            guideCanvas.addEventListener('mouseleave', () => {
                guideCanvas.style.boxShadow = '0 0 15px rgba(255, 69, 0, 0.5)';
            });
            
            // Reminder messages disabled - user prefers clean interface
            // let reminderCount = 0;
            // const reminderInterval = setInterval(() => {
            //     if (reminderCount < 3) {
            //         showArchitectMessage('üèóÔ∏è REMINDER: Click on the 2D maze view to modify walls!', true);
            //         reminderCount++;
            //     } else {
            //         clearInterval(reminderInterval);
            //     }
            // }, 10000); // Every 10 seconds, 3 times
        }

        function handleArchitectClick(event) {
            
            if (playerRole !== 'architect') {
                return;
            }
            
            event.preventDefault();
            const rect = guideCanvas.getBoundingClientRect();
            const canvasX = event.clientX - rect.left;
            const canvasY = event.clientY - rect.top;
            
            performArchitectAction(canvasX, canvasY, 'add');
        }



        function handleArchitectRightClick(event) {
            
            if (playerRole !== 'architect') {
                return;
            }
            
            event.preventDefault();
            event.stopPropagation();
            const rect = guideCanvas.getBoundingClientRect();
            const canvasX = event.clientX - rect.left;
            const canvasY = event.clientY - rect.top;
            
            performArchitectAction(canvasX, canvasY, 'remove');
            
            return false; // Extra prevention of context menu
        }

        // Architect move limit tracking - 3 moves per game
        let architectMovesRemaining = 3;
        const MAX_ARCHITECT_MOVES = 3;

        function updateArchitectMovesDisplay() {
            const movesDisplay = document.getElementById('architectCooldownTimer');
            
            if (!movesDisplay) return;
            
            if (architectMovesRemaining > 0) {
                movesDisplay.textContent = `üèóÔ∏è Moves Left: ${architectMovesRemaining}/${MAX_ARCHITECT_MOVES}`;
                movesDisplay.style.background = architectMovesRemaining === 1 ? 'rgba(255, 140, 0, 0.9)' : 'rgba(0, 255, 0, 0.9)';
                movesDisplay.style.display = 'block';
            } else {
                movesDisplay.textContent = '‚ùå No Moves Left';
                movesDisplay.style.background = 'rgba(255, 0, 0, 0.9)';
                movesDisplay.style.display = 'block';
            }
        }

        function performArchitectAction(canvasX, canvasY, action) {
            
            // Check moves remaining
            if (architectMovesRemaining <= 0) {
                showArchitectMessage('‚ùå No moves left! You only get 3 moves per game.', false);
                return;
            }
            
            const config = window.guideViewConfig;
            if (!config || !maze) {
                return;
            }
            
            const { cellSize, margin } = config;
            
            // Convert canvas coordinates to flipped grid coordinates (matching drawGuideView)
            const canvasGridX = Math.floor((canvasX - margin) / cellSize);
            const canvasGridZ = Math.floor((canvasY - margin) / cellSize);
            
            // Unflip the coordinates to get actual maze grid coordinates
            const gridX = maze.maze[0].length - 1 - canvasGridX;
            const gridZ = maze.maze.length - 1 - canvasGridZ;
            
            // Convert grid coordinates to world coordinates
            const worldX = gridX * maze.cellSize;
            const worldZ = gridZ * maze.cellSize;
            
            console.log({
                canvas: {canvasX, canvasY},
                canvasGrid: {canvasGridX, canvasGridZ},
                actualGrid: {gridX, gridZ},
                world: {worldX, worldZ},
                cellSize: maze.cellSize,
                mazeSize: {width: maze.maze[0].length, height: maze.maze.length}
            });
            
            // Bounds check
            if (gridX < 0 || gridX >= maze.maze[0].length || gridZ < 0 || gridZ >= maze.maze.length) {
                return;
            }
            
            // CHECK DISTANCE FROM PLAYER AND MONSTER (5 block minimum)
            const MIN_DISTANCE = 5 * maze.cellSize;
            
            // Check player position
            const playerPos = Object.values(playerPositions)[0];
            if (playerPos) {
                const distToPlayer = Math.sqrt(
                    Math.pow(worldX - playerPos.x, 2) + 
                    Math.pow(worldZ - playerPos.z, 2)
                );
                if (distToPlayer < MIN_DISTANCE) {
                    showArchitectMessage('‚ùå Too close to player! (min 5 blocks)', false);
                    return;
                }
            }
            
            // Check monster position
            const monsterPos = Object.values(monsterPositions)[0];
            if (monsterPos) {
                const distToMonster = Math.sqrt(
                    Math.pow(worldX - monsterPos.x, 2) + 
                    Math.pow(worldZ - monsterPos.z, 2)
                );
                if (distToMonster < MIN_DISTANCE) {
                    showArchitectMessage('‚ùå Too close to monster! (min 5 blocks)', false);
                    return;
                }
            }
            
            // Check current maze state
            const currentValue = maze.maze[gridZ][gridX];
            
            if (action === 'add' && currentValue === 1) {
                showArchitectMessage('‚ùå Wall already exists!', false);
                return;
            }
            
            if (action === 'remove' && currentValue === 0) {
                showArchitectMessage('‚ùå No wall to remove!', false);
                return;
            }
            
            // Decrement moves remaining
            architectMovesRemaining--;
            updateArchitectMovesDisplay(); // Immediately update display
            showArchitectMessage(`‚úÖ ${action === 'add' ? 'Wall placed' : 'Wall removed'}! ${architectMovesRemaining} moves left`, true);
            
            // Play sound effect
            playSound(action === 'add' ? 'wall_place' : 'wall_remove');
            
            
            // Update maze immediately for instant visual feedback
            maze.maze[gridZ][gridX] = action === 'add' ? 1 : 0;
            
            // üîß CRITICAL FIX: Update collision detection immediately for architect too
            // Note: worldX and worldZ are already declared above
            
            if (!maze.wallPositions) {
                maze.wallPositions = [];
            }
            
            if (action === 'add') {
                // Add wall position for collision detection
                const wallPos = { x: worldX, z: worldZ };
                // Check if position already exists to avoid duplicates
                const exists = maze.wallPositions.some(pos => 
                    Math.abs(pos.x - wallPos.x) < 0.1 && Math.abs(pos.z - wallPos.z) < 0.1
                );
                if (!exists) {
                    maze.wallPositions.push(wallPos);
                }
            } else if (action === 'remove') {
                // Remove wall position from collision detection
                const initialLength = maze.wallPositions.length;
                maze.wallPositions = maze.wallPositions.filter(pos => 
                    !(Math.abs(pos.x - worldX) < 0.1 && Math.abs(pos.z - worldZ) < 0.1)
                );
                const removedCount = initialLength - maze.wallPositions.length;
            }
            
            
            // Redraw the architect's view immediately
            if (guideCanvas && guideCtx) {
                const currentPlayerPos = Object.values(playerPositions)[0] || null;
                const currentMonsterPos = Object.values(monsterPositions)[0] || null;
                drawGuideView(maze, currentPlayerPos, currentMonsterPos);
            }
            
            // Send wall change request to server
            console.log({
                connected: multiplayerManager?.connected,
                socketState: multiplayerManager?.socket?.readyState,
                roomCode: multiplayerManager?.roomCode
            });
            
            if (multiplayerManager && multiplayerManager.socket && multiplayerManager.socket.readyState === WebSocket.OPEN) {
                const message = {
                    type: 'architect_wall_change',
                    x: worldX,
                    z: worldZ,
                    action: action
                };
                
                
                // Flash screen to show message being sent
                document.body.style.backgroundColor = '#00ffff';
                setTimeout(() => {
                    document.body.style.backgroundColor = '#000';
                }, 150);
                
                multiplayerManager.socket.send(JSON.stringify(message));
                
            } else {
                console.error('Cannot send message - connection not ready');
            }
        }

        function showArchitectCooldown(seconds) {

            const cooldownIndicator = document.getElementById('architectCooldown');
            if (cooldownIndicator) {
                cooldownIndicator.textContent = `üî• Cooldown: ${seconds}s`;
                cooldownIndicator.style.display = 'block';
                
                const countdownTimer = setInterval(() => {
                    seconds--;
                    if (seconds <= 0) {
                        cooldownIndicator.style.display = 'none';
                        clearInterval(countdownTimer);
                    } else {
                        cooldownIndicator.textContent = `üî• Cooldown: ${seconds}s`;
                    }
                }, 1000);
            }
        }

        // In-game message display function - disabled to reduce UI clutter
        function showArchitectMessage(message, isSuccess = false) {
            
            // Popup messages disabled - user prefers clean interface
            // Only log to console now
            
            // Remove any existing messages (cleanup)
            const existingMessages = document.querySelectorAll('.architect-message');
            existingMessages.forEach(msg => msg.remove());
            
            // UI popup disabled - messages only go to console now
        }
        
        // Backward compatibility function
        function showArchitectError(message) {
            showArchitectMessage(message, false);
        }

        // Expose functions globally so multiplayer.js can access them
        window.handleWallChanged = handleWallChanged;
        window.showArchitectCooldown = showArchitectCooldown;
        window.showArchitectError = showArchitectError;
        window.showArchitectMessage = showArchitectMessage;
        
        // Function to add pending players when scene becomes ready
        function addPendingPlayers() {
            if (!window.pendingPlayers || !scene) return;
            
            
            window.pendingPlayers.forEach(pendingPlayer => {
                if (!otherPlayers[pendingPlayer.playerId]) {
                    otherPlayers[pendingPlayer.playerId] = pendingPlayer.mesh;
                    otherPlayers[pendingPlayer.playerId].position.set(0, 2, 0);
                    otherPlayers[pendingPlayer.playerId].visible = true;
                    scene.add(otherPlayers[pendingPlayer.playerId]);
                }
            });
            
            // Clear pending players
            window.pendingPlayers = [];
        }
        
        // Create fallback texture when loading fails
        function createFallbackTexture(color1, color2) {
            const canvas = document.createElement('canvas');
            canvas.width = 64;
            canvas.height = 64;
            const ctx = canvas.getContext('2d');
            
            // Create a checkerboard pattern
            const tileSize = 8;
            for (let x = 0; x < canvas.width; x += tileSize) {
                for (let y = 0; y < canvas.height; y += tileSize) {
                    const isEven = ((x / tileSize) + (y / tileSize)) % 2 === 0;
                    ctx.fillStyle = isEven ? color1 : color2;
                    ctx.fillRect(x, y, tileSize, tileSize);
                }
            }
            
            return canvas;
        }
        

        
        // DEBUGGING: Track role changes and clicks  
        let lastKnownRole = null;
        setInterval(() => {
            if (playerRole !== lastKnownRole) {
                lastKnownRole = playerRole;
                document.title = `Maze Game - Role: ${playerRole || 'none'}`;
            }
        }, 1000);
        

        

        

        

        


        function handleWallChanged(data) {
            if (!data || !maze) return;
            
            // Note: mazeGroup is only needed for 3D views (player/monster), not 2D views (guide/architect)
            
            // Update the local maze data
            if (maze && maze.maze && data.gridX !== undefined && data.gridZ !== undefined) {
                maze.maze[data.gridZ][data.gridX] = data.action === 'add' ? 1 : 0;
                
                // Track architect changes for visual highlighting
                const coordKey = `${data.gridX},${data.gridZ}`;
                if (data.action === 'add') {
                    architectWallChanges.added.add(coordKey);
                    architectWallChanges.removed.delete(coordKey); // Remove from removed if it was there
                    window.architectWallChanges.added.add(coordKey);
                    window.architectWallChanges.removed.delete(coordKey);
                } else if (data.action === 'remove') {
                    architectWallChanges.removed.add(coordKey);
                    architectWallChanges.added.delete(coordKey); // Remove from added if it was there
                    window.architectWallChanges.removed.add(coordKey);
                    window.architectWallChanges.added.delete(coordKey);
                }
                
                // üîß CRITICAL FIX: Update collision detection wallPositions array
                const worldX = data.gridX * maze.cellSize;
                const worldZ = data.gridZ * maze.cellSize;
                
                if (!maze.wallPositions) {
                    maze.wallPositions = [];
                }
                
                if (data.action === 'add') {
                    // Add wall position for collision detection
                    const wallPos = { x: worldX, z: worldZ };
                    // Check if position already exists to avoid duplicates
                    const exists = maze.wallPositions.some(pos => 
                        Math.abs(pos.x - wallPos.x) < 0.1 && Math.abs(pos.z - wallPos.z) < 0.1
                    );
                    if (!exists) {
                        maze.wallPositions.push(wallPos);
                    }
                } else if (data.action === 'remove') {
                    // Remove wall position from collision detection
                    maze.wallPositions = maze.wallPositions.filter(pos => 
                        !(Math.abs(pos.x - worldX) < 0.1 && Math.abs(pos.z - worldZ) < 0.1)
                    );
                }
                
            } else {
                return;
            }
            
            // Update 2D view for guide and architect with current player positions
            if ((playerRole === 'guide' || playerRole === 'architect') && window.guideViewConfig && guideCanvas && guideCtx) {
                try {
                    // Get current player and monster positions to preserve them in the redraw
                    const currentPlayerPos = Object.values(playerPositions)[0] || null;
                    const currentMonsterPos = Object.values(monsterPositions)[0] || null;
                    
                    console.log({
                        added: Array.from(architectWallChanges.added),
                        removed: Array.from(architectWallChanges.removed)
                    });
                    drawGuideView(maze, currentPlayerPos, currentMonsterPos);
                } catch (error) {
                    console.error('Error redrawing 2D view:', error);
                }
            }
            
            // Update 3D walls for player and monster (only if they have 3D scenes)
            if (mazeGroup && scene && (playerRole === 'player' || playerRole === 'monster')) {
                const worldX = data.gridX * maze.cellSize;
                const worldZ = data.gridZ * maze.cellSize;
                
                if (data.action === 'add') {
                    const wallGeometry = new THREE.BoxGeometry(maze.cellSize, maze.wallHeight, maze.cellSize);
                    
                    let wallMaterial;
                    if (typeof wallTexture !== 'undefined' && wallTexture) {
                        wallMaterial = new THREE.MeshLambertMaterial({ 
                            map: wallTexture,
                            color: 0xff0000 
                        });
                    } else {
                        wallMaterial = new THREE.MeshLambertMaterial({ 
                            color: 0xff0000 
                        });
                    }
                    const wall = new THREE.Mesh(wallGeometry, wallMaterial);
                    
                    wall.position.set(worldX, maze.wallHeight / 2, worldZ);
                    wall.userData = { 
                        gridX: data.gridX, 
                        gridZ: data.gridZ, 
                        isArchitectWall: true 
                    };
                    
                    mazeGroup.add(wall);
                    
                    // Remove any dark patch that might be at this location
                    const patchesToRemove = [];
                    mazeGroup.traverse((child) => {
                        if (child.userData && 
                            child.userData.isRemovedWallPatch &&
                            child.userData.gridX === data.gridX && 
                            child.userData.gridZ === data.gridZ) {
                            patchesToRemove.push(child);
                        }
                    });
                    
                    patchesToRemove.forEach(patch => {
                        mazeGroup.remove(patch);
                        if (patch.geometry) patch.geometry.dispose();
                        if (patch.material) patch.material.dispose();
                    });
                    
                } else if (data.action === 'remove') {
                    const wallsToRemove = [];
                    mazeGroup.traverse((child) => {
                        if (child.userData && 
                            child.userData.gridX === data.gridX && 
                            child.userData.gridZ === data.gridZ) {
                            wallsToRemove.push(child);
                        }
                    });
                    
                    wallsToRemove.forEach(wall => {
                        mazeGroup.remove(wall);
                        if (wall.geometry) wall.geometry.dispose();
                        if (wall.material) wall.material.dispose();
                    });
                    
                    // Add dark patch where wall was removed
                    const patchGeometry = new THREE.PlaneGeometry(maze.cellSize * 0.9, maze.cellSize * 0.9);
                    const patchMaterial = new THREE.MeshBasicMaterial({
                        color: 0x222222, // Very dark grey
                        transparent: true,
                        opacity: 0.8
                    });
                    const patch = new THREE.Mesh(patchGeometry, patchMaterial);
                    patch.rotation.x = -Math.PI / 2;
                    patch.position.set(worldX, 0.02, worldZ); // Slightly above floor
                    patch.userData = { 
                        isRemovedWallPatch: true, 
                        gridX: data.gridX, 
                        gridZ: data.gridZ 
                    };
                    mazeGroup.add(patch);
                }
                
                updateWallVisual(data.gridX, data.gridZ, data.action);
            }
            
            // Update architect view if it exists
            if (playerRole === 'architect' && window.architectViewCanvas && window.drawArchitectView) {
                setTimeout(() => {
                    drawArchitectView();
                }, 50);
            }
        }

        function updateWallVisual(gridX, gridZ, action) {
            
            // Validate input parameters
            if (typeof gridX === 'undefined' || typeof gridZ === 'undefined' || typeof action === 'undefined') {
                console.error('üî• Invalid parameters to updateWallVisual:', {gridX, gridZ, action});
                return;
            }
            
            if (!mazeGroup || !maze || !scene) {
                console.error('üèóÔ∏è updateWallVisual: missing required objects', {
                    mazeGroup: !!mazeGroup,
                    maze: !!maze,
                    scene: !!scene
                });
                return;
            }
            
            const worldX = gridX * maze.cellSize;
            const worldZ = gridZ * maze.cellSize;
            
            
            // Update maze data
            maze.maze[gridZ][gridX] = action === 'add' ? 1 : 0;
            
            // üîß CRITICAL FIX: Update collision detection wallPositions array
            // Note: worldX and worldZ are already declared above
            if (!maze.wallPositions) {
                maze.wallPositions = [];
            }
            
            if (action === 'add') {
                // Add wall position for collision detection
                const wallPos = { x: worldX, z: worldZ };
                // Check if position already exists to avoid duplicates
                const exists = maze.wallPositions.some(pos => 
                    Math.abs(pos.x - wallPos.x) < 0.1 && Math.abs(pos.z - wallPos.z) < 0.1
                );
                if (!exists) {
                    maze.wallPositions.push(wallPos);
                }
            } else if (action === 'remove') {
                // Remove wall position from collision detection
                const initialLength = maze.wallPositions.length;
                maze.wallPositions = maze.wallPositions.filter(pos => 
                    !(Math.abs(pos.x - worldX) < 0.1 && Math.abs(pos.z - worldZ) < 0.1)
                );
                const removedCount = initialLength - maze.wallPositions.length;
            }
            
            
            if (action === 'add') {
                
                // Check if wall already exists at this position
                const existingWall = mazeGroup.children.find(child => 
                    child.userData && child.userData.gridX === gridX && child.userData.gridZ === gridZ
                );
                
                if (existingWall) {
                    return;
                }
                
                // Create new wall - make it VERY visible for architect
                const wallGeometry = new THREE.BoxGeometry(maze.cellSize, maze.wallHeight, maze.cellSize);
                
                // Create a bright, easily visible material for architect walls
                const wallMaterial = new THREE.MeshBasicMaterial({
                    color: 0xff0000, // Red color for architect walls
                    transparent: false
                });
                
                const wall = new THREE.Mesh(wallGeometry, wallMaterial);
                wall.position.set(worldX, maze.wallHeight / 2, worldZ);
                wall.userData = { gridX: gridX, gridZ: gridZ, architectPlaced: true };
                wall.castShadow = true;
                wall.receiveShadow = true;
                
                mazeGroup.add(wall);
                
                // Add a glowing indicator above the wall for extra visibility
                const glowGeometry = new THREE.SphereGeometry(0.5, 8, 8);
                const glowMaterial = new THREE.MeshBasicMaterial({
                    color: 0x00ff00,
                    transparent: true,
                    opacity: 0.7
                });
                const glow = new THREE.Mesh(glowGeometry, glowMaterial);
                glow.position.set(worldX, maze.wallHeight + 2, worldZ);
                glow.userData = { isGlow: true, parentWall: wall };
                scene.add(glow);
                
            } else if (action === 'remove') {
                
                // Find walls to remove (use fuzzy matching for better precision)
                const wallsToRemove = mazeGroup.children.filter(child => {
                    if (!child.userData) return false;
                    
                    // Check exact grid coordinates first
                    if (child.userData.gridX === gridX && child.userData.gridZ === gridZ) {
                        return true;
                    }
                    
                    // Fallback: check if world position is close (within 0.5 units)
                    const worldX = gridX * maze.cellSize;
                    const worldZ = gridZ * maze.cellSize;
                    const childX = child.position.x;
                    const childZ = child.position.z;
                    
                    if (Math.abs(childX - worldX) < 0.5 && Math.abs(childZ - worldZ) < 0.5) {
                        return true;
                    }
                    
                    return false;
                });
                
                if (wallsToRemove.length > 0) {
                    wallsToRemove.forEach((wall, index) => {
                        mazeGroup.remove(wall);
                        wall.geometry.dispose();
                        wall.material.dispose();
                        
                        // Also remove any glow indicators
                        const glowToRemove = scene.children.find(child =>
                            child.userData && child.userData.isGlow && child.userData.parentWall === wall
                        );
                        if (glowToRemove) {
                            scene.remove(glowToRemove);
                            glowToRemove.geometry.dispose();
                            glowToRemove.material.dispose();
                        }
                    });
                } else {
                    // List all available walls for debugging
                    mazeGroup.children.forEach((child, index) => {
                        if (child.userData && (child.userData.gridX !== undefined)) {
                            const distance = Math.abs(child.userData.gridX - gridX) + Math.abs(child.userData.gridZ - gridZ);
                        }
                    });
                    
                    // Check if there's a wall in the maze data but not in 3D scene
                    if (maze.maze[gridZ] && maze.maze[gridZ][gridX] === 1) {
                    }
                }
            }
            
        }

        function startGameTimer() {
            // Show timer for all roles
            
            // Remove any existing timer first
            const existingTimer = document.getElementById('gameTimer');
            if (existingTimer) {
                existingTimer.remove();
            }
            
            // Create timer display for all roles
            const timerDisplay = document.createElement('div');
            timerDisplay.id = 'gameTimer';
            
            timerDisplay.style.cssText = `
                position: fixed;
                top: 20px;
                right: 20px;
                background: rgba(255, 0, 0, 0.9);
                border: 3px solid #ff0000;
                box-shadow: 0 0 25px rgba(255, 0, 0, 0.5);
                color: white;
                padding: 12px 25px;
                border-radius: 15px;
                font-size: 20px;
                font-weight: bold;
                z-index: 10000;
                text-shadow: 0 0 5px rgba(0, 0, 0, 0.8);
            `;
            document.body.appendChild(timerDisplay);
            
            let timeRemaining = gameTimeLimit;
            
            const updateTimer = () => {
                const minutes = Math.floor(timeRemaining / 60000);
                const seconds = Math.floor((timeRemaining % 60000) / 1000);
                timerDisplay.textContent = `‚è∞ TIME: ${minutes}:${seconds.toString().padStart(2, '0')}`;
                
                // Change intensity as time runs out
                if (timeRemaining <= 60000) { // Last minute - very urgent
                    timerDisplay.style.background = 'rgba(255, 0, 0, 1.0)';
                    timerDisplay.style.borderColor = '#ffffff';
                    timerDisplay.style.boxShadow = '0 0 30px rgba(255, 0, 0, 0.8)';
                    timerDisplay.style.animation = 'pulse 0.5s infinite';
                    // Play warning sound every 10 seconds in last minute
                    if (timeRemaining % 10000 < 1000) {
                        playSound('timer_warning');
                    }
                } else if (timeRemaining <= 120000) { // Last 2 minutes - getting urgent
                    timerDisplay.style.background = 'rgba(255, 69, 0, 0.95)';
                    timerDisplay.style.borderColor = '#ff4500';
                    timerDisplay.style.boxShadow = '0 0 25px rgba(255, 69, 0, 0.7)';
                    // Play warning sound at 2 minute mark
                    if (timeRemaining === 120000) {
                        playSound('timer_warning');
                    }
                }
                
                timeRemaining -= 1000;
                
                if (timeRemaining <= 0) {
                    clearInterval(gameTimer);
                    handleTimeUp();
                }
            };
            
            updateTimer(); // Initial display
            gameTimer = setInterval(updateTimer, 1000);
        }

        function stopGameTimer() {
            if (gameTimer) {
                clearInterval(gameTimer);
                gameTimer = null;
            }
            
            const timerDisplay = document.getElementById('gameTimer');
            if (timerDisplay) {
                timerDisplay.remove();
            }
        }

        function handleTimeUp() {
            if (!gameStarted) return;
            gameStarted = false;
            
            // Stop the timer
            stopGameTimer();
            
            // Create time up screen
            const timeUpScreen = document.createElement('div');
            timeUpScreen.style.cssText = `
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: rgba(255, 152, 0, 0.95);
                color: white;
                padding: 30px;
                border-radius: 15px;
                text-align: center;
                font-size: 24px;
                z-index: 10000;
                box-shadow: 0 0 30px rgba(255, 152, 0, 0.7);
            `;
            
            timeUpScreen.innerHTML = `
                <h2>‚è∞ Time's Up! Game Over! ‚è∞</h2>
                <p>Everyone will be kicked out in 3 seconds...</p>
                <div style="font-size: 18px; margin-top: 15px;">
                    Thanks for playing! üéÆ
                </div>
            `;
            
            document.body.appendChild(timeUpScreen);
            
            // Send game over message to server
            if (multiplayerManager && multiplayerManager.connected) {
                multiplayerManager.socket.send(JSON.stringify({
                    type: 'game_over',
                    winner: 'time_up',
                    roomCode: multiplayerManager.roomCode
                }));
            }
            
            // Kick everyone out after a short delay
            setTimeout(() => {
                if (timeUpScreen.parentNode) {
                    document.body.removeChild(timeUpScreen);
                }
                // Disconnect from multiplayer and go back to main menu
                if (multiplayerManager && multiplayerManager.connected) {
                    multiplayerManager.disconnect();
                }
                window.location.reload(); // Force page reload to main menu
            }, 3000);
        }

        let animateDebugCount = 0;
        
        // Simple direct player movement system as backup
        const simpleKeys = { w: false, s: false, a: false, d: false };
        
        document.addEventListener('keydown', (e) => {
            if (e.key.toLowerCase() === 'w') {
                simpleKeys.w = true;
            }
            if (e.key.toLowerCase() === 's') {
                simpleKeys.s = true;
            }
            if (e.key.toLowerCase() === 'a') {
                simpleKeys.a = true;
            }
            if (e.key.toLowerCase() === 'd') {
                simpleKeys.d = true;
            }
        });
        
        document.addEventListener('keyup', (e) => {
            if (e.key.toLowerCase() === 'w') {
                simpleKeys.w = false;
            }
            if (e.key.toLowerCase() === 's') {
                simpleKeys.s = false;
            }
            if (e.key.toLowerCase() === 'a') {
                simpleKeys.a = false;
            }
            if (e.key.toLowerCase() === 'd') {
                simpleKeys.d = false;
            }
        });
        
        function animate() {
            requestAnimationFrame(animate);
            
            // Increment debug counter
            if (animateDebugCount < 10) {
                animateDebugCount++;
            }
            
            // Basic validation to prevent errors
            if (!renderer || !scene || !camera) {
                console.error('‚ùå Animation loop missing critical components:', {
                    renderer: !!renderer,
                    scene: !!scene,
                    camera: !!camera,
                    playerRole: playerRole
                });
                return;
            }
            
            // Debug monster movement conditions
            if (playerRole === 'monster' && animateDebugCount < 5) {
                // Monster movement debug check
            }
            
            // SIMPLE DIRECT MOVEMENT FOR PLAYER AND MONSTER WITH COLLISION DETECTION
            if ((playerRole === 'player' || playerRole === 'monster') && camera && gameStarted && maze) {
                const moveSpeed = 0.15;
                let moved = false;
                const oldPosition = camera.position.clone();
                const newPosition = camera.position.clone();
                
                // Calculate movement vector - WASD movement, A/D for turning
                let moveVector = { x: 0, z: 0 };
                
                // Handle rotation first
                if (simpleKeys.a) {
                    camera.rotation.y += 0.06;
                    moved = true;
                }
                if (simpleKeys.d) {
                    camera.rotation.y -= 0.06;
                    moved = true;
                }
                
                // Then handle forward/backward movement
                if (simpleKeys.w) {
                    moveVector.x -= Math.sin(camera.rotation.y) * moveSpeed;
                    moveVector.z -= Math.cos(camera.rotation.y) * moveSpeed;
                }
                if (simpleKeys.s) {
                    moveVector.x += Math.sin(camera.rotation.y) * moveSpeed;
                    moveVector.z += Math.cos(camera.rotation.y) * moveSpeed;
                }
                
                // Apply movement with collision detection
                if (moveVector.x !== 0 || moveVector.z !== 0) {
                    const targetPos = {
                        x: newPosition.x + moveVector.x,
                        z: newPosition.z + moveVector.z
                    };
                    
                    // Check collision at target position
                    const collision = checkCollision(targetPos);
                    
                    // If there's a collision, try to slide along walls
                    if (collision.x || collision.z) {
                        if (!collision.x) newPosition.x = targetPos.x;
                        if (!collision.z) newPosition.z = targetPos.z;
                        
                        // Apply sliding motion if available
                        if (collision.slideX || collision.slideZ) {
                            newPosition.x += collision.slideX * 0.5;
                            newPosition.z += collision.slideZ * 0.5;
                        }
                    } else {
                        // No collision, move freely
                        newPosition.x = targetPos.x;
                        newPosition.z = targetPos.z;
                    }
                    
                    // Update camera position
                    camera.position.copy(newPosition);
                    moved = true;
                }
                
                if (moved && animateDebugCount < 5) {
                }
                
                // Additional monster-specific debugging
                if (playerRole === 'monster' && animateDebugCount < 5) {
                    console.log({
                        keysPressed: Object.entries(simpleKeys).filter(([k,v]) => v),
                        moveVector: moveVector,
                        moved: moved,
                        position: {x: camera.position.x, z: camera.position.z}
                    });
                }
                
                // Send position update for multiplayer
                if (moved && multiplayerManager && multiplayerManager.connected) {
                    const now = Date.now();
                    if (now - lastPositionUpdate >= POSITION_UPDATE_INTERVAL) {
                        lastPositionUpdate = now;
                        if (animateDebugCount < 5) {
                        }
                        multiplayerManager.sendPosition(camera.position, camera.rotation);
                    }
                }
            }
            
            if (gameStarted && controls && controls.update) {
                // Debug player and monster movement issues
                if ((playerRole === 'player' || playerRole === 'monster') && animateDebugCount < 3) {
                    // Controls debug check
                }
                
                // Skip controls.update() for player and monster since they're using simple movement
                if (playerRole !== 'player' && playerRole !== 'monster') {
                    controls.update(); // Call the controls update function for architects/guides only
                }
                
                // Check if player has reached the end marker
                if (playerRole === 'player' && maze && maze.endPosition) {
                    const distanceToEnd = Math.sqrt(
                        Math.pow(camera.position.x - maze.endPosition.x, 2) +
                        Math.pow(camera.position.z - maze.endPosition.z, 2)
                    );
                    if (distanceToEnd < 1.0) { // If player is within 1 unit of the end marker
                        handlePlayerWin();
                    }
                }
                
                if ((playerRole === 'player' || playerRole === 'monster') && multiplayerManager && multiplayerManager.connected) {
                    const now = Date.now();
                    // Only send position updates at most every 50ms
                    if (now - lastPositionUpdate >= POSITION_UPDATE_INTERVAL) {
                        lastPositionUpdate = now;
                        
                        // Send position update to server
                        const position = {
                            x: camera.position.x,
                            y: camera.position.y,
                            z: camera.position.z
                        };
                        const rotation = {
                            x: camera.rotation.x,
                            y: camera.rotation.y,
                            z: camera.rotation.z
                        };
                        
                        // Send position and rotation update to server with correct type
                        if (multiplayerManager.socket && multiplayerManager.socket.readyState === WebSocket.OPEN) {
                            multiplayerManager.socket.send(JSON.stringify({
                                type: playerRole === 'monster' ? 'monster_position' : 'player_position',
                                position: position,
                                rotation: rotation,
                                roomCode: multiplayerManager.roomCode,
                                sessionId: multiplayerManager.gameState.sessionId
                            }));
                        }
                    }
                }
            } else if (gameStarted && !controls && (playerRole === 'player' || playerRole === 'monster')) {
                // Critical fix: if game started but no controls, try to set them up
                console.error('üö® CRITICAL: Game started but no controls for', playerRole);
                if (scene && camera && maze) {
                    controls = setupControls();
                }
            }
            
            // Animate red flickering lights - more dramatic and varied pattern
            if (window.flickeringLights) {
                const time = Date.now();
                window.flickeringLights.forEach((flickerData, index) => {
                    // Check if it's time to possibly change state
                    if (!flickerData.lastChange || time - flickerData.lastChange > flickerData.changeInterval) {
                        // More varied flickering pattern - some lights more active than others
                        const flickerChance = 0.3 + (index % 3) * 0.2; // Different chances for different lights
                        if (Math.random() < flickerChance) {
                            flickerData.isOn = !flickerData.isOn;
                            flickerData.lastChange = time;
                            // More varied timing - some lights flicker faster, some slower
                            const baseInterval = 200 + (index % 4) * 150; // 200-800ms base
                            flickerData.changeInterval = baseInterval + Math.random() * 400; // Add randomness
                        }
                    }
                    
                    // Set light intensity based on on/off state with some variation
                    if (flickerData.isOn) {
                        // Add slight intensity variation for more realistic effect
                        const intensityVariation = 0.8 + Math.random() * 0.4; // 0.8 to 1.2 times base intensity
                        flickerData.light.intensity = flickerData.baseIntensity * intensityVariation;
                    } else {
                        flickerData.light.intensity = 0; // Completely off
                    }
                });
            }
            
            // ALWAYS render the scene to prevent black screen
            // Continuous smooth interpolation for other players/monsters
            if (otherPlayers && Object.keys(otherPlayers).length > 0) {
                Object.entries(otherPlayers).forEach(([playerId, playerObject]) => {
                    if (playerObject && playerTargetPositions[playerId]) {
                        smoothUpdatePosition(
                            playerObject,
                            playerTargetPositions[playerId].position,
                            playerTargetPositions[playerId].rotation,
                            playerId,
                            0.1 // Gentle interpolation for animation loop
                        );
                    }
                });
            }

            try {
                renderer.render(scene, camera);
                
                // Debug empty scene once
                if (animateDebugCount === 2 && scene.children.length === 0) {
                    console.warn('‚ö†Ô∏è Scene is empty! This will cause a black screen.');
                }
            } catch (error) {
                console.error('‚ùå Rendering error:', error);
                console.error('Scene children count:', scene.children.length);
                console.error('Camera position:', camera.position);
            }
        }

        // Event Listeners
        document.getElementById('multiplayerButton').addEventListener('click', () => {
            showMultiplayerMenu();
        });
        document.getElementById('createRoomButton').addEventListener('click', () => {
            createRoom();
        });
        document.getElementById('joinRoomButton').addEventListener('click', () => {
            showJoinRoom();
        });
        document.getElementById('backToMainButton').addEventListener('click', () => {
            document.getElementById('multiplayerMenu').style.display = 'none';
            document.getElementById('startScreen').style.display = 'block';
        });
        document.getElementById('roomCodeInput').addEventListener('keyup', (e) => {
            if (e.key === 'Enter') {
                joinRoom();
            }
        });

        // Add click handler for room code copying
        document.getElementById('roomCode').addEventListener('click', function() {
            copyRoomCode(this);
        });

        // Handle window resizing
        window.addEventListener('resize', () => {
            if (camera && renderer) {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            }
        });

        // Clean up when leaving the game
        window.addEventListener('beforeunload', () => {
            if (multiplayerManager) {
                multiplayerManager.disconnect();
            }
            gameStarted = false;
        });

        // Handle visibility change to prevent reconnection loops
        document.addEventListener('visibilitychange', () => {
            if (document.hidden) {
                // Store current game state before going hidden
                if (multiplayerManager && multiplayerManager.gameState.active) {
                    multiplayerManager.gameState.lastKnownState = {
                        roomCode: multiplayerManager.roomCode,
                        role: multiplayerManager.role,
                        isHost: multiplayerManager.isHost,
                        position: camera ? { x: camera.position.x, y: camera.position.y, z: camera.position.z } : null
                    };
                }
            } else {
                if (multiplayerManager && multiplayerManager.gameState.active) {
                    // Verify connection and game state when becoming visible
                    if (!multiplayerManager.connected || multiplayerManager.gameState.reconnecting) {
                        multiplayerManager.connect();
                    } else {
                        // Send a ping to verify connection is still alive
                        multiplayerManager.socket.send(JSON.stringify({
                            type: 'ping',
                            timestamp: Date.now()
                        }));
                    }
                }
            }
        });

        // Update the MultiplayerManager to handle disconnections better
        MultiplayerManager.prototype.handleDisconnect = function() {
            this.connected = false;
            
            if (gameStarted && !this.disconnecting) {
                // Show a reconnection message
                let reconnectMessage = document.getElementById('reconnectMessage');
                if (!reconnectMessage) {
                    reconnectMessage = document.createElement('div');
                    reconnectMessage.id = 'reconnectMessage';
                    reconnectMessage.style.cssText = `
                        position: fixed;
                        top: 50%;
                        left: 50%;
                        transform: translate(-50%, -50%);
                        background: rgba(0, 0, 0, 0.8);
                        color: white;
                        padding: 20px;
                        border-radius: 10px;
                        z-index: 1000;
                        text-align: center;
                    `;
                    document.body.appendChild(reconnectMessage);
                }
                
                reconnectMessage.innerHTML = `
                    <h3>Connection Lost</h3>
                    <p>Attempting to reconnect...</p>
                    <button onclick="location.reload()" style="margin-top: 10px; padding: 5px 10px;">Restart Game</button>
                `;
                
                // Try to reconnect
                this.reconnect();
                
                // Set a timeout to show the menu if reconnection fails
                setTimeout(() => {
                    if (!this.connected && gameStarted) {
                        hideAllMenus();
                        
                        // Only show start screen if we're completely disconnected
                        if (!this.socket || this.socket.readyState !== WebSocket.CONNECTING) {
                            document.getElementById('startScreen').style.display = 'block';
                            gameStarted = false;
                            
                            // Remove reconnect message
                            if (reconnectMessage) {
                                reconnectMessage.remove();
                            }
                            
                            // Show an error message to the user
                            alert('Lost connection to the game. Please try again.');
                        }
                    }
                }, 15000); // Give even more time for reconnection attempts
            }
        };

        // Override MultiplayerManager message handling completely
        MultiplayerManager.prototype.handleMessage = function(message) {
            
            switch (message.type) {
                case 'room_created':
                    this.roomCode = message.roomCode;
                    this.isHost = true;
                    this.role = message.role;
                    playerRole = message.role; // This will be 'waiting' initially
                    this.gameState.players.add('host');
                    this.gameState.playerCount = 1;
                    this.gameState.canStart = false;
                    this.gameState.allPlayersJoined = false;
                    if (this.onRoomCreated) {
                        this.onRoomCreated(message.roomCode);
                    }
                    break;

                case 'room_joined':
                    this.roomCode = message.roomCode;
                    this.role = message.role;
                    playerRole = message.role; // This will be 'waiting' initially
                    this.gameState.canStart = false;
                    this.gameState.allPlayersJoined = false;
                    if (this.onRoomJoined) {
                        this.onRoomJoined();
                    }
                    break;

                case 'player_joined':
                    this.gameState.players.add(message.playerId);
                    this.gameState.playerCount++;
                    if (this.onPlayerJoined) {
                        this.onPlayerJoined(message.playerId, message.role);
                    }
                    break;

                case 'role_assigned':
                    this.role = message.role;
                    playerRole = message.role; // This is the actual game role
                    
                    // If we have maze data and this is a proper role, trigger initialization
                    if (maze && playerRole && playerRole !== 'waiting') {
                        // Small delay to ensure all role assignment processing is complete
                        setTimeout(() => {
                            if (playerRole === 'guide' || playerRole === 'architect') {
                                initGuideView(maze);
                                if (playerRole === 'architect') {
                                    try {
                                        setupArchitectControls();
                                    } catch (error) {
                                        console.error('Error setting up architect controls:', error);
                                    }
                                }
                            } else if (playerRole === 'player' || playerRole === 'monster') {
                                init(false);
                            }
                        }, 100);
                    }
                    
                    if (this.onRoleAssigned) {
                        this.onRoleAssigned(message.role, message.message);
                    }
                    break;

                case 'game_ready':
                    this.gameState.allPlayersJoined = true;
                    this.gameState.canStart = true;
                    
                    // Start timer for ALL players at the same time
                    if (gameMode === 'multiplayer') {
                        startGameTimer();
                    }
                    
                    if (this.onGameReady) {
                        this.onGameReady();
                    }
                    break;

                case 'waiting_for_players':
                    this.gameState.allPlayersJoined = false;
                    this.gameState.canStart = false;
                    break;

                case 'player_left':
                    this.gameState.players.delete(message.playerId);
                    this.gameState.playerCount--;
                    this.gameState.canStart = false;
                    this.gameState.allPlayersJoined = false;
                    if (this.onPlayerLeft) {
                        this.onPlayerLeft(message.playerId);
                    }
                    break;

                case 'maze_data':
                    maze = message.maze;
                    maze.wallPositions = maze.wallPositions || [];
                    
                    // Check if we can initialize now that we have maze data
                    if (playerRole && playerRole !== 'waiting') {
                        if (playerRole === 'guide' || playerRole === 'architect') {
                            initGuideView(maze);
                            if (playerRole === 'architect') {
                                try {
                                    setupArchitectControls();
                                } catch (error) {
                                    console.error('Error setting up architect controls:', error);
                                }
                            }
                        } else {
                            init(false);
                        }
                    } else {
                    }
                    break;

                case 'error':
                    console.error('‚ùå Server error:', message.error);
                    if (this.onError) {
                        this.onError(message.error);
                    }
                    break;

                case 'player_position':
                case 'monster_position':
                    // Handle position updates separately
                    handleMultiplayerMessage(message);
                    break;

                case 'architect_update':
                    // Call the wall changed handler directly
                    if (window.handleWallChanged) {
                        window.handleWallChanged(message);
                    } else {
                        console.error('‚ùå handleWallChanged function not available!');
                    }
                    break;

                default:
                    break;
            }
        };

        function handleMultiplayerMessage(message) {
            
            switch (message.type) {
                case 'player_position':
                    if (!message.position || typeof message.position.x !== 'number' || typeof message.position.z !== 'number') {
                        console.error('Invalid player position received:', message.position);
                        return;
                    }

                    if (playerRole === 'guide' || playerRole === 'architect') {
                        // Store position for this specific player ID
                        playerPositions[message.playerId] = {
                            x: message.position.x,
                            y: message.position.y,
                            z: message.position.z,
                            rotation: message.rotation
                        };
                        
                        // Guide and Architect: Update 2D view
                        if ((playerRole === 'guide' || playerRole === 'architect') && maze && guideCanvas && guideCtx) {
                            requestAnimationFrame(() => {
                                // Get the first (and should be only) player position
                                const playerPos = Object.values(playerPositions)[0] || null;
                                const monsterPos = Object.values(monsterPositions)[0] || null;
                                drawGuideView(maze, playerPos, monsterPos);
                            });
                        }
                        
                        // Architect: Update 3D view
                        if (playerRole === 'architect') {
                            if (otherPlayers[message.playerId]) {
                                // Store target position for smooth interpolation
                                playerTargetPositions[message.playerId] = {
                                    position: message.position,
                                    rotation: message.rotation
                                };
                                
                                // Apply immediate interpolation for architect's 3D view
                                smoothUpdatePosition(
                                    otherPlayers[message.playerId], 
                                    message.position, 
                                    message.rotation, 
                                    message.playerId,
                                    0.3 // Smoothing factor
                                );
                            } else {
                                // Create player representation for architect's 3D view
                                const playerGeometry = new THREE.Group();
                                
                                const body = new THREE.Mesh(
                                    new THREE.CylinderGeometry(0.4, 0.4, 2.5, 8),
                                    new THREE.MeshPhongMaterial({ 
                                        color: 0x00ff00,
                                        emissive: 0x00ff00,
                                        emissiveIntensity: 0.5
                                    })
                                );
                                playerGeometry.add(body);
                                
                                const ring = new THREE.Mesh(
                                    new THREE.TorusGeometry(0.5, 0.1, 8, 16),
                                    new THREE.MeshPhongMaterial({
                                        color: 0xffff00,
                                        emissive: 0xffff00,
                                        emissiveIntensity: 0.7
                                    })
                                );
                                ring.position.y = 1.5;
                                ring.rotation.x = Math.PI / 2;
                                playerGeometry.add(ring);
                                
                                otherPlayers[message.playerId] = playerGeometry;
                                otherPlayers[message.playerId].position.set(
                                    message.position.x,
                                    message.position.y,
                                    message.position.z
                                );
                                otherPlayers[message.playerId].visible = true;
                                scene.add(otherPlayers[message.playerId]);
                            }
                        }

                        // Check if player reached the end
                        if (maze && maze.endPosition) {
                            const distanceToEnd = Math.sqrt(
                                Math.pow(message.position.x - maze.endPosition.x, 2) +
                                Math.pow(message.position.z - maze.endPosition.z, 2)
                            );
                            if (distanceToEnd < 1.0) { // If player is within 1 unit of the end marker
                                handlePlayerWin();
                            }
                        }
                    } else if (playerRole === 'monster') {
                        // Create representation if it doesn't exist
                        if (!otherPlayers[message.playerId] && scene) {
                            const playerMesh = new THREE.Mesh(
                                new THREE.CylinderGeometry(0.5, 0.5, 2.5, 16),
                                new THREE.MeshPhongMaterial({ 
                                    color: 0x00ff00,
                                    emissive: 0x00ff00,
                                    emissiveIntensity: 1.0
                                })
                            );
                            otherPlayers[message.playerId] = playerMesh;
                            scene.add(playerMesh);
                        }
                        
                        // Always update position
                        if (otherPlayers[message.playerId]) {
                            otherPlayers[message.playerId].position.set(
                                message.position.x,
                                message.position.y || 1.5,
                                message.position.z
                            );
                            otherPlayers[message.playerId].visible = true;
                            
                            const distance = Math.sqrt(
                                Math.pow(camera.position.x - message.position.x, 2) +
                                Math.pow(camera.position.z - message.position.z, 2)
                            );
                            
                            if (distance < 1.5) {
                                handleMonsterWin();
                            }
                        }
                    }
                    break;

                case 'monster_position':
                    if (playerRole === 'guide' || playerRole === 'architect') {
                        if (!message.position || typeof message.position.x !== 'number' || typeof message.position.z !== 'number') {
                            console.error('Invalid monster position received:', message.position);
                            return;
                        }
                        
                        // Store position for this specific monster ID
                        monsterPositions[message.playerId] = {
                            x: message.position.x,
                            y: message.position.y,
                            z: message.position.z,
                            rotation: message.rotation
                        };
                        
                        // Guide and Architect: Update 2D view
                        if ((playerRole === 'guide' || playerRole === 'architect') && maze && guideCanvas && guideCtx) {
                            requestAnimationFrame(() => {
                                // Get the first (and should be only) player and monster positions
                                const playerPos = Object.values(playerPositions)[0] || null;
                                const monsterPos = Object.values(monsterPositions)[0] || null;
                                drawGuideView(maze, playerPos, monsterPos);
                            });
                        }
                        
                        // Architect: Update 3D view
                        if (playerRole === 'architect') {
                            if (otherPlayers[message.playerId]) {
                                // Store target position for smooth interpolation
                                playerTargetPositions[message.playerId] = {
                                    position: message.position,
                                    rotation: message.rotation
                                };
                                
                                // Apply immediate interpolation for architect's 3D view
                                smoothUpdatePosition(
                                    otherPlayers[message.playerId], 
                                    message.position, 
                                    message.rotation, 
                                    message.playerId,
                                    0.3 // Smoothing factor
                                );
                            } else {
                                // Create monster representation for architect's 3D view
                                const monsterMesh = new THREE.Mesh(
                                    new THREE.CylinderGeometry(0.3, 0.3, 2, 8),
                                    new THREE.MeshPhongMaterial({ 
                                        color: 0xff0000,
                                        emissive: 0xff0000,
                                        emissiveIntensity: 0.5
                                    })
                                );
                                
                                otherPlayers[message.playerId] = monsterMesh;
                                otherPlayers[message.playerId].position.set(
                                    message.position.x,
                                    message.position.y,
                                    message.position.z
                                );
                                otherPlayers[message.playerId].visible = true;
                                scene.add(otherPlayers[message.playerId]);
                            }
                        }
                    } else if (playerRole === 'player') {
                        // Create representation if it doesn't exist
                        if (!otherPlayers[message.playerId] && scene) {
                            const monsterMesh = new THREE.Mesh(
                                new THREE.CylinderGeometry(0.6, 0.6, 3, 16),
                                new THREE.MeshPhongMaterial({ 
                                    color: 0xff0000,
                                    emissive: 0xff0000,
                                    emissiveIntensity: 1.0
                                })
                            );
                            otherPlayers[message.playerId] = monsterMesh;
                            scene.add(monsterMesh);
                        }
                        
                        // Always update position
                        if (otherPlayers[message.playerId]) {
                            otherPlayers[message.playerId].position.set(
                                message.position.x,
                                message.position.y || 1.5,
                                message.position.z
                            );
                            otherPlayers[message.playerId].visible = true;
                        }

                        const distance = Math.sqrt(
                            Math.pow(camera.position.x - message.position.x, 2) +
                            Math.pow(camera.position.z - message.position.z, 2)
                        );
                        
                        if (distance < 1.5) {
                            handleMonsterWin();
                        }
                    }
                    break;

                case 'maze_data':
                    maze = message.maze;
                    maze.wallPositions = maze.wallPositions || [];
                    
                    // Initialize the maze for all roles
                    if (playerRole === 'player' || playerRole === 'monster') {
                        generateNewMaze();
                    } else if (playerRole === 'guide' || playerRole === 'architect') {
                        drawGuideView(maze);
                    }
                    break;

                case 'waiting_for_players':
                    const instructionsElement = document.getElementById('roomCodeInstructions');
                    if (instructionsElement) {
                        instructionsElement.textContent = message.message || 'Waiting for more players...';
                        instructionsElement.style.display = 'block';
                    }
                    break;

                case 'host_assigned':
                    if (message.isHost) {
                        this.isHost = true;
                    }
                    break;

                case 'error':
                    console.error('Server error:', message.error);
                    if (this.onError) {
                        this.onError(message.error);
                    }
                    break;

                case 'player_joined':
                    if (this.onPlayerJoined) {
                        this.onPlayerJoined(message.playerId, message.role);
                    }
                    break;

                case 'player_left':
                    if (this.onPlayerLeft) {
                        this.onPlayerLeft(message.playerId);
                    }
                    break;

                case 'game_over':
                    if (!message.winner) return;
                    
                    if (message.winner === 'player' && playerRole !== 'player') {
                        handlePlayerWin();
                    } else if (message.winner === 'monster' && playerRole !== 'monster') {
                        handleMonsterWin();
                    }
                    
                    // Don't cleanup immediately - let server handle game_terminated message
                    break;

                case 'game_terminated':
                    
                    // Stop game timers
                    if (gameTimer) {
                        clearInterval(gameTimer);
                        gameTimer = null;
                    }
                    
                    // Stop animation
                    if (window.animationFrameId) {
                        cancelAnimationFrame(window.animationFrameId);
                        window.animationFrameId = null;
                    }
                    
                    // Show end screen with play again button
                    showGameEndScreen(message.winner);
                    break;
                
                case 'play_again_restart':
                    // Remove end screen
                    const endScreen = document.getElementById('gameEndScreen');
                    if (endScreen) endScreen.remove();
                    
                    // Clean up scene
                    cleanupRenderer();
                    cleanupMultiplayer();
                    
                    // Reset game state
                    gameStarted = false;
                    allPlayersJoined = false;
                    otherPlayers = {};
                    playerPositions = {};
                    monsterPositions = {};
                    
                    // Show waiting screen
                    document.getElementById('waitingScreen').style.display = 'block';
                    document.getElementById('waitingMessage').textContent = 'Restarting game with new roles...';
                    document.getElementById('waitingRoomCode').textContent = message.roomCode;
                    break;

                default:
                    break;
            }
        };



        function initGame(isMultiplayer = false) {
            if (isMultiplayer && !gameStarted) {
                return;
            }
            
            // ... rest of initGame function ...
        }

        function getRandomEmptyCell(maze) {
            const width = maze.maze[0].length;
            const height = maze.maze.length;
            let attempts = 0;
            const maxAttempts = 200;

            while (attempts < maxAttempts) {
                const x = Math.floor(Math.random() * (width - 2)) + 1;
                const z = Math.floor(Math.random() * (height - 2)) + 1;
                
                // Check if this cell AND surrounding cells are empty
                const isCurrentEmpty = maze.maze[z][x] === 0;
                const isNotStart = (x !== Math.floor(maze.startPosition.x / maze.cellSize) || 
                                   z !== Math.floor(maze.startPosition.z / maze.cellSize));
                
                // Ensure 2x2 area is clear (no walls immediately around spawn)
                const hasClearArea = 
                    maze.maze[z][x] === 0 &&
                    (x > 0 && maze.maze[z][x - 1] === 0) &&
                    (x < width - 1 && maze.maze[z][x + 1] === 0) &&
                    (z > 0 && maze.maze[z - 1][x] === 0) &&
                    (z < height - 1 && maze.maze[z + 1][x] === 0);
                
                if (isCurrentEmpty && isNotStart && hasClearArea) {
                    return { x: x, z: z };
                }
                attempts++;
            }

            // Fallback: find ANY empty cell away from start
            for (let z = 2; z < height - 2; z++) {
                for (let x = 2; x < width - 2; x++) {
                    if (maze.maze[z][x] === 0) {
                        return { x: x, z: z };
                    }
                }
            }

            // Last resort
            return { x: 2, z: 2 };
        }

        function handlePlayerMove(ws, data) {
            const room = rooms.get(ws.roomCode);
            if (!room) {
                return;
            }

            // Update player position
            room.playerPositions.set(ws.playerId, {
                position: data.position,
                rotation: data.rotation
            });

            // Send position to all guide and monster players
            room.players.forEach((playerWs, playerId) => {
                const role = room.roles.get(playerId);
                if (role === 'guide' || role === 'monster') {
                    console.log({
                        position: data.position,
                        playerId: playerId
                    });
                    playerWs.send(JSON.stringify({
                        type: 'player_position',
                        position: data.position,
                        rotation: data.rotation
                    }));
                }
            });
        }

        // Add proximity effects for when monster gets close to player
        let proximityShakeOffset = { x: 0, y: 0, z: 0 };
        
        // Track last heartbeat time
        let lastHeartbeat = 0;
        
        function applyProximityEffects(distance) {
            if (playerRole !== 'player') return; // Only apply to player
            
            const maxEffectDistance = 30; // Start effects at 30 units (much much earlier!)
            const maxIntensity = 1.0; // Maximum effect intensity
            
            // Calculate intensity based on distance (closer = more intense)
            let intensity = 0;
            if (distance <= maxEffectDistance) {
                intensity = Math.max(0, (maxEffectDistance - distance) / maxEffectDistance);
                
                // Play heartbeat sound based on distance - faster when closer
                const now = Date.now();
                let heartbeatInterval = 2000; // Default 2 seconds
                if (distance <= 3) heartbeatInterval = 400; // Very fast
                else if (distance <= 6) heartbeatInterval = 700;
                else if (distance <= 12) heartbeatInterval = 1200;
                else if (distance <= 20) heartbeatInterval = 1800;
                
                if (now - lastHeartbeat >= heartbeatInterval) {
                    playSound('heartbeat');
                    lastHeartbeat = now;
                }
                
                // Create multiple intensity zones for different levels of fear
                if (distance <= 3) {
                    // PANIC ZONE - extremely intense effects
                    intensity = Math.pow(intensity, 0.5) * 1.0; // Very intense
                } else if (distance <= 6) {
                    // DANGER ZONE - strong effects
                    intensity = Math.pow(intensity, 0.8) * 0.8; // Strong
                } else if (distance <= 12) {
                    // WARNING ZONE - moderate effects
                    intensity = Math.pow(intensity, 1.2) * 0.6; // Moderate
                } else if (distance <= 20) {
                    // ALERT ZONE - mild effects
                    intensity = Math.pow(intensity, 1.8) * 0.4; // Mild
                } else {
                    // AWARENESS ZONE - very subtle effects
                    intensity = Math.pow(intensity, 2.5) * 0.2; // Very subtle
                }
            }
            
            // Apply screen shake effect by modifying renderer position instead of camera
            if (intensity > 0) {
                let shakeAmount = intensity * 25; // More intense shake
                
                // Add rapid shaking for close distances
                if (distance <= 3) {
                    shakeAmount += Math.sin(Date.now() * 0.05) * 10; // Rapid vibration
                }
                
                const shakeX = (Math.random() - 0.5) * shakeAmount;
                const shakeY = (Math.random() - 0.5) * shakeAmount;
                
                // Apply shake to renderer element instead of camera position
                if (renderer && renderer.domElement) {
                    renderer.domElement.style.transform = `translate(${shakeX}px, ${shakeY}px)`;
                }
            } else {
                // No shake, reset renderer position
                if (renderer && renderer.domElement) {
                    renderer.domElement.style.transform = 'translate(0px, 0px)';
                }
            }
            
            // Apply red overlay effect with dynamic gradients
            let redOverlay = document.getElementById('proximityOverlay');
            if (!redOverlay) {
                redOverlay = document.createElement('div');
                redOverlay.id = 'proximityOverlay';
                redOverlay.style.cssText = `
                    position: fixed;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    pointer-events: none;
                    z-index: 9999;
                    transition: opacity 0.05s ease;
                `;
                document.body.appendChild(redOverlay);
            }
            
            // Dynamic red overlay based on distance zones
            if (intensity > 0) {
                let overlayStyle = '';
                let opacity = intensity;
                
                if (distance <= 3) {
                    // PANIC ZONE - extreme pulsing red with black vignette + GLITCH EFFECT
                    const pulse = Math.sin(Date.now() * 0.015) * 0.4 + 0.6;
                    const glitch = Math.random() > 0.7 ? Math.random() * 0.2 : 0; // Random glitch
                    overlayStyle = `radial-gradient(circle, rgba(255, 0, 0, ${intensity * 0.5}) 5%, rgba(139, 0, 0, ${intensity * pulse}) 60%, rgba(0, 0, 0, ${intensity * 0.95}) 100%)`;
                    opacity = Math.min(0.9, intensity + pulse * 0.3 + glitch);
                    
                    // Add screen distortion/glitch when very close
                    if (renderer && renderer.domElement && Math.random() > 0.85) {
                        const glitchX = (Math.random() - 0.5) * 15;
                        const glitchSkew = (Math.random() - 0.5) * 5;
                        renderer.domElement.style.filter = `hue-rotate(${Math.random() * 360}deg) saturate(${1 + Math.random()})`;
                        setTimeout(() => {
                            if (renderer && renderer.domElement) {
                                renderer.domElement.style.filter = 'none';
                            }
                        }, 50);
                    }
                } else if (distance <= 6) {
                    // DANGER ZONE - strong red vignette
                    overlayStyle = `radial-gradient(circle, transparent 20%, rgba(255, 0, 0, ${intensity * 0.7}) 80%, rgba(139, 0, 0, ${intensity * 0.8}) 100%)`;
                    opacity = intensity * 0.8;
                } else if (distance <= 10) {
                    // WARNING ZONE - moderate red edges
                    overlayStyle = `radial-gradient(circle, transparent 40%, rgba(255, 0, 0, ${intensity * 0.5}) 90%)`;
                    opacity = intensity * 0.6;
                } else {
                    // AWARENESS ZONE - subtle red tint
                    overlayStyle = `radial-gradient(circle, transparent 60%, rgba(255, 0, 0, ${intensity * 0.3}) 95%)`;
                    opacity = intensity * 0.4;
                }
                
                redOverlay.style.background = overlayStyle;
                redOverlay.style.opacity = opacity;
            } else {
                redOverlay.style.opacity = 0;
            }
        }

        // Add these new functions for monster features
        function updateDistanceIndicator(distance) {
            let indicator = document.getElementById('distanceIndicator');
            if (!indicator) {
                indicator = document.createElement('div');
                indicator.id = 'distanceIndicator';
                indicator.style.cssText = `
                    position: fixed;
                    top: 60px;
                    left: 20px;
                    color: #ff0000;
                    font-size: 16px;
                    text-shadow: 0 0 5px rgba(255, 0, 0, 0.5);
                    z-index: 1000;
                `;
                document.body.appendChild(indicator);
            }
            indicator.textContent = `Distance to player: ${Math.round(distance)} units`;
        }

        function handleMonsterCatch() {
            // Create catch notification
            const notification = document.createElement('div');
            notification.style.cssText = `
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: rgba(255, 0, 0, 0.8);
                color: white;
                padding: 20px;
                border-radius: 10px;
                font-size: 24px;
                text-align: center;
                z-index: 1000;
            `;
            notification.textContent = 'You caught the player!';
            document.body.appendChild(notification);

            // Remove notification after 3 seconds
            setTimeout(() => {
                notification.remove();
            }, 3000);

            // TODO: Add game end logic here
        }

        // Add these new functions for win conditions
        function handlePlayerWin() {
            if (!gameStarted) return;
            gameStarted = false;

            if (controls) {
                controls.enabled = false;
            }
            
            // Play win sound for player, lose sound for monster
            if (playerRole === 'player') {
                playSound('win');
            } else if (playerRole === 'monster') {
                playSound('lose');
            }

            // Send game over message to server
            if (multiplayerManager && multiplayerManager.connected) {
                multiplayerManager.socket.send(JSON.stringify({
                    type: 'game_over',
                    winner: 'player',
                    roomCode: multiplayerManager.roomCode
                }));
            }
        }

        function handleMonsterWin() {
            if (!gameStarted) return;
            gameStarted = false;

            if (controls) {
                controls.enabled = false;
            }
            
            // Play win sound for monster, lose sound for player
            if (playerRole === 'monster') {
                playSound('win');
            } else if (playerRole === 'player') {
                playSound('lose');
            }

            // Send game over message to server
            if (multiplayerManager && multiplayerManager.connected) {
                multiplayerManager.socket.send(JSON.stringify({
                    type: 'game_over',
                    winner: 'monster',
                    roomCode: multiplayerManager.roomCode
                }));
            }
        }

        // Function to show game end screen to all players
        function showGameEndScreen(winner) {
            gameStarted = false;
            if (controls) controls.enabled = false;
            
            // Create end screen
            const endScreen = document.createElement('div');
            endScreen.id = 'gameEndScreen';
            endScreen.style.cssText = `
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: rgba(0, 0, 0, 0.95);
                color: white;
                padding: 40px;
                border-radius: 20px;
                text-align: center;
                font-size: 24px;
                z-index: 10000;
                border: 3px solid ${winner === 'player' ? '#00ff00' : '#ff0000'};
                box-shadow: 0 0 30px ${winner === 'player' ? 'rgba(0, 255, 0, 0.5)' : 'rgba(255, 0, 0, 0.5)'};
            `;
            
            const icon = winner === 'player' ? 'üéâ' : 'üëª';
            const winnerText = winner === 'player' ? 'Player Escaped!' : 'Monster Wins!';
            const subtitle = winner === 'player' ? 'The player reached the exit!' : 'The monster caught the player!';
            
            endScreen.innerHTML = `
                <h1 style="font-size: 48px; margin: 0 0 20px 0;">${icon} ${winnerText} ${icon}</h1>
                <p style="font-size: 22px; margin-bottom: 30px;">${subtitle}</p>
                <button id="playAgainButton" style="
                    background: #4CAF50;
                    border: none;
                    color: white;
                    padding: 15px 40px;
                    font-size: 24px;
                    cursor: pointer;
                    border-radius: 10px;
                    transition: all 0.3s;
                ">Play Again</button>
                <div id="playAgainStatus" style="margin-top: 20px; font-size: 18px;"></div>
            `;
            
            document.body.appendChild(endScreen);
            
            // Add button hover effect
            const playAgainBtn = document.getElementById('playAgainButton');
            playAgainBtn.onmouseover = () => playAgainBtn.style.transform = 'scale(1.1)';
            playAgainBtn.onmouseout = () => playAgainBtn.style.transform = 'scale(1)';
            
            // Handle play again click
            playAgainBtn.onclick = () => {
                playAgainBtn.disabled = true;
                playAgainBtn.style.opacity = '0.5';
                document.getElementById('playAgainStatus').textContent = 'Waiting for other players...';
                
                // Send play again request to server
                if (multiplayerManager && multiplayerManager.connected) {
                    multiplayerManager.socket.send(JSON.stringify({
                        type: 'play_again',
                        roomCode: multiplayerManager.roomCode
                    }));
                }
            };
        }

        function testBroadcast() {
            if (multiplayerManager && multiplayerManager.connected) {
                multiplayerManager.socket.send(JSON.stringify({
                    type: 'test_broadcast'
                }));
            } else {
                alert('Not connected to multiplayer server');
            }
        }

        function cleanupGame() {
            // Disable all controls and game logic
            gameStarted = false;
            if (controls) {
                controls.enabled = false;
            }

            // Remove event listeners
            document.removeEventListener('pointerlockchange', onPointerLockChange);
            document.removeEventListener('pointerlockerror', onPointerLockError);
            document.removeEventListener('mousemove', onMouseMove);
            if (keydownListener) document.removeEventListener('keydown', keydownListener);
            if (keyupListener) document.removeEventListener('keyup', keyupListener);
            
            // Exit pointer lock if active
            if (document.pointerLockElement) {
                document.exitPointerLock();
            }

            // Disconnect from server
            if (multiplayerManager && multiplayerManager.connected) {
                multiplayerManager.disconnect();
            }

            // Clear any animation frames
            if (window.animationFrameId) {
                cancelAnimationFrame(window.animationFrameId);
            }

            // Clear the scene
            if (scene) {
                while(scene.children.length > 0) { 
                    scene.remove(scene.children[0]); 
                }
            }

            // Dispose of renderer
            if (renderer && renderer.domElement) {
                renderer.domElement.remove();
                renderer.dispose();
            }

            // Hide all game-related elements
            const elementsToHide = [
                'guideView',
                'winScreen',
                'multiplayerMenu',
                'roomCode',
                'roomCodeInstructions',
                'loadingScreen',
                'errorScreen'
            ];
            
            elementsToHide.forEach(id => {
                const element = document.getElementById(id);
                if (element) {
                    element.style.display = 'none';
                }
            });

            // Show start screen
            const startScreen = document.getElementById('startScreen');
            if (startScreen) {
                startScreen.style.display = 'block';
            }

            // Reset all game variables
            scene = null;
            camera = null;
            renderer = null;
            controls = null;
            maze = null;
            mazeGroup = null;
            otherPlayers = {};
            playerRole = null;
            gameMode = 'single';
            multiplayerManager = null;
            playerPositions = {};
            monsterPositions = {};
            allPlayersJoined = false;
            roomCode = null;
            lastPositionUpdate = 0;
            lastPlayerPos = null;
            lastMonsterPos = null;
            isInitialized = false;
            animateDebugCount = 0;
        }

        // 3D click handling for architect
        function handleArchitect3DClick(event) {
            if (playerRole !== 'architect') return;
            
            
            // Cast ray from camera to determine where in the maze the architect clicked
            const raycaster = new THREE.Raycaster();
            const mouse = new THREE.Vector2();
            
            // Calculate mouse position in normalized device coordinates
            const rect = renderer.domElement.getBoundingClientRect();
            mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
            
            // Cast ray from camera
            raycaster.setFromCamera(mouse, camera);
            
            // Create a ground plane at y=0 to intersect with
            const groundPlane = new THREE.Plane(new THREE.Vector3(0, 1, 0), 0);
            const intersectionPoint = new THREE.Vector3();
            raycaster.ray.intersectPlane(groundPlane, intersectionPoint);
            
            if (intersectionPoint) {
                // Convert world coordinates to grid coordinates
                const gridX = Math.round(intersectionPoint.x / maze.cellSize);
                const gridZ = Math.round(intersectionPoint.z / maze.cellSize);
                
                
                // Validate grid coordinates
                if (gridX >= 0 && gridX < maze.maze[0].length && gridZ >= 0 && gridZ < maze.maze.length) {
                    performArchitectAction3D(gridX, gridZ, 'add');
                } else {
                }
            }
        }
        
        function handleArchitect3DRightClick(event) {
            if (playerRole !== 'architect') return;
            
            
            // Cast ray from camera to determine where in the maze the architect clicked
            const raycaster = new THREE.Raycaster();
            const mouse = new THREE.Vector2();
            
            // Calculate mouse position in normalized device coordinates
            const rect = renderer.domElement.getBoundingClientRect();
            mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
            
            // Cast ray from camera
            raycaster.setFromCamera(mouse, camera);
            
            // Create a ground plane at y=0 to intersect with
            const groundPlane = new THREE.Plane(new THREE.Vector3(0, 1, 0), 0);
            const intersectionPoint = new THREE.Vector3();
            raycaster.ray.intersectPlane(groundPlane, intersectionPoint);
            
            if (intersectionPoint) {
                // Convert world coordinates to grid coordinates
                const gridX = Math.round(intersectionPoint.x / maze.cellSize);
                const gridZ = Math.round(intersectionPoint.z / maze.cellSize);
                
                
                // Validate grid coordinates
                if (gridX >= 0 && gridX < maze.maze[0].length && gridZ >= 0 && gridZ < maze.maze.length) {
                    performArchitectAction3D(gridX, gridZ, 'remove');
                } else {
                }
            }
        }
        
        function performArchitectAction3D(gridX, gridZ, action) {
            if (playerRole !== 'architect') {
                return;
            }
            
            // Check moves remaining
            if (architectMovesRemaining <= 0) {
                showArchitectMessage('‚ùå No moves left! You only get 3 moves per game.', false);
                return;
            }
            
            
            // Calculate world coordinates
            const worldX = gridX * maze.cellSize;
            const worldZ = gridZ * maze.cellSize;
            
            // CHECK DISTANCE FROM PLAYER AND MONSTER (5 block minimum)
            const MIN_DISTANCE = 5 * maze.cellSize;
            
            const playerPos = Object.values(playerPositions)[0];
            if (playerPos) {
                const distToPlayer = Math.sqrt(
                    Math.pow(worldX - playerPos.x, 2) + 
                    Math.pow(worldZ - playerPos.z, 2)
                );
                if (distToPlayer < MIN_DISTANCE) {
                    showArchitectMessage('‚ùå Too close to player! (min 5 blocks)', false);
                    return;
                }
            }
            
            const monsterPos = Object.values(monsterPositions)[0];
            if (monsterPos) {
                const distToMonster = Math.sqrt(
                    Math.pow(worldX - monsterPos.x, 2) + 
                    Math.pow(worldZ - monsterPos.z, 2)
                );
                if (distToMonster < MIN_DISTANCE) {
                    showArchitectMessage('‚ùå Too close to monster! (min 5 blocks)', false);
                    return;
                }
            }
            
            // Check current state
            const currentValue = maze.maze[gridZ][gridX];
            
            if (action === 'add' && currentValue === 1) {
                showArchitectMessage('‚ùå Wall already exists!', false);
                return;
            }
            
            if (action === 'remove' && currentValue === 0) {
                showArchitectMessage('‚ùå No wall to remove!', false);
                return;
            }
            
            // Decrement moves remaining
            architectMovesRemaining--;
            updateArchitectMovesDisplay(); // Immediately update display
            showArchitectMessage(`‚úÖ ${action === 'add' ? 'Wall placed' : 'Wall removed'}! ${architectMovesRemaining} moves left`, true);
            
            // Send the update to the server
            if (multiplayerManager && multiplayerManager.connected) {
                const updateData = {
                    type: 'architect_update',
                    action: action,
                    gridX: gridX,
                    gridZ: gridZ,
                    x: worldX,
                    z: worldZ
                };
                
                multiplayerManager.socket.send(JSON.stringify(updateData));
                
                // Show feedback
                showArchitectMessage(`Wall ${action === 'add' ? 'added' : 'removed'} at (${gridX}, ${gridZ})!`, true);
            } else {
                console.error('üèóÔ∏è Cannot send architect update - not connected to server');
                showArchitectMessage('Not connected to server!', false);
            }
        }
    </script>
</body>
</html> 