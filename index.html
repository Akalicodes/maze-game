<!DOCTYPE html>
<html>
<head>
    <title>3D Maze Game</title>
    <!-- Load Three.js from local file -->
            <script src="js/three.min.js?v=3"></script>
        <script src="js/maze-generator.js?v=3"></script>
        <script src="js/multiplayer.js?v=3"></script>
    <script>
        // Verify Three.js loaded
        window.addEventListener('load', function() {
            if (typeof THREE === 'undefined') {
                document.body.innerHTML = '<div style="color: red; text-align: center; margin-top: 50px;">Error: Failed to load 3D library. Please try refreshing the page.</div>';
            }
        });
    </script>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: Arial, sans-serif;
            background: #000;
            color: #fff;
        }
        #startScreen {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            background: none;
            color: white;
            padding: 30px;
            z-index: 1000;
            pointer-events: auto !important;
        }
        #startScreen h1 {
            color: #4CAF50;
            text-shadow: 0 0 15px rgba(76, 175, 80, 0.7);
            margin-bottom: 30px;
            font-size: 48px;
        }
        #startScreen .instruction {
            color: rgba(255, 255, 255, 0.9);
            margin: 8px 0;
            font-size: 18px;
            text-shadow: 0 0 10px rgba(255, 255, 255, 0.5);
        }
        .gameButton {
            background: rgba(76, 175, 80, 0.8);
            border: 2px solid rgba(255, 255, 255, 0.2);
            color: white;
            padding: 15px 30px;
            font-size: 20px;
            cursor: pointer;
            border-radius: 25px;
            transition: all 0.3s;
            margin: 15px;
            width: 200px;
            backdrop-filter: blur(5px);
            text-shadow: 0 0 5px rgba(0, 0, 0, 0.3);
        }
        .gameButton:hover {
            background: rgba(76, 175, 80, 1);
            transform: scale(1.05);
            box-shadow: 0 0 20px rgba(76, 175, 80, 0.4);
        }
        #multiplayerMenu {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 30px;
            border-radius: 15px;
            z-index: 1000;
            display: none;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
        }
        #roomCodeInput {
            padding: 10px;
            font-size: 18px;
            margin: 10px;
            border-radius: 5px;
            border: none;
            text-align: center;
            width: 180px;
        }
        .backButton {
            background: #666;
            border: none;
            color: white;
            padding: 10px 20px;
            font-size: 16px;
            cursor: pointer;
            border-radius: 5px;
            transition: all 0.3s;
            margin-top: 20px;
        }
        .backButton:hover {
            background: #555;
        }
        #roomCode {
            font-size: 48px;
            margin: 20px;
            padding: 30px;
            background: rgba(0, 0, 0, 0.9);
            border-radius: 15px;
            font-family: monospace;
            letter-spacing: 8px;
            text-align: center;
            border: 3px solid #4CAF50;
            color: #4CAF50;
            cursor: pointer;
            user-select: all;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 9999;
            box-shadow: 0 0 30px rgba(76, 175, 80, 0.5);
            transition: all 0.3s ease;
            animation: pulse 2s infinite;
            display: none;
        }
        @keyframes pulse {
            0% { box-shadow: 0 0 30px rgba(76, 175, 80, 0.5); }
            50% { box-shadow: 0 0 50px rgba(76, 175, 80, 0.8); }
            100% { box-shadow: 0 0 30px rgba(76, 175, 80, 0.5); }
        }
        #roomCodeInstructions {
            color: #fff;
            font-size: 18px;
            margin-top: 20px;
            text-align: center;
            position: fixed;
            top: calc(50% + 100px);
            left: 50%;
            transform: translateX(-50%);
            z-index: 1000;
            background: rgba(0, 0, 0, 0.8);
            padding: 15px 30px;
            border-radius: 10px;
            animation: fadeIn 0.5s ease-out;
        }
        @keyframes fadeIn {
            from { opacity: 0; transform: translate(-50%, 20px); }
            to { opacity: 1; transform: translate(-50%, 0); }
        }
        #loadingScreen {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 20px;
            border-radius: 10px;
            z-index: 2000;
            display: none;
        }
        #loadingMessage {
            margin-top: 10px;
            font-size: 18px;
        }
        #errorScreen {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            background: rgba(255, 0, 0, 0.9);
            color: white;
            padding: 30px;
            border-radius: 15px;
            z-index: 3000;
            display: none;
            max-width: 80%;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
        }
        #errorMessage {
            margin: 20px 0;
            font-size: 16px;
            white-space: pre-wrap;
            text-align: left;
        }
        #debugInfo {
            margin-top: 20px;
            font-size: 14px;
            color: #ddd;
            text-align: left;
            font-family: monospace;
            background: rgba(0, 0, 0, 0.3);
            padding: 10px;
            border-radius: 5px;
            max-height: 200px;
            overflow-y: auto;
        }
        .spinner {
            border: 4px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            border-top: 4px solid white;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 10px auto;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        #winScreen {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 30px;
            border-radius: 15px;
            text-align: center;
            z-index: 2000;
            display: none;
            animation: popIn 0.5s ease-out;
        }
        @keyframes popIn {
            0% { transform: translate(-50%, -50%) scale(0.5); opacity: 0; }
            100% { transform: translate(-50%, -50%) scale(1); opacity: 1; }
        }
        #winScreen h2 {
            color: #4CAF50;
            margin-bottom: 20px;
            font-size: 32px;
            text-shadow: 0 0 10px rgba(76, 175, 80, 0.5);
        }
        #winScreen p {
            font-size: 20px;
            margin: 15px 0;
            color: #fff;
        }
        #winScreen button {
            background: #4CAF50;
            border: none;
            color: white;
            padding: 15px 30px;
            border-radius: 5px;
            cursor: pointer;
            margin: 10px;
            font-size: 20px;
            transition: all 0.3s;
        }
        #winScreen button:hover {
            background: #45a049;
            transform: scale(1.1);
        }
        /* Remove crosshair cursor */
        canvas {
            pointer-events: auto !important;
            cursor: default !important;
            outline: none;
            z-index: 1;
        }
        
        /* Update win screen styles */
        #winScreen button {
            background: #4CAF50;
            border: none;
            color: white;
            padding: 15px 30px;
            font-size: 24px;
            cursor: pointer;
            border-radius: 8px;
            transition: all 0.3s;
            margin-top: 20px;
        }
        
        #winScreen button:hover {
            background: #45a049;
            transform: scale(1.1);
        }
        * {
            pointer-events: auto !important;
            cursor: default;
        }
        #gameContainer {
            position: relative;
            width: 100%;
            height: 100%;
        }
        .no-cursor {
            cursor: none;
        }
        .game-canvas {
            outline: none;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            -khtml-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
            pointer-events: auto !important;
        }
        #guideInstructions {
            position: absolute;
            top: 20px;
            left: 20px;
            color: #4CAF50;
            font-size: 18px;
            text-shadow: 0 0 5px rgba(76, 175, 80, 0.5);
        }
        #guideView {
            display: none;
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000;
            pointer-events: auto !important;
        }
        #guideCanvas {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: #111;
            pointer-events: auto !important;
        }
    </style>
</head>
<body>
    <div id="startScreen">
        <h1>3D Maze Game</h1>
        <div class="instruction">Navigate through the maze to find the exit</div>
        <div class="instruction">Use WASD to move and mouse to look around</div>
        <button class="gameButton" id="singlePlayerButton">Single Player</button>
        <button class="gameButton" id="multiplayerButton">Multiplayer</button>
    </div>

    <div id="roomCode" class="room-code"></div>
    <div id="roomCodeInstructions" class="room-code-instructions"></div>

    <div id="multiplayerMenu">
        <h2>Multiplayer Mode</h2>
        <button class="gameButton" id="createRoomButton">Create Room</button>
        <button class="gameButton" id="joinRoomButton">Join Room</button>
        <input type="text" id="roomCodeInput" placeholder="Enter Room Code" style="display: none;">
        <button class="backButton" id="backToMainButton">Back to Main Menu</button>
    </div>

    <div id="loadingScreen">
        <div class="spinner"></div>
        <div id="loadingMessage">Loading Game...</div>
    </div>

    <!-- Add new waiting and role assignment screens -->
    <div id="waitingScreen" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); text-align: center; background: rgba(0, 0, 0, 0.9); color: white; padding: 40px; border-radius: 20px; z-index: 2000; border: 3px solid #4CAF50; box-shadow: 0 0 30px rgba(76, 175, 80, 0.5);">
        <h2 style="color: #4CAF50; font-size: 32px; margin-bottom: 20px; text-shadow: 0 0 10px rgba(76, 175, 80, 0.5);">🎮 Waiting for Players</h2>
        <div class="spinner"></div>
        <div id="waitingMessage" style="font-size: 20px; margin: 20px 0;">Waiting for players to join...</div>
                        <div id="playerCount" style="font-size: 18px; color: #4CAF50;">Players joined: 1/4</div>
        <div style="margin-top: 30px; text-align: center;">
            <div style="font-size: 18px; color: #ccc; margin-bottom: 10px;">Room Code:</div>
            <div id="waitingRoomCode" style="font-family: monospace; color: #4CAF50; cursor: pointer; padding: 15px 25px; border: 3px solid #4CAF50; border-radius: 10px; font-size: 32px; font-weight: bold; letter-spacing: 4px; background: rgba(76, 175, 80, 0.1); transition: all 0.3s; display: inline-block;" onclick="copyRoomCode(this)" title="Click to copy" onmouseover="this.style.background='rgba(76, 175, 80, 0.2)'" onmouseout="this.style.background='rgba(76, 175, 80, 0.1)'"></div>
            <div style="font-size: 14px; color: #999; margin-top: 10px;">Click to copy • Share with other players</div>
        </div>
    </div>

    <div id="roleAssignmentScreen" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); text-align: center; background: rgba(0, 0, 0, 0.9); color: white; padding: 40px; border-radius: 20px; z-index: 2000; border: 3px solid #FFD700; box-shadow: 0 0 30px rgba(255, 215, 0, 0.5);">
        <h2 style="color: #FFD700; font-size: 32px; margin-bottom: 20px; text-shadow: 0 0 10px rgba(255, 215, 0, 0.5);">🎲 Assigning Roles</h2>
        <div class="spinner" style="border-top-color: #FFD700;"></div>
        <div style="font-size: 20px; margin: 20px 0;">All players joined! Assigning roles...</div>
        <div style="font-size: 16px; color: #ccc;">Please wait while roles are being assigned</div>
    </div>

    <div id="yourRoleScreen" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); text-align: center; background: rgba(0, 0, 0, 0.9); color: white; padding: 40px; border-radius: 20px; z-index: 2000; border: 3px solid #FF6B6B; box-shadow: 0 0 30px rgba(255, 107, 107, 0.5);">
        <h2 style="color: #FF6B6B; font-size: 32px; margin-bottom: 20px; text-shadow: 0 0 10px rgba(255, 107, 107, 0.5);">🎭 Your Role</h2>
        <div id="assignedRole" style="font-size: 36px; font-weight: bold; margin: 20px 0; color: #4CAF50;"></div>
        <div id="roleDescription" style="font-size: 18px; margin: 20px 0; line-height: 1.5;"></div>
        <div style="font-size: 16px; color: #FFD700; margin-top: 20px;">Game starting in 3 seconds...</div>
    </div>

    <div id="errorScreen">
        <h2>Error</h2>
        <div id="errorMessage"></div>
        <div id="debugInfo"></div>
        <button onclick="location.reload()" style="margin-top: 15px; padding: 10px 20px; cursor: pointer; background: white; color: red; border: none; border-radius: 5px; font-weight: bold;">Reload Game</button>
    </div>

    <div id="winScreen">
        <h2>🎉 You Won! 🎉</h2>
        <p>Congratulations! You made it through the maze!</p>
        <p>Refresh the page to play again</p>
    </div>

    <div id="guideView" style="display: none;">
        <canvas id="guideCanvas"></canvas>
        <div id="guideInstructions">
            <span id="roleTitle">Guide View</span>
        </div>
    </div>

    <!-- Temporary debug test button -->
    <button id="testBroadcastBtn" onclick="testBroadcast()" style="position: fixed; top: 10px; right: 10px; z-index: 9999; background: #ff6b6b; color: white; padding: 10px; border: none; border-radius: 5px; cursor: pointer; font-weight: bold;">🧪 Test Broadcast</button>

    <script>
        let scene, camera, renderer, controls;
        let maze, mazeGroup;
        const MAZE_SIZE = { width: 25, height: 25 };
        let keydownListener, keyupListener;
        let textureLoader;
        let architectWallMaterial = null; // Global material for architect walls
        let handleWallChangedCallCount = 0; // Track how many times handleWallChanged is called
        let gameMode = 'single';
        let multiplayerManager = null;
        let otherPlayers = {};
        let gameStarted = false;
        let playerRole = null;
        let gameTimer = null;
        let gameTimeLimit = 300000; // 5 minutes in milliseconds
        let guideCanvas, guideCtx;
        let playerPositions = {}; // Track positions by player ID
        let monsterPositions = {}; // Track monster positions by player ID
        let allPlayersJoined = false;
        let requiredPlayers = 4;
        let roomCode = null;
        let lastPositionUpdate = 0;
        const POSITION_UPDATE_INTERVAL = 100; // Throttle position updates for better performance
        let monsterTexture = null;
        // Add smoothing state variables at the top of the file, after other variable declarations
        let lastPlayerPos = null;
        let lastMonsterPos = null;
        const positionSmoothingFactor = 0.3;
        const rotationSmoothingFactor = 0.3;
        // Performance optimization variables
        let lastArrowUpdate = 0;
        const ARROW_UPDATE_INTERVAL = 100; // Update arrow every 100ms for better performance
        let rotationBuffer = [];
        const ROTATION_BUFFER_SIZE = 3; // Reduce buffer size for memory efficiency

        function createMonsterMesh() {
            // Create a plane geometry that always faces the camera
            const monsterGeometry = new THREE.PlaneGeometry(2, 2);
            const monsterMaterial = new THREE.MeshBasicMaterial({
                map: textureLoader.load('monster.png'),
                transparent: true,
                side: THREE.DoubleSide
            });
            const monster = new THREE.Mesh(monsterGeometry, monsterMaterial);
            
            // Create a container for the monster to handle positioning
            const monsterContainer = new THREE.Object3D();
            monsterContainer.add(monster);
            
            // Make the monster plane always face the camera
            monster.onBeforeRender = function(renderer, scene, camera) {
                monster.quaternion.copy(camera.quaternion);
            };
            
            return monsterContainer;
        }

        function createRoom() {
            if (gameStarted) {
                console.log('Game already started, ignoring createRoom');
                return;
            }
            
            showLoadingScreen('Creating Room...');
            console.log('Creating room...');
            
            // Initialize multiplayer manager
            multiplayerManager = new MultiplayerManager();
            
            // Set up callbacks
            multiplayerManager.onConnectionSuccess = () => {
                console.log('Successfully connected, creating room...');
                multiplayerManager.createRoom();
            };

            multiplayerManager.onMazeDataReceived = (mazeData) => {
                console.log('🗺️ Maze data received and loaded!', mazeData);
                maze = mazeData;
                maze.wallPositions = maze.wallPositions || [];
                
                // Now that we have maze data, we can safely initialize the scene
                console.log('🎬 Initializing scene after maze data received');
                init(false);
            };

            multiplayerManager.onRoomCreated = (roomCode) => {
                console.log('Room created with code:', roomCode);
                hideLoadingScreen();
                
                // Hide all menus
                hideAllMenus();
                
                // Show waiting screen
                document.getElementById('waitingScreen').style.display = 'block';
                document.getElementById('waitingRoomCode').textContent = roomCode;
                document.getElementById('playerCount').textContent = 'Players joined: 1/4';
                document.getElementById('waitingMessage').textContent = 'Waiting for 3 more players to join...';
                
                // Set the game mode but don't start yet
                gameMode = 'multiplayer';
                playerRole = 'waiting';
                allPlayersJoined = false;
                gameStarted = false;
                
                // Host should generate maze data immediately and send it to server
                console.log('🏠 Room created, host generating maze data...');
                const generator = new MazeGenerator(MAZE_SIZE.width, MAZE_SIZE.height);
                maze = generator.generate();
                
                // Send maze data to server for distribution to all players
                multiplayerManager.socket.send(JSON.stringify({
                    type: 'maze_data',
                    maze: maze
                }));
                
                console.log('🗺️ Maze generated and sent to server');
                
                // Now initialize the scene
                init(false);
            };

            multiplayerManager.onPlayerJoined = (playerId, role) => {
                console.log('Player joined:', playerId, 'as', role);
                
                // Update player count
                const currentPlayers = Object.keys(otherPlayers).length + 2; // +2 because we're counting this new player
                document.getElementById('playerCount').textContent = `Players joined: ${currentPlayers}/4`;
                
                const playersNeeded = requiredPlayers - currentPlayers;
                if (playersNeeded > 0) {
                    document.getElementById('waitingMessage').textContent = `Waiting for ${playersNeeded} more player${playersNeeded > 1 ? 's' : ''} to join...`;
                } else {
                    // All players joined - show role assignment screen
                    document.getElementById('waitingScreen').style.display = 'none';
                    document.getElementById('roleAssignmentScreen').style.display = 'block';
                    
                    document.getElementById('waitingMessage').textContent = 'All players joined! Assigning roles...';
                }
                
                if (!otherPlayers[playerId] && (playerRole === 'player' || playerRole === 'monster' || playerRole === 'architect')) {
                    console.log('Creating representation for player:', playerId, 'with role:', role, 'for viewer:', playerRole);
                    
                    // Create a more visible representation for players
                    let playerMesh;
                    if (role === 'monster') {
                        // Monster representation - red cylinder for all viewers
                        playerMesh = new THREE.Mesh(
                            new THREE.CylinderGeometry(0.3, 0.3, 2, 8),
                            new THREE.MeshPhongMaterial({ 
                                color: 0xff0000,
                                emissive: 0xff0000,
                                emissiveIntensity: 0.5
                            })
                        );
                    } else if (role === 'player') {
                        // Player representation - bright green cylinder for all viewers
                        const playerGeometry = new THREE.Group();
                        
                        // Main body - taller and brighter cylinder
                        const body = new THREE.Mesh(
                            new THREE.CylinderGeometry(0.4, 0.4, 2.5, 8),
                            new THREE.MeshPhongMaterial({ 
                                color: 0x00ff00,
                                emissive: 0x00ff00,
                                emissiveIntensity: 0.5
                            })
                        );
                        playerGeometry.add(body);
                        
                        // Add glowing ring at the top
                        const ring = new THREE.Mesh(
                            new THREE.TorusGeometry(0.5, 0.1, 8, 16),
                            new THREE.MeshPhongMaterial({
                                color: 0xffff00,
                                emissive: 0xffff00,
                                emissiveIntensity: 0.7
                            })
                        );
                        ring.position.y = 1.5;
                        ring.rotation.x = Math.PI / 2;
                        playerGeometry.add(ring);
                        
                        playerMesh = playerGeometry;
                    }
                    
                    if (playerMesh) {
                        otherPlayers[playerId] = playerMesh;
                        otherPlayers[playerId].position.set(0, 1, 0);
                        otherPlayers[playerId].visible = true;
                        scene.add(otherPlayers[playerId]);
                        console.log('Added player representation to scene for', playerRole, ':', playerId);
                    }
                }
            };

            multiplayerManager.onRoleAssigned = (role, message) => {
                console.log('🎭 Role assigned:', role, message);
                playerRole = role;
                
                // Hide role assignment screen and show your role screen
                document.getElementById('roleAssignmentScreen').style.display = 'none';
                document.getElementById('yourRoleScreen').style.display = 'block';
                
                // Update role information
                document.getElementById('assignedRole').textContent = role.toUpperCase();
                
                // Set role descriptions
                let description = '';
                switch(role) {
                    case 'player':
                        description = 'Navigate through the maze to find the green exit. Use WASD to move and mouse to look around. Avoid the monster!';
                        break;
                    case 'guide':
                        description = 'Help the player reach the exit using your top-down 2D view. You can see the entire maze layout and all player positions.';
                        break;
                    case 'architect':
                        description = 'Architect: Click to add/remove walls.';
                        break;
                    case 'monster':
                        description = 'Hunt the player in first-person view! Use WASD to move and mouse to look around. Catch the player before they escape!';
                        break;
                    default:
                        description = message || 'Unknown role';
                }
                document.getElementById('roleDescription').textContent = description;
                
                // DON'T initialize the scene yet - wait for onGameReady
                // This prevents race conditions with maze data loading
                console.log('🎭 Role assigned, waiting for game ready signal...');
            };

            multiplayerManager.onGameReady = () => {
                console.log('🎮 onGameReady called - Current role:', playerRole, 'Maze exists:', !!maze);
                allPlayersJoined = true;
                gameStarted = true;
                
                // Hide all UI screens
                hideAllMenus();
                
                // Wait for maze data if not available
                if (!maze) {
                    console.log('🎮 No maze data yet, waiting...');
                    setTimeout(() => {
                        if (maze) {
                            console.log('🎮 Maze data now available, starting game');
                            multiplayerManager.onGameReady();
                        } else {
                            console.error('🎮 Still no maze data after waiting');
                        }
                    }, 100);
                    return;
                }
                
                // Add a 3-second countdown before starting
                setTimeout(() => {
                    // Force game start based on role
                    console.log('🎮 Starting game for role:', playerRole);
                    if (playerRole === 'guide') {
                        console.log('🎮 Starting GUIDE view (2D only)');
                        initGuideView(maze);
                    } else if (playerRole === 'architect') {
                        console.log('🔥🔥🔥 Starting ARCHITECT view (2D ONLY)! 🔥🔥🔥');
                        // Architect gets pure 2D view like guide
                        initGuideView(maze);
                        
                        // Start game timer if multiplayer
                        if (gameMode === 'multiplayer') {
                            startGameTimer();
                        }
                    } else if (playerRole === 'player' || playerRole === 'monster') {
                        console.log('🎮 Starting 3D view for:', playerRole);
                        // Always call init(true) to ensure fresh initialization
                        init(true);
                        
                        // Start game timer if multiplayer
                        if (gameMode === 'multiplayer') {
                            startGameTimer();
                        }
                    } else {
                        console.log('🎮 Unknown role:', playerRole);
                    }
                    

                }, 3000);
            };

            multiplayerManager.onPlayerLeft = (playerId) => {
                if (otherPlayers[playerId]) {
                    scene.remove(otherPlayers[playerId]);
                    delete otherPlayers[playerId];
                }
                
                // Clean up position tracking for disconnected player
                delete playerPositions[playerId];
                delete monsterPositions[playerId];
                
                // Update UI to show disconnection and waiting state
                const currentPlayers = Object.keys(otherPlayers).length + 1;
                if (currentPlayers < requiredPlayers) {
                    allPlayersJoined = false;
                    gameStarted = false;
                    
                    // Show waiting message
                    const instructionsElement = document.getElementById('roomCodeInstructions');
                    instructionsElement.style.display = 'block';
                    instructionsElement.textContent = `A player has disconnected • Waiting for ${requiredPlayers - currentPlayers} more player${requiredPlayers - currentPlayers > 1 ? 's' : ''}...`;
                    
                    // Show room code again
                    const roomCodeElement = document.getElementById('roomCode');
                    roomCodeElement.style.display = 'block';
                }
            };

            multiplayerManager.onError = (error) => {
                console.error('Error in multiplayer:', error);
                hideLoadingScreen();
                alert(error);
                showMultiplayerMenu();
            };

            // Start connection
            multiplayerManager.connect();
        }

        function startMultiplayerGame() {
            if (!gameStarted) {
                console.log('Starting multiplayer game...');
                gameStarted = true;
                
                // Hide all menus
                document.getElementById('startScreen').style.display = 'none';
                document.getElementById('multiplayerMenu').style.display = 'none';
                document.getElementById('winScreen').style.display = 'none';
                
                // Set up multiplayer components
                setupMultiplayer();
                
                // Start the animation loop
                animate();
            }
        }

        function startGame(mode = 'single') {
            if (mode === 'multiplayer') {
                console.log('Redirecting multiplayer start to startMultiplayerGame');
                startMultiplayerGame();
                return;
            }
            
            console.log('Starting single player game...');
            gameStarted = false; // Reset first
            playerRole = 'player'; // Set role for single player
            
            // Hide ALL menu elements
            hideAllMenus();
            
            // Remove old renderer and clean up
            cleanupRenderer();

            // Clean up old multiplayer resources
            cleanupMultiplayer();
            
            // Start fresh game
            gameStarted = true;
            gameMode = mode;
            init();
        }

        function hideAllMenus() {
            const menuElements = [
                'startScreen',
                'multiplayerMenu',
                'winScreen',
                'roomCode',
                'roomCodeInstructions',
                'loadingScreen',
                'errorScreen',
                'guideView',
                'waitingScreen',
                'roleAssignmentScreen',
                'yourRoleScreen',
                'simple-waiting'
            ];
            
            menuElements.forEach(elementId => {
                const element = document.getElementById(elementId);
                if (element) {
                    element.style.display = 'none';
                }
            });
        }

        function cleanupRenderer() {
            if (window.animationFrameId) {
                cancelAnimationFrame(window.animationFrameId);
                window.animationFrameId = null;
            }
            
            if (renderer && renderer.domElement && renderer.domElement.parentNode) {
                // Remove pointer lock event listeners
                document.removeEventListener('pointerlockchange', onPointerLockChange);
                document.removeEventListener('pointerlockerror', onPointerLockError);
                document.removeEventListener('mousemove', onMouseMove);
                
                // Exit pointer lock if active
                if (document.pointerLockElement === renderer.domElement) {
                    document.exitPointerLock();
                }
                
                renderer.domElement.parentNode.removeChild(renderer.domElement);
                renderer.dispose();
                renderer = null;
            }
            
            // Clean up event listeners
            if (keydownListener) {
                document.removeEventListener('keydown', keydownListener);
                keydownListener = null;
            }
            if (keyupListener) {
                document.removeEventListener('keyup', keyupListener);
                keyupListener = null;
            }
        }

        function cleanupMultiplayer() {
            if (multiplayerManager) {
                multiplayerManager.disconnect();
                multiplayerManager = null;
            }
        }

        function init(shouldStartAnimation = true) {
            console.log('🔥🔥🔥 INIT CALLED: mode=', gameMode, 'role=', playerRole, 'shouldStartAnimation=', shouldStartAnimation, 'mazeExists=', !!maze);
            
            try {
                // Guide and architect both get only 2D view
                if (playerRole === 'guide' || playerRole === 'architect') {
                    console.log(`🎮 Initializing ${playerRole.toUpperCase()} view (2D only)...`);
                    // Initialize guide view
                    document.body.style.cursor = 'default';
                    if (maze) {
                        console.log('🗺️ Maze data available for 2D view, calling initGuideView');
                        initGuideView(maze);
                    } else {
                        console.error('❌ No maze data available for 2D view');
                        document.body.innerHTML = '<div style="color: red; text-align: center; margin-top: 50px;">Error: No maze data available. Please try refreshing the page.</div>';
                    }
                    return;
                }

                console.log('🎮 Initializing 3D view for role:', playerRole);

                // Both player and monster get the same 3D setup
                console.log('🎨 Creating THREE.js scene...');
                scene = new THREE.Scene();
                scene.background = new THREE.Color(0x000000);
                
                // Create renderer
                console.log('🖥️ Creating WebGL renderer...');
                renderer = new THREE.WebGLRenderer({ 
                    antialias: true,
                    powerPreference: "high-performance"
                });
                renderer.setSize(window.innerWidth, window.innerHeight);
                renderer.setPixelRatio(window.devicePixelRatio);
                
                // Style the renderer canvas properly
                renderer.domElement.style.position = 'fixed';
                renderer.domElement.style.top = '0';
                renderer.domElement.style.left = '0';
                renderer.domElement.style.width = '100%';
                renderer.domElement.style.height = '100%';
                renderer.domElement.style.zIndex = '1';
                renderer.domElement.style.display = 'block';
                
                // For architect, make the canvas slightly transparent so they can see both views
                if (playerRole === 'architect') {
                    renderer.domElement.style.opacity = '0.8';
                    renderer.domElement.style.zIndex = '10';
                    console.log('🎮 Architect renderer canvas made semi-transparent');
                }
                
                document.body.appendChild(renderer.domElement);
                console.log('🖥️ Renderer canvas added to DOM');
                
                // Create first-person camera
                camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
                
                // Make scene, camera, and renderer globally accessible for wall updates
                window.scene = scene;
                window.camera = camera;
                window.renderer = renderer;
                console.log('🌍 Made scene, camera, and renderer globally accessible');
                
                // Load textures
                textureLoader = new THREE.TextureLoader();
                
                // Generate new maze only for single player mode
                if (gameMode === 'single' && !maze) {
                    const generator = new MazeGenerator(MAZE_SIZE.width, MAZE_SIZE.height);
                    maze = generator.generate();
                    console.log('✅ Generated maze for single player mode');
                }
                
                if (!maze) {
                    console.error('❌ No maze data available when trying to init 3D view');
                    throw new Error('No maze data available');
                }
                console.log('✅ Maze data is available for 3D view');

                // Clean up any existing role labels first
                const existingLabels = document.querySelectorAll('.role-label');
                existingLabels.forEach(label => label.remove());

                // Set starting position based on role
                if (playerRole === 'monster') {
                    // Place monster at a random position
                    const randomCell = getRandomEmptyCell(maze);
                    camera.position.set(
                        randomCell.x * maze.cellSize,
                        1.5,
                        randomCell.z * maze.cellSize
                    );
                    console.log('Monster spawned at:', camera.position);

                    // Add monster UI overlay
                    const monsterInstructions = document.createElement('div');
                    monsterInstructions.className = 'role-label';
                    monsterInstructions.style.cssText = `
                        position: fixed;
                        top: 20px;
                        left: 20px;
                        color: #ff0000;
                        font-size: 18px;
                        text-shadow: 0 0 5px rgba(255, 0, 0, 0.5);
                        z-index: 1000;
                    `;
                    monsterInstructions.innerHTML = `Monster View`;
                    document.body.appendChild(monsterInstructions);
                } else if (playerRole === 'player') {
                    // Set player starting position
                    camera.position.set(
                        maze.startPosition.x,
                        1.5,
                        maze.startPosition.z
                    );
                    console.log('Player spawned at:', camera.position);

                    // Add player UI overlay
                    const playerInstructions = document.createElement('div');
                    playerInstructions.className = 'role-label';
                    playerInstructions.style.cssText = `
                        position: fixed;
                        top: 20px;
                        left: 20px;
                        color: #4CAF50;
                        font-size: 18px;
                        text-shadow: 0 0 5px rgba(76, 175, 80, 0.5);
                        z-index: 1000;
                    `;
                    playerInstructions.innerHTML = `Player`;
                    document.body.appendChild(playerInstructions);
                }

                // Hide guide view for all 3D roles (player, monster only, not architect)
                const guideView = document.getElementById('guideView');
                if (guideView) {
                    guideView.style.display = 'none';
                }
                
                // Generate maze geometry
                mazeGroup = new THREE.Group();
                generateNewMaze();
                
                // Set up controls
                controls = setupControls();
                
                // Only start animation and game if requested
                if (shouldStartAnimation) {
                    console.log('🎬 Starting animation and game...');
                    gameStarted = true;
                    animate();
                    
                    // Request pointer lock for player and monster, but not architect
                    if (playerRole !== 'architect') {
                        renderer.domElement.requestPointerLock();
                        console.log('🎬 Animation started and pointer lock requested');
                    } else {
                        console.log('🎬 Animation started for architect (no pointer lock)');
                    }
                } else {
                    gameStarted = false;
                    console.log('🎬 Game initialized but not started - waiting for all players');
                }
                
                if (playerRole !== 'architect') {
                    console.log('Game initialized in mode:', gameMode, 'role:', playerRole, 'with first-person view');
                }
            } catch (error) {
                console.error('❌ Error initializing game:', error);
                // Show detailed error information
                const errorDiv = document.createElement('div');
                errorDiv.style.cssText = `
                    position: fixed;
                    top: 50%;
                    left: 50%;
                    transform: translate(-50%, -50%);
                    background: rgba(0, 0, 0, 0.9);
                    color: white;
                    padding: 20px;
                    border-radius: 10px;
                    text-align: center;
                    z-index: 9999;
                    max-width: 80%;
                `;
                errorDiv.innerHTML = `
                    <h3>🚨 Game Initialization Error</h3>
                    <p>Role: ${playerRole || 'Unknown'}</p>
                    <p>Maze available: ${!!maze ? 'Yes' : 'No'}</p>
                    <p>Scene exists: ${!!scene ? 'Yes' : 'No'}</p>
                    <p>Error: ${error.message}</p>
                    <button onclick="location.reload()" style="margin-top: 15px; padding: 10px 20px; background: #ff4444; color: white; border: none; border-radius: 5px; cursor: pointer;">
                        Reload Game
                    </button>
                `;
                document.body.appendChild(errorDiv);
            }
        }

        function generateNewMaze() {
            if (mazeGroup) {
                // Remove all objects from the scene
                while(scene.children.length > 0){ 
                    scene.remove(scene.children[0]); 
                }
                mazeGroup = new THREE.Group();
            }

            // Initialize maze.wallPositions array
            if (!maze.wallPositions) {
                maze.wallPositions = [];
            }

            mazeGroup = new THREE.Group();
            
            // Add static lights in a sparser grid pattern
            const mazeWidth = MAZE_SIZE.width * maze.cellSize;
            const mazeHeight = MAZE_SIZE.height * maze.cellSize;
            
            // Calculate positions for a few strategic lights
            const lights = [
                // Center light
                {x: 0, z: 0, intensity: 8.0, distance: 70},
                
                // Four quadrant lights
                {x: -mazeWidth/4, z: -mazeHeight/4, intensity: 6.0, distance: 50},
                {x: mazeWidth/4, z: -mazeHeight/4, intensity: 6.0, distance: 50},
                {x: -mazeWidth/4, z: mazeHeight/4, intensity: 6.0, distance: 50},
                {x: mazeWidth/4, z: mazeHeight/4, intensity: 6.0, distance: 50},
                
                // Additional corner lights
                {x: -mazeWidth/2, z: -mazeHeight/2, intensity: 5.0, distance: 40},
                {x: mazeWidth/2, z: -mazeHeight/2, intensity: 5.0, distance: 40},
                {x: -mazeWidth/2, z: mazeHeight/2, intensity: 5.0, distance: 40},
                {x: mazeWidth/2, z: mazeHeight/2, intensity: 5.0, distance: 40}
            ];
            
            // Add brighter ambient light for better overall visibility
            const ambientLight = new THREE.AmbientLight(0xffffff, 3.0);
            scene.add(ambientLight);
            
            // Add all lights
            lights.forEach(light => {
                const pointLight = new THREE.PointLight(0xffffff, light.intensity, light.distance);
                pointLight.position.set(light.x, 3.5, light.z);
                scene.add(pointLight);
            });

            // Load textures
            const wallTexture = textureLoader.load('wall.jpg');
            wallTexture.wrapS = wallTexture.wrapT = THREE.RepeatWrapping;
            wallTexture.repeat.set(1, 1);

            // Create wall geometry and material only once for better performance
            const wallGeometry = new THREE.BoxGeometry(maze.cellSize, maze.wallHeight, maze.cellSize);
            const wallMaterial = new THREE.MeshPhongMaterial({
                map: wallTexture,
                color: 0xcccccc,
                specular: 0x222222,
                shininess: 10,
                transparent: false,
                opacity: 1.0,
                side: THREE.FrontSide,
                depthWrite: true,
                depthTest: true
            });

            // Create architect wall material for reuse
            const architectWallTexture = textureLoader.load('wall.jpg');
            architectWallTexture.wrapS = architectWallTexture.wrapT = THREE.RepeatWrapping;
            architectWallTexture.repeat.set(1, 1);
            
            architectWallMaterial = new THREE.MeshPhongMaterial({
                map: architectWallTexture,
                color: 0xffdddd, // Slightly reddish tint for architect walls
                specular: 0x222222,
                shininess: 10,
                transparent: false,
                opacity: 1.0,
                side: THREE.FrontSide,
                depthWrite: true,
                depthTest: true
            });

            // Clear existing walls array
            maze.wallPositions = [];

            function addWall(x, z) {
                const wall = new THREE.Mesh(wallGeometry, wallMaterial);
                wall.position.set(x * maze.cellSize, maze.wallHeight / 2, z * maze.cellSize);
                wall.castShadow = true;
                wall.receiveShadow = true;
                wall.matrixAutoUpdate = false; // Optimize performance
                wall.userData = { gridX: x, gridZ: z }; // Store grid coordinates for architect functionality
                wall.updateMatrix();
                mazeGroup.add(wall);
                
                maze.wallPositions.push({ x: x * maze.cellSize, z: z * maze.cellSize });
            }

            // Clear existing walls
            while(mazeGroup.children.length > 0) {
                const obj = mazeGroup.children[0];
                obj.geometry.dispose();
                obj.material.dispose();
                mazeGroup.remove(obj);
            }

            // Add maze walls
            for (let y = 0; y < MAZE_SIZE.height; y++) {
                for (let x = 0; x < MAZE_SIZE.width; x++) {
                    if (maze.maze[y][x] === 1) {
                        addWall(x, y);
                    }
                }
            }

            // Add boundary walls
            for (let x = -1; x <= MAZE_SIZE.width; x++) {
                addWall(x, -1);
                addWall(x, MAZE_SIZE.height);
            }

            for (let z = -1; z <= MAZE_SIZE.height; z++) {
                addWall(-1, z);
                addWall(MAZE_SIZE.width, z);
            }

            // Add floor
            const floorGeometry = new THREE.PlaneGeometry(
                (MAZE_SIZE.width + 2) * maze.cellSize,
                (MAZE_SIZE.height + 2) * maze.cellSize
            );
            const floorMaterial = new THREE.MeshPhongMaterial({
                color: 0x808080,  // Lighter floor color
                specular: 0x222222,
                shininess: 10,
                side: THREE.FrontSide,
                depthWrite: true
            });
            const floor = new THREE.Mesh(floorGeometry, floorMaterial);
            floor.rotation.x = -Math.PI / 2;
            floor.position.set(
                (MAZE_SIZE.width * maze.cellSize) / 2,
                0,
                (MAZE_SIZE.height * maze.cellSize) / 2
            );
            mazeGroup.add(floor);

            // Add end marker with improved material
            const endMarkerGeometry = new THREE.CylinderGeometry(0.4, 0.4, 0.1, 32);
            const endMarkerMaterial = new THREE.MeshPhongMaterial({ 
                color: 0x00ff00,
                emissive: 0x00ff00,
                emissiveIntensity: 0.5,
                transparent: false,
                opacity: 1.0,
                depthWrite: true
            });
            const endMarker = new THREE.Mesh(endMarkerGeometry, endMarkerMaterial);
            
            // Place end marker at the correct world position (don't multiply by cellSize again)
            endMarker.position.set(
                maze.endPosition.x,
                0.05,
                maze.endPosition.z
            );
            
            // Add point light to end marker for glow
            const endLight = new THREE.PointLight(0x00ff00, 1, 5);
            endLight.position.copy(endMarker.position);
            endLight.position.y = 1;
            
            mazeGroup.add(endMarker);
            mazeGroup.add(endLight);

            // Add the entire maze group to the scene
            scene.add(mazeGroup);
        }

        function checkCollision(position) {
            if (!maze || !maze.wallPositions || !Array.isArray(maze.wallPositions)) {
                console.log('Maze or wall positions not properly initialized');
                return { x: false, z: false };
            }

            const playerRadius = 0.5;
            const wallBuffer = 0.3;
            let collisionX = false;
            let collisionZ = false;
            let nearestWallDist = Infinity;
            let slideX = 0;
            let slideZ = 0;
            
            // Check collision with each wall
            for (const wall of maze.wallPositions) {
                // Calculate distances for each axis
                const dx = position.x - wall.x;
                const dz = position.z - wall.z;
                const distance = Math.sqrt(dx * dx + dz * dz);
                
                // Calculate the minimum distance needed to avoid collision
                const minDistance = maze.cellSize / 2 + playerRadius + wallBuffer;
                
                // If we're within collision range
                if (distance < minDistance) {
                    // Update nearest wall distance
                    if (distance < nearestWallDist) {
                        nearestWallDist = distance;
                        
                        // Calculate normalized direction from wall to player
                        const nx = dx / distance;
                        const nz = dz / distance;
                        
                        // Calculate slide vector
                        const penetration = minDistance - distance;
                        slideX = nx * penetration;
                        slideZ = nz * penetration;
                    }
                    
                    // Set collision flags based on approach angle
                    const dotX = Math.abs(dx / distance);
                    const dotZ = Math.abs(dz / distance);
                    
                    if (dotX > 0.7) collisionX = true;
                    if (dotZ > 0.7) collisionZ = true;
                }
            }
            
            return {
                x: collisionX,
                z: collisionZ,
                slideX: slideX,
                slideZ: slideZ
            };
        }

        function setupControls() {
            const moveSpeed = playerRole === 'monster' ? 0.1 : (playerRole === 'architect' ? 0.2 : 0.15);
            const turnSpeed = 0.06;
            let isPointerLocked = false;
            
            const controls = {
                enabled: true,
                update: null
            };
            
            const keys = {
                forward: false,
                backward: false,
                left: false,
                right: false
            };

            // Remove any existing listeners
            if (keydownListener) document.removeEventListener('keydown', keydownListener);
            if (keyupListener) document.removeEventListener('keyup', keyupListener);

            function onMouseMove(event) {
                if (isPointerLocked && gameStarted && (playerRole === 'player' || playerRole === 'monster')) {
                    camera.rotation.y -= event.movementX * 0.002;
                }
                // Architect doesn't need mouse look - they have fixed overhead view
            }

            function onPointerLockChange() {
                isPointerLocked = document.pointerLockElement === renderer.domElement;
            }

            function onPointerLockError() {
                console.error('Pointer lock error');
            }

            document.addEventListener('pointerlockchange', onPointerLockChange);
            document.addEventListener('pointerlockerror', onPointerLockError);
            document.addEventListener('mousemove', onMouseMove);

            if (renderer && renderer.domElement) {
                renderer.domElement.addEventListener('click', (event) => {
                                    // Architect uses 2D view, so no 3D clicking
                if (playerRole !== 'architect') {
                        // Only request pointer lock for player and monster, not architect
                        if (!isPointerLocked && (playerRole === 'player' || playerRole === 'monster')) {
                            renderer.domElement.requestPointerLock();
                        }
                    }
                });
                
                // Handle right-click for 3D view only (architect uses 2D)
                renderer.domElement.addEventListener('contextmenu', (event) => {
                    if (playerRole !== 'architect') {
                        // Only handle 3D right-click for non-architects
                    }
                });
            }

            document.addEventListener('keydown', (e) => {
                if (e.key === 'Escape' && isPointerLocked) {
                    document.exitPointerLock();
                }
            });

            keydownListener = (e) => {
                switch(e.key.toLowerCase()) {
                    case 'w':
                    case 'arrowup':
                        keys.forward = true;
                        break;
                    case 's':
                    case 'arrowdown':
                        keys.backward = true;
                        break;
                    case 'a':
                    case 'arrowleft':
                        keys.left = true;
                        break;
                    case 'd':
                    case 'arrowright':
                        keys.right = true;
                        break;
                }
            };

            keyupListener = (e) => {
                switch(e.key.toLowerCase()) {
                    case 'w':
                    case 'arrowup':
                        keys.forward = false;
                        break;
                    case 's':
                    case 'arrowdown':
                        keys.backward = false;
                        break;
                    case 'a':
                    case 'arrowleft':
                        keys.left = false;
                        break;
                    case 'd':
                    case 'arrowright':
                        keys.right = false;
                        break;
                }
            };

            document.addEventListener('keydown', keydownListener);
            document.addEventListener('keyup', keyupListener);

            controls.update = function updateControls() {
                if (!controls.enabled || !camera || !maze) return;

                const moveSpeed = playerRole === 'monster' ? 0.1 : 0.15;
                const turnSpeed = 0.06;
                const newPosition = camera.position.clone();
                const oldPosition = camera.position.clone();

                // First-person movement for player and monster (WITH collision detection)
                let moveVector = new THREE.Vector3(0, 0, 0);
                    if (keys.forward) {
                        moveVector.x -= Math.sin(camera.rotation.y) * moveSpeed;
                        moveVector.z -= Math.cos(camera.rotation.y) * moveSpeed;
                    }
                    if (keys.backward) {
                        moveVector.x += Math.sin(camera.rotation.y) * moveSpeed;
                        moveVector.z += Math.cos(camera.rotation.y) * moveSpeed;
                    }
                    if (keys.left) {
                        camera.rotation.y += turnSpeed;
                    }
                    if (keys.right) {
                        camera.rotation.y -= turnSpeed;
                    }
                    
                    // Apply movement and check collision for non-architects
                    if (moveVector.length() > 0) {
                        // Try to move to new position
                        const targetPos = {
                            x: newPosition.x + moveVector.x,
                            z: newPosition.z + moveVector.z
                        };
                        
                        // Check collision at target position
                        const collision = checkCollision(targetPos);
                        
                        // If there's a collision, try to slide along walls
                        if (collision.x || collision.z) {
                            if (!collision.x) newPosition.x = targetPos.x;
                            if (!collision.z) newPosition.z = targetPos.z;
                            
                            // Apply sliding motion if available
                            if (collision.slideX || collision.slideZ) {
                                newPosition.x += collision.slideX * 0.5;
                                newPosition.z += collision.slideZ * 0.5;
                            }
                        } else {
                            // No collision, move freely
                            newPosition.x = targetPos.x;
                            newPosition.z = targetPos.z;
                        }
                    }

                // Update position and send update if changed
                camera.position.copy(newPosition);
                
                if (camera.position.x !== oldPosition.x || camera.position.z !== oldPosition.z) {
                    if (multiplayerManager && multiplayerManager.connected) {
                        multiplayerManager.sendPosition(camera.position, camera.rotation);
                    }
                }
            };

            return controls;
        }

        function showWinScreen() {
            document.getElementById('winScreen').style.display = 'block';
            // Reset game state
            gameStarted = false;
        }

        // Show the multiplayer menu
        function showMultiplayerMenu() {
            console.log('Showing multiplayer menu');
            if (gameStarted) {
                console.log('Game in progress, cleaning up first');
                cleanupRenderer();
                cleanupMultiplayer();
            }
            
            gameStarted = false;
            gameMode = 'single'; // Reset game mode
            hideAllMenus();
            document.getElementById('multiplayerMenu').style.display = 'block';
            document.getElementById('createRoomButton').style.display = 'block';
            document.getElementById('joinRoomButton').style.display = 'block';
        }

        // Show join room input
        function showJoinRoom() {
            document.getElementById('createRoomButton').style.display = 'none';
            document.getElementById('joinRoomButton').style.display = 'none';
            document.getElementById('roomCodeInput').style.display = 'block';
            document.getElementById('roomCodeInput').value = '';
        }

        function joinRoom() {
            const roomCode = document.getElementById('roomCodeInput').value.trim().toUpperCase();
            if (!roomCode) {
                alert('Please enter a room code');
                return;
            }

            showLoadingScreen('Joining Room...');
            console.log('Attempting to join room:', roomCode);
            
            // Initialize multiplayer manager
            multiplayerManager = new MultiplayerManager();
            
            // Set up callbacks
            multiplayerManager.onConnectionSuccess = () => {
                console.log('Successfully connected to server, attempting to join room:', roomCode);
                multiplayerManager.joinRoom(roomCode);
            };

            multiplayerManager.onMazeDataReceived = (mazeData) => {
                console.log('🗺️ Maze data received and loaded!', mazeData);
                maze = mazeData;
                maze.wallPositions = maze.wallPositions || [];
                
                // Now that we have maze data, we can safely initialize the scene
                console.log('🎬 Initializing scene after maze data received');
                init(false);
            };

            multiplayerManager.onRoomJoined = () => {
                console.log('Successfully joined room:', roomCode);
                hideLoadingScreen();
                
                // Hide all menus
                hideAllMenus();
                
                // Show simple waiting message
                const waitingDiv = document.createElement('div');
                waitingDiv.id = 'simple-waiting';
                waitingDiv.style.cssText = `
                    position: fixed;
                    top: 50%;
                    left: 50%;
                    transform: translate(-50%, -50%);
                    color: white;
                    font-size: 24px;
                    text-align: center;
                    z-index: 1000;
                `;
                waitingDiv.innerHTML = 'Waiting for players...';
                document.body.appendChild(waitingDiv);
                
                // Set the game mode but don't start yet
                gameMode = 'multiplayer';
                playerRole = 'waiting';
                allPlayersJoined = false;
                gameStarted = false;
                
                console.log('🏠 Room joined, showing simple waiting message...');
            };

            // Add the same event handlers as createRoom
            multiplayerManager.onPlayerJoined = (playerId, role) => {
                console.log('Player joined:', playerId, 'as', role);
                
                // For joinRoom, just wait silently - no UI updates needed
                const currentPlayers = Object.keys(otherPlayers).length + 2;
                const playersNeeded = requiredPlayers - currentPlayers;
                
                if (playersNeeded > 0) {
                    console.log(`Waiting for ${playersNeeded} more player${playersNeeded > 1 ? 's' : ''} to join...`);
                } else {
                    console.log('All players joined! Waiting for role assignment...');
                }
            };

            multiplayerManager.onRoleAssigned = (role, message) => {
                console.log('🎭 Role assigned:', role, message);
                playerRole = role;
                
                // Remove simple waiting message if it exists
                const simpleWaiting = document.getElementById('simple-waiting');
                if (simpleWaiting) {
                    simpleWaiting.remove();
                }
                
                // Hide role assignment screen and show your role screen
                document.getElementById('roleAssignmentScreen').style.display = 'none';
                document.getElementById('yourRoleScreen').style.display = 'block';
                
                // Update role information
                document.getElementById('assignedRole').textContent = role.toUpperCase();
                
                // Set role descriptions
                let description = '';
                switch(role) {
                    case 'player':
                        description = 'Navigate through the maze to find the green exit. Use WASD to move and mouse to look around. Avoid the monster!';
                        break;
                    case 'guide':
                        description = 'Help the player reach the exit using your top-down 2D view. You can see the entire maze layout and all player positions.';
                        break;
                    case 'architect':
                        description = 'Architect: Click to add/remove walls.';
                        break;
                    case 'monster':
                        description = 'Hunt the player in first-person view! Use WASD to move and mouse to look around. Catch the player before they escape!';
                        break;
                    default:
                        description = message || 'Unknown role';
                }
                document.getElementById('roleDescription').textContent = description;
                
                // DON'T initialize the scene yet - wait for onGameReady
                console.log('🎭 Role assigned, waiting for game ready signal...');
            };

            multiplayerManager.onGameReady = () => {
                console.log('🎮 onGameReady called - Current role:', playerRole, 'Maze exists:', !!maze);
                allPlayersJoined = true;
                gameStarted = true;
                
                // Hide all UI screens
                hideAllMenus();
                
                // Wait for maze data if not available
                if (!maze) {
                    console.log('🎮 No maze data yet, waiting...');
                    setTimeout(() => {
                        if (maze) {
                            console.log('🎮 Maze data now available, starting game');
                            multiplayerManager.onGameReady();
                        } else {
                            console.error('🎮 Still no maze data after waiting');
                        }
                    }, 100);
                    return;
                }
                
                // Add a 3-second countdown before starting
                setTimeout(() => {
                    // Force game start based on role
                    console.log('🎮 Starting game for role:', playerRole);
                    if (playerRole === 'guide') {
                        console.log('🎮 Starting GUIDE view (2D only)');
                        initGuideView(maze);
                    } else if (playerRole === 'architect') {
                        console.log('🔥🔥🔥 Starting ARCHITECT view (2D only)! 🔥🔥🔥');
                        // Architect gets 2D view with wall editing
                        initGuideView(maze);
                    } else if (playerRole === 'player' || playerRole === 'monster') {
                        console.log('🎮 Starting 3D view for:', playerRole);
                        // Always call init(true) to ensure fresh initialization
                        init(true);
                    } else {
                        console.log('🎮 Unknown role:', playerRole);
                    }
                }, 3000);
            };

            multiplayerManager.onError = (error) => {
                console.error('Error joining room:', error);
                hideLoadingScreen();
                alert('Error joining room: ' + error);
                showMultiplayerMenu();
            };

            // Start connection
            multiplayerManager.connect();
        }

        function showLoadingScreen(message = 'Loading Game...') {
            document.getElementById('loadingMessage').textContent = message;
            document.getElementById('loadingScreen').style.display = 'block';
        }

        function hideLoadingScreen() {
            document.getElementById('loadingScreen').style.display = 'none';
        }

        function setupMultiplayer() {
            console.log('Setting up multiplayer components with role:', playerRole);
            
            // Create other player representation based on role
            if (playerRole === 'player' || playerRole === 'monster') {
                let otherPlayerMesh;
                if (playerRole === 'monster') {
                    // Create player representation for monster's view
                    const playerGeometry = new THREE.Group();
                    
                    // Main body - taller and brighter cylinder
                    const body = new THREE.Mesh(
                        new THREE.CylinderGeometry(0.4, 0.4, 2.5, 8),
                        new THREE.MeshPhongMaterial({ 
                            color: 0x00ff00,
                            emissive: 0x00ff00,
                            emissiveIntensity: 0.5
                        })
                    );
                    playerGeometry.add(body);
                    
                    // Add glowing ring at the top
                    const ring = new THREE.Mesh(
                        new THREE.TorusGeometry(0.5, 0.1, 8, 16),
                        new THREE.MeshPhongMaterial({
                            color: 0xffff00,
                            emissive: 0xffff00,
                            emissiveIntensity: 0.7
                        })
                    );
                    ring.position.y = 1.5;
                    ring.rotation.x = Math.PI / 2;
                    playerGeometry.add(ring);
                    
                    otherPlayerMesh = playerGeometry;
                } else {
                    // Monster representation for player's view
                    otherPlayerMesh = new THREE.Mesh(
                        new THREE.CylinderGeometry(0.3, 0.3, 2, 8),
                        new THREE.MeshPhongMaterial({ 
                            color: 0xff0000,
                            emissive: 0xff0000,
                            emissiveIntensity: 0.5
                        })
                    );
                }
                
                otherPlayers[multiplayerManager.playerId] = otherPlayerMesh;
                otherPlayers[multiplayerManager.playerId].position.set(0, 1, 0);
                otherPlayers[multiplayerManager.playerId].visible = true;
                scene.add(otherPlayers[multiplayerManager.playerId]);
            }

            // Set up multiplayer event handlers
            multiplayerManager.onPlayerJoined = (playerId, role) => {
                console.log('Player joined:', playerId, 'as', role);
                if (!otherPlayers[playerId] && (playerRole === 'player' || playerRole === 'monster')) {
                    console.log('Creating representation for player:', playerId, 'with role:', role);
                    
                    // Create a more visible representation for players
                    let playerMesh;
                    if (role === 'monster') {
                        // Monster representation
                        playerMesh = new THREE.Mesh(
                            new THREE.CylinderGeometry(0.3, 0.3, 2, 8),
                            new THREE.MeshPhongMaterial({ 
                                color: 0xff0000,
                                emissive: 0xff0000,
                                emissiveIntensity: 0.5
                            })
                        );
                    } else {
                        // Player representation - more visible for monster
                        const playerGeometry = new THREE.Group();
                        
                        // Main body - taller and brighter cylinder
                        const body = new THREE.Mesh(
                            new THREE.CylinderGeometry(0.4, 0.4, 2.5, 8),
                            new THREE.MeshPhongMaterial({ 
                                color: 0x00ff00,
                                emissive: 0x00ff00,
                                emissiveIntensity: 0.5
                            })
                        );
                        playerGeometry.add(body);
                        
                        // Add glowing ring at the top
                        const ring = new THREE.Mesh(
                            new THREE.TorusGeometry(0.5, 0.1, 8, 16),
                            new THREE.MeshPhongMaterial({
                                color: 0xffff00,
                                emissive: 0xffff00,
                                emissiveIntensity: 0.7
                            })
                        );
                        ring.position.y = 1.5;
                        ring.rotation.x = Math.PI / 2;
                        playerGeometry.add(ring);
                        
                        playerMesh = playerGeometry;
                    }
                    
                    otherPlayers[playerId] = playerMesh;
                    otherPlayers[playerId].position.set(0, 1, 0);
                    otherPlayers[playerId].visible = true;
                    scene.add(otherPlayers[playerId]);
                    
                    console.log('Added player representation to scene:', playerId);
                }
            };

            multiplayerManager.onPlayerLeft = (playerId) => {
                console.log('Player left:', playerId);
                if (otherPlayers[playerId]) {
                    scene.remove(otherPlayers[playerId]);
                    delete otherPlayers[playerId];
                }
            };

            multiplayerManager.onPlayerMove = (playerId, position, rotation) => {
                console.log('Received player move:', playerId, position, rotation);
                if (otherPlayers[playerId]) {
                    otherPlayers[playerId].visible = true;
                    otherPlayers[playerId].position.set(position.x, position.y, position.z);
                    otherPlayers[playerId].rotation.set(rotation.x, rotation.y, rotation.z);
                }
            };
        }

        function copyRoomCode(element) {
            const code = element.textContent;
            navigator.clipboard.writeText(code).then(() => {
                element.classList.add('copied');
                setTimeout(() => element.classList.remove('copied'), 500);
            });
        }

        function initGuideView(mazeData) {
            try {
                if (!mazeData) throw new Error('No maze data provided');
                console.log('🗺️ Initializing guide view with maze data:', mazeData);

                // Update role title based on actual player role
                const roleTitleElement = document.getElementById('roleTitle');
                if (roleTitleElement) {
                    if (playerRole === 'architect') {
                        roleTitleElement.textContent = 'Architect View';
                    } else {
                        roleTitleElement.textContent = 'Guide View';
                    }
                }

                // Clean up
                if (renderer?.domElement?.parentNode) {
                    renderer.domElement.parentNode.removeChild(renderer.domElement);
                    renderer.dispose();
                }

                // Hide other screens
                ['startScreen', 'multiplayerMenu', 'winScreen', 'loadingScreen'].forEach(id => {
                    const element = document.getElementById(id);
                    if (element) element.style.display = 'none';
                });

                // Setup guide container
                const guideView = document.getElementById('guideView');
                guideView.style.cssText = `
                    position: fixed;
                    top: 0;
                    left: 0;
                    width: 100vw;
                    height: 100vh;
                    display: flex;
                    justify-content: center;
                    align-items: center;
                    background-color: #000000;
                `;
                guideView.style.display = 'block';

                // Setup canvas
                guideCanvas = document.getElementById('guideCanvas');
                guideCtx = guideCanvas.getContext('2d', { alpha: false });

                // Calculate optimal size
                const margin = 80;
                const maxWidth = window.innerWidth - margin * 2;
                const maxHeight = window.innerHeight - margin * 2;
                
                // Calculate cell size to maintain aspect ratio
                const mazeWidth = mazeData.maze[0].length;
                const mazeHeight = mazeData.maze.length;
                const cellSizeX = Math.floor(maxWidth / mazeWidth);
                const cellSizeY = Math.floor(maxHeight / mazeHeight);
                const cellSize = Math.min(cellSizeX, cellSizeY);

                // Set canvas size
                guideCanvas.width = mazeWidth * cellSize + margin * 2;
                guideCanvas.height = mazeHeight * cellSize + margin * 2;

                // Store settings globally
                window.guideViewConfig = {
                    cellSize,
                    margin,
                    mazeWidth,
                    mazeHeight,
                    worldCellSize: mazeData.cellSize
                };

                // Initial draw
                drawGuideView(mazeData, null, null);
                
                // Add architect-specific functionality
                if (playerRole === 'architect') {
                    setupArchitectControls();
                }
                
                // Start game timer if multiplayer
                if (gameMode === 'multiplayer') {
                    startGameTimer();
                }
                
                gameStarted = true;

            } catch (error) {
                console.error('Guide view error:', error);
                const msg = document.createElement('div');
                msg.style.cssText = 'position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);background:rgba(0,0,0,0.8);color:red;padding:20px;border-radius:10px;text-align:center;';
                msg.innerHTML = `Error: ${error.message}<br><button onclick="location.reload()" style="margin-top:15px;padding:10px;background:white;color:red;border:none;border-radius:5px;cursor:pointer;">Reload</button>`;
                document.body.appendChild(msg);
            }
        }

        function smoothPosition(current, last) {
            if (!last) return current;
            return {
                x: last.x + (current.x - last.x) * positionSmoothingFactor,
                y: last.y + (current.y - last.y) * positionSmoothingFactor,
                z: last.z + (current.z - last.z) * positionSmoothingFactor,
                rotation: {
                    x: last.rotation?.x + (current.rotation?.x - last.rotation?.x) * rotationSmoothingFactor || current.rotation?.x,
                    y: last.rotation?.y + (current.rotation?.y - last.rotation?.y) * rotationSmoothingFactor || current.rotation?.y,
                    z: last.rotation?.z + (current.rotation?.z - last.rotation?.z) * rotationSmoothingFactor || current.rotation?.z
                }
            };
        }

        function drawGuideView(mazeData, playerPos, monsterPos) {
            if (!mazeData || !mazeData.maze) return;
            
            const config = window.guideViewConfig;
            if (!config) return;

            // Apply position smoothing
            if (playerPos) {
                if (!lastPlayerPos) {
                    lastPlayerPos = { ...playerPos };
                } else {
                    playerPos = smoothPosition(playerPos, lastPlayerPos);
                    lastPlayerPos = { ...playerPos };
                }
            }
            
            if (monsterPos) {
                if (!lastMonsterPos) {
                    lastMonsterPos = { ...monsterPos };
                } else {
                    monsterPos = smoothPosition(monsterPos, lastMonsterPos);
                    lastMonsterPos = { ...monsterPos };
                }
            }

            const { cellSize, margin, worldCellSize } = config;

            // Create an off-screen canvas for double buffering
            const offscreenCanvas = document.createElement('canvas');
            offscreenCanvas.width = guideCanvas.width;
            offscreenCanvas.height = guideCanvas.height;
            const offscreenCtx = offscreenCanvas.getContext('2d', { alpha: false });
            
            // Enable image smoothing for smoother rendering
            offscreenCtx.imageSmoothing = true;
            offscreenCtx.imageSmoothingQuality = 'high';

            // Clear offscreen canvas with a solid color
            offscreenCtx.fillStyle = '#000000';
            offscreenCtx.fillRect(0, 0, offscreenCanvas.width, offscreenCanvas.height);

            // Draw floor with anti-aliasing
            offscreenCtx.fillStyle = '#e0e0e0';
            offscreenCtx.fillRect(
                Math.round(margin),
                Math.round(margin),
                Math.round(mazeData.maze[0].length * cellSize),
                Math.round(mazeData.maze.length * cellSize)
            );

            // Draw walls with darker color - flip the z-axis by using (mazeData.maze.length - 1 - z)
            for (let z = 0; z < mazeData.maze.length; z++) {
                for (let x = 0; x < mazeData.maze[z].length; x++) {
                    if (mazeData.maze[z][x] === 1) {
                        offscreenCtx.fillStyle = '#1a1a1a'; // Very dark gray
                        offscreenCtx.fillRect(
                            (mazeData.maze[z].length - 1 - x) * cellSize + margin,
                            (mazeData.maze.length - 1 - z) * cellSize + margin,
                            cellSize,
                            cellSize
                        );
                    }
                }
            }

            // Draw exit - flip both x and z coordinates
            const exitX = Math.floor((mazeData.maze[0].length - 1 - (mazeData.endPosition.x / worldCellSize))) * cellSize + margin;
            const exitZ = Math.floor(mazeData.maze.length - 1 - (mazeData.endPosition.z / worldCellSize)) * cellSize + margin;
            
            // Draw exit marker with glow effect
            offscreenCtx.shadowColor = '#4CAF50';
            offscreenCtx.shadowBlur = 15;
            offscreenCtx.fillStyle = '#4CAF50';
            offscreenCtx.fillRect(exitX - cellSize/4, exitZ - cellSize/4, cellSize/2, cellSize/2);

            // Draw player position if available
            if (playerPos && typeof playerPos.x === 'number' && typeof playerPos.z === 'number') {
                const squareSize = cellSize * 0.6;
                
                // Calculate canvas coordinates for player
                const canvasX = ((mazeData.maze[0].length - 1) - (playerPos.x / worldCellSize)) * cellSize + margin + cellSize/2;
                const canvasZ = ((mazeData.maze.length - 1) - (playerPos.z / worldCellSize)) * cellSize + margin + cellSize/2;
                
                // Draw player marker
                offscreenCtx.shadowColor = '#2196F3';
                offscreenCtx.shadowBlur = 10;
                offscreenCtx.strokeStyle = '#2196F3';
                offscreenCtx.lineWidth = 3;
                
                // Draw player square
                offscreenCtx.strokeRect(
                    canvasX - squareSize/2,
                    canvasZ - squareSize/2,
                    squareSize,
                    squareSize
                );

                // Direction indicator removed - was causing flickering
            }

            // Draw monster position if available
            if (monsterPos && typeof monsterPos.x === 'number' && typeof monsterPos.z === 'number') {
                const diamondSize = cellSize * 0.6;
                
                // Calculate canvas coordinates for monster
                const canvasX = ((mazeData.maze[0].length - 1) - (monsterPos.x / worldCellSize)) * cellSize + margin + cellSize/2;
                const canvasZ = ((mazeData.maze.length - 1) - (monsterPos.z / worldCellSize)) * cellSize + margin + cellSize/2;
                
                // Draw monster marker
                offscreenCtx.shadowColor = '#ff0000';
                offscreenCtx.shadowBlur = 10;
                offscreenCtx.strokeStyle = '#ff0000';
                offscreenCtx.lineWidth = 3;
                
                // Draw diamond shape
                offscreenCtx.beginPath();
                offscreenCtx.moveTo(canvasX, canvasZ - diamondSize/2);
                offscreenCtx.lineTo(canvasX + diamondSize/2, canvasZ);
                offscreenCtx.lineTo(canvasX, canvasZ + diamondSize/2);
                offscreenCtx.lineTo(canvasX - diamondSize/2, canvasZ);
                offscreenCtx.closePath();
                offscreenCtx.stroke();
            }

            // Reset shadow
            offscreenCtx.shadowBlur = 0;

            // Copy the offscreen canvas to the visible canvas
            guideCtx.clearRect(0, 0, guideCanvas.width, guideCanvas.height);
            guideCtx.drawImage(offscreenCanvas, 0, 0);
        }

        function setupArchitectControls() {
            // Create cooldown indicator
            const cooldownIndicator = document.createElement('div');
            cooldownIndicator.id = 'architectCooldown';
            cooldownIndicator.style.cssText = `
                position: fixed;
                top: 20px;
                left: 50%;
                transform: translateX(-50%);
                background: rgba(255, 69, 0, 0.9);
                color: white;
                padding: 10px 20px;
                border-radius: 20px;
                font-size: 18px;
                font-weight: bold;
                z-index: 10000;
                display: none;
                text-shadow: 0 0 5px rgba(0, 0, 0, 0.5);
                box-shadow: 0 4px 15px rgba(255, 69, 0, 0.4);
            `;
            document.body.appendChild(cooldownIndicator);
            
            // Create instructions (positioned to not cover maze)
            const instructions = document.createElement('div');
            instructions.id = 'architectInstructions';
            instructions.style.cssText = `
                position: fixed;
                top: 70px;
                left: 20px;
                background: rgba(255, 69, 0, 0.95);
                color: white;
                padding: 15px 20px;
                border-radius: 10px;
                font-size: 16px;
                z-index: 10000;
                border: 3px solid #FFD700;
                box-shadow: 0 0 25px rgba(255, 215, 0, 0.5);
                max-width: 300px;
                animation: architectPulse 2s infinite;
                font-weight: bold;
                text-shadow: 0 0 5px rgba(0, 0, 0, 0.5);
            `;
            instructions.innerHTML = `
                <strong>🏗️ ARCHITECT MODE ACTIVE</strong><br>
                <span style="font-size: 14px; color: #FFD700;">
                📍 CLICK ON THE 2D MAZE VIEW:<br>
                🖱️ Left Click: Add Wall<br>
                🖱️ Right Click: Remove Wall<br>
                ⏱️ 5-second cooldown between changes
                </span>
            `;
            
            // Add pulsing animation
            if (!document.getElementById('architect-pulse-style')) {
                const style = document.createElement('style');
                style.id = 'architect-pulse-style';
                style.textContent = `
                    @keyframes architectPulse {
                        0% { box-shadow: 0 0 25px rgba(255, 215, 0, 0.5); }
                        50% { box-shadow: 0 0 35px rgba(255, 215, 0, 0.8); }
                        100% { box-shadow: 0 0 25px rgba(255, 215, 0, 0.5); }
                    }
                `;
                document.head.appendChild(style);
            }
            
            document.body.appendChild(instructions);
            
            // Add click handlers to guide canvas
            console.log('🏗️ Setting up architect controls for canvas:', guideCanvas);
            guideCanvas.addEventListener('click', handleArchitectClick);
            guideCanvas.addEventListener('contextmenu', handleArchitectRightClick);
            
            // Add visual feedback for architect interactions
            guideCanvas.style.cursor = 'crosshair';
            guideCanvas.style.border = '3px solid #FF4500';
            guideCanvas.style.boxShadow = '0 0 15px rgba(255, 69, 0, 0.5)';
            
            // Add hover effects
            guideCanvas.addEventListener('mouseenter', () => {
                guideCanvas.style.boxShadow = '0 0 25px rgba(255, 69, 0, 0.8)';
            });
            
            guideCanvas.addEventListener('mouseleave', () => {
                guideCanvas.style.boxShadow = '0 0 15px rgba(255, 69, 0, 0.5)';
            });
            
            // Add a blinking reminder
            let reminderCount = 0;
            const reminderInterval = setInterval(() => {
                if (reminderCount < 3) {
                    showArchitectMessage('🏗️ REMINDER: Click on the 2D maze view to modify walls!', true);
                    reminderCount++;
                } else {
                    clearInterval(reminderInterval);
                }
            }, 10000); // Every 10 seconds, 3 times
        }

        function handleArchitectClick(event) {
            if (playerRole !== 'architect') return;
            
            console.log('🏗️ Architect left click detected at:', event.clientX, event.clientY);
            event.preventDefault();
            const rect = guideCanvas.getBoundingClientRect();
            const canvasX = event.clientX - rect.left;
            const canvasY = event.clientY - rect.top;
            
            performArchitectAction(canvasX, canvasY, 'add');
        }

        function handleArchitectRightClick(event) {
            if (playerRole !== 'architect') return;
            
            console.log('🏗️ Architect right click detected at:', event.clientX, event.clientY);
            event.preventDefault();
            event.stopPropagation();
            const rect = guideCanvas.getBoundingClientRect();
            const canvasX = event.clientX - rect.left;
            const canvasY = event.clientY - rect.top;
            
            performArchitectAction(canvasX, canvasY, 'remove');
            return false; // Extra prevention of context menu
        }

        function performArchitectAction(canvasX, canvasY, action) {
            console.log('🏗️ performArchitectAction called:', {canvasX, canvasY, action, playerRole});
            
            const config = window.guideViewConfig;
            if (!config || !maze) {
                console.log('🏗️ Missing config or maze:', {config, maze});
                return;
            }
            
            const { cellSize, margin } = config;
            console.log('🏗️ Config values:', {cellSize, margin});
            
            // Convert canvas coordinates to flipped grid coordinates (matching drawGuideView)
            const canvasGridX = Math.floor((canvasX - margin) / cellSize);
            const canvasGridZ = Math.floor((canvasY - margin) / cellSize);
            
            // Unflip the coordinates to get actual maze grid coordinates
            // In drawGuideView: canvas_x = (maze.width - 1 - grid_x), so grid_x = maze.width - 1 - canvas_x
            const gridX = maze.maze[0].length - 1 - canvasGridX;
            const gridZ = maze.maze.length - 1 - canvasGridZ;
            
            // Convert grid coordinates to world coordinates
            const worldX = gridX * maze.cellSize;
            const worldZ = gridZ * maze.cellSize;
            
            console.log('🏗️ Coordinate conversion:', {
                canvas: {canvasX, canvasY},
                canvasGrid: {canvasGridX, canvasGridZ},
                actualGrid: {gridX, gridZ},
                world: {worldX, worldZ},
                cellSize: maze.cellSize,
                mazeSize: {width: maze.maze[0].length, height: maze.maze.length}
            });
            
            // Bounds check on actual grid coordinates
            if (gridX < 0 || gridX >= maze.maze[0].length || gridZ < 0 || gridZ >= maze.maze.length) {
                console.log('🏗️ Click outside maze bounds');
                return;
            }
            
            // Check current maze state at this position
            const currentValue = maze.maze[gridZ][gridX];
            console.log(`🏗️ Current maze value at grid(${gridX}, ${gridZ}): ${currentValue} (${currentValue === 1 ? 'wall' : 'empty'})`);
            
            // Send wall change request to server
            if (multiplayerManager && multiplayerManager.socket && multiplayerManager.socket.readyState === WebSocket.OPEN) {
                const message = {
                    type: 'architect_wall_change',
                    x: worldX,
                    z: worldZ,
                    action: action
                };
                
                console.log('🏗️ Sending message to server:', message);
                multiplayerManager.socket.send(JSON.stringify(message));
                
                console.log(`🏗️ Sent ${action} wall request at world (${worldX}, ${worldZ}) grid (${gridX}, ${gridZ})`);
            } else {
                console.log('🏗️ Cannot send message - connection not ready:', {
                    multiplayerManager: !!multiplayerManager,
                    socket: !!multiplayerManager?.socket,
                    readyState: multiplayerManager?.socket?.readyState
                });
            }
        }

        function showArchitectCooldown(seconds) {
            console.log('🔥 showArchitectCooldown called with seconds:', seconds);
            const cooldownIndicator = document.getElementById('architectCooldown');
            if (cooldownIndicator) {
                cooldownIndicator.textContent = `🔥 Cooldown: ${seconds}s`;
                cooldownIndicator.style.display = 'block';
                
                const countdownTimer = setInterval(() => {
                    seconds--;
                    if (seconds <= 0) {
                        cooldownIndicator.style.display = 'none';
                        clearInterval(countdownTimer);
                    } else {
                        cooldownIndicator.textContent = `🔥 Cooldown: ${seconds}s`;
                    }
                }, 1000);
            }
        }

        // In-game message display function
        function showArchitectMessage(message, isSuccess = false) {
            console.log('📢 Architect message:', message, 'isSuccess:', isSuccess);
            
            // Remove any existing messages
            const existingMessages = document.querySelectorAll('.architect-message');
            existingMessages.forEach(msg => msg.remove());
            
            // Create new message
            const messageDiv = document.createElement('div');
            messageDiv.className = 'architect-message';
            
            const backgroundColor = isSuccess ? 'rgba(76, 175, 80, 0.95)' : 'rgba(255, 69, 0, 0.95)';
            const shadowColor = isSuccess ? 'rgba(76, 175, 80, 0.6)' : 'rgba(255, 69, 0, 0.6)';
            
            messageDiv.style.cssText = `
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: ${backgroundColor};
                color: white;
                padding: 15px 25px;
                border-radius: 10px;
                font-size: 16px;
                font-weight: bold;
                z-index: 10001;
                text-align: center;
                box-shadow: 0 4px 15px ${shadowColor};
                border: 2px solid rgba(255, 255, 255, 0.3);
                animation: fadeInOut 2s ease-in-out;
            `;
            
            // Add fade animation if not already added
            if (!document.getElementById('architect-message-style')) {
                const style = document.createElement('style');
                style.id = 'architect-message-style';
                style.textContent = `
                    @keyframes fadeInOut {
                        0% { opacity: 0; transform: translate(-50%, -50%) scale(0.8); }
                        20% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
                        80% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
                        100% { opacity: 0; transform: translate(-50%, -50%) scale(0.8); }
                    }
                `;
                document.head.appendChild(style);
            }
            
            const icon = isSuccess ? '✅' : '🚫';
            messageDiv.innerHTML = `
                <strong>${icon} Architect</strong><br>
                ${message}
            `;
            document.body.appendChild(messageDiv);
            
            // Remove after 2 seconds
            setTimeout(() => {
                if (document.body.contains(messageDiv)) {
                    document.body.removeChild(messageDiv);
                }
            }, 2000);
        }
        
        // Backward compatibility function
        function showArchitectError(message) {
            showArchitectMessage(message, false);
        }

        // Expose functions globally so multiplayer.js can access them
        console.log('🔥🔥🔥 ATTACHING FUNCTIONS TO WINDOW OBJECT! 🔥🔥🔥');
        window.handleWallChanged = handleWallChanged;
        window.showArchitectCooldown = showArchitectCooldown;
        window.showArchitectError = showArchitectError;
        window.showArchitectMessage = showArchitectMessage;
        console.log('🔥🔥🔥 FUNCTIONS ATTACHED! handleWallChanged type:', typeof window.handleWallChanged, '🔥🔥🔥');
        
        // Add a simple test function to check if Three.js is working
        window.testAddCube = function() {
            console.log('🧪 Testing cube addition to scene...');
            if (scene) {
                const testCube = new THREE.Mesh(
                    new THREE.BoxGeometry(5, 5, 5),
                    new THREE.MeshBasicMaterial({ color: 0x00ffff })
                );
                testCube.position.set(0, 5, -10); // In front of player
                scene.add(testCube);
                console.log('🧪 Added cyan test cube to scene at (0, 5, -10)');
            } else {
                console.error('🧪 Scene not available for testing');
            }
        };
        
        // Add a debug function to check if the multiplayer system is working
        window.forceCallHandleWallChanged = function() {
            console.log('🔥 FORCING CALL TO handleWallChanged with test data...');
            const testData = {
                gridX: 5,
                gridZ: 5,
                action: 'add',
                x: 5 * 3, // assuming cellSize is 3
                z: 5 * 3
            };
            
            console.log('🔥 Current game state:');
            console.log('- window.handleWallChanged exists:', typeof window.handleWallChanged);
            console.log('- handleWallChanged call count:', handleWallChangedCallCount);
            console.log('- scene exists:', !!scene);
            console.log('- camera exists:', !!camera);
            console.log('- renderer exists:', !!renderer);
            console.log('- mazeGroup exists:', !!mazeGroup);
            console.log('- maze exists:', !!maze);
            console.log('- playerRole:', playerRole);
            console.log('- gameStarted:', gameStarted);
            console.log('- multiplayerManager connected:', multiplayerManager?.connected);
            
            if (window.handleWallChanged) {
                try {
                    window.handleWallChanged(testData);
                    console.log('🔥 handleWallChanged call completed successfully!');
                } catch (error) {
                    console.error('🔥 Error calling handleWallChanged:', error);
                }
            } else {
                console.error('🔥 handleWallChanged not available!');
            }
        };
        
        // Quick test to see if basic scene manipulation works
        window.quickSceneTest = function() {
            console.log('🧪 Quick scene test...');
            if (scene) {
                const testCube = new THREE.Mesh(
                    new THREE.BoxGeometry(2, 2, 2),
                    new THREE.MeshBasicMaterial({ color: 0x00ff00 })
                );
                testCube.position.set(0, 2, -5);
                scene.add(testCube);
                console.log('🧪 Green test cube added to scene!');
                return true;
            } else {
                console.error('🧪 No scene available!');
                return false;
            }
        };
        
        // Check if functions are properly attached to window
        window.checkWindowFunctions = function() {
            console.log('🔍 Checking window functions...');
            console.log('- window.handleWallChanged:', typeof window.handleWallChanged, window.handleWallChanged);
            console.log('- window.testAddCube:', typeof window.testAddCube);
            console.log('- window.forceCallHandleWallChanged:', typeof window.forceCallHandleWallChanged);
            console.log('- window.quickSceneTest:', typeof window.quickSceneTest);
            console.log('- window.debugArchitect:', typeof window.debugArchitect);
            console.log('- multiplayerManager exists:', !!multiplayerManager);
            console.log('- multiplayerManager connected:', multiplayerManager?.connected);
            console.log('- multiplayerManager socket state:', multiplayerManager?.socket?.readyState);
            console.log('- Current playerRole:', playerRole);
            console.log('- gameStarted:', gameStarted);
            
            // Try to list all window functions related to our game
            const gameFunctions = Object.keys(window).filter(key => 
                key.includes('handle') || key.includes('test') || key.includes('debug') || key.includes('force')
            );
            console.log('- All game-related window functions:', gameFunctions);
        };
        
        // Debug function for architect
        window.debugArchitect = function() {
            console.log('🏗️ ARCHITECT DEBUG INFO:');
            console.log('- playerRole:', playerRole);
            console.log('- guideCanvas exists:', !!guideCanvas);
            console.log('- guideCanvas visible:', guideCanvas ? guideCanvas.style.display : 'N/A');
            console.log('- guideViewConfig exists:', !!window.guideViewConfig);
            console.log('- maze exists:', !!maze);
            console.log('- multiplayerManager connected:', multiplayerManager?.connected);
            console.log('- Socket state:', multiplayerManager?.socket?.readyState);
            console.log('- scene exists:', !!scene);
            console.log('- camera exists:', !!camera);
            console.log('- renderer exists:', !!renderer);
            console.log('- mazeGroup exists:', !!mazeGroup);
            console.log('- mazeGroup children count:', mazeGroup?.children?.length);
            console.log('- scene children count:', scene?.children?.length);
            console.log('- renderer canvas in DOM:', !!(renderer?.domElement?.parentNode));
            console.log('- camera position:', camera?.position);
            console.log('- maze cellSize:', maze?.cellSize);
            console.log('- architectWallMaterial exists:', !!architectWallMaterial);
            
            if (playerRole === 'architect') {
                showArchitectMessage('DEBUG: Architect controls are active! Click on the 2D maze view.', true);
                
                // Highlight the guide canvas temporarily
                if (guideCanvas) {
                    const originalBorder = guideCanvas.style.border;
                    guideCanvas.style.border = '5px solid #FF0000';
                    guideCanvas.style.boxShadow = '0 0 20px #FF0000';
                    
                    setTimeout(() => {
                        guideCanvas.style.border = originalBorder;
                        guideCanvas.style.boxShadow = '';
                    }, 3000);
                }
            } else {
                console.log('🏗️ You are not the architect. Current role:', playerRole);
            }
        };
        
        // Test function for architect
        window.testArchitectWall = function(x = 5, z = 5, action = 'add') {
            if (playerRole !== 'architect') {
                console.log('🏗️ You must be the architect to use this function');
                return;
            }
            
            console.log(`🏗️ Testing architect wall: ${action} at grid (${x}, ${z})`);
            
            if (!maze) {
                console.log('🏗️ No maze data available');
                return;
            }
            
            const worldX = x * maze.cellSize;
            const worldZ = z * maze.cellSize;
            
            if (multiplayerManager && multiplayerManager.socket && multiplayerManager.socket.readyState === WebSocket.OPEN) {
                const message = {
                    type: 'architect_wall_change',
                    x: worldX,
                    z: worldZ,
                    action: action
                };
                
                console.log('🏗️ Sending test message:', message);
                multiplayerManager.socket.send(JSON.stringify(message));
                showArchitectMessage(`Testing ${action} wall at (${x}, ${z})`, true);
            } else {
                console.log('🏗️ Connection not ready for testing');
            }
        };

        function handleWallChanged(data) {
            handleWallChangedCallCount++;
            console.log('🔥🔥🔥 WALL CHANGE HANDLER CALLED! 🔥🔥🔥', data);
            console.log('🔥🔥🔥 FUNCTION DEFINITELY EXECUTING! Call #' + handleWallChangedCallCount + ' 🔥🔥🔥');
            
            // Update the page title to show call count (ALL PLAYERS can see this)
            document.title = `Maze Game - Wall Handler Called ${handleWallChangedCallCount} times`;
            
            // Flash the background briefly for ALL PLAYERS to see
            document.body.style.backgroundColor = '#ff0080';
            setTimeout(() => {
                document.body.style.backgroundColor = '#000';
            }, 200);
            
            // Log what role is receiving this
            console.log('🔥 handleWallChanged called for role:', playerRole);
            
            // Basic validation first
            if (!data) {
                console.error('🔥 No data provided to handleWallChanged');
                return;
            }
            
            console.log('🏗️ Current state - playerRole:', playerRole, 'maze exists:', !!maze, 'mazeGroup exists:', !!mazeGroup);
            console.log('🏗️ Scene exists:', !!scene, 'Camera exists:', !!camera, 'Renderer exists:', !!renderer);
            console.log('🏗️ Document title:', document.title, 'Window focus:', document.hasFocus());
            console.log('🏗️ MazeGroup children count:', mazeGroup ? mazeGroup.children.length : 'N/A');
            console.log('🏗️ architectWallMaterial exists:', !!architectWallMaterial);
            
            // Check if basic variables are defined
            if (typeof playerRole === 'undefined') {
                console.error('🔥 playerRole is undefined!');
                return;
            }
            if (typeof maze === 'undefined') {
                console.error('🔥 maze is undefined!');
                return;
            }
            if (typeof mazeGroup === 'undefined') {
                console.error('🔥 mazeGroup is undefined!');
                return;
            }
            
            // Update the local maze data manually since we're not sending the full maze
            if (maze && maze.maze && data.gridX !== undefined && data.gridZ !== undefined) {
                console.log('🏗️ Updating local maze data with individual change');
                const oldValue = maze.maze[data.gridZ][data.gridX];
                maze.maze[data.gridZ][data.gridX] = data.action === 'add' ? 1 : 0;
                console.log(`🏗️ Updated maze[${data.gridZ}][${data.gridX}] from ${oldValue} to ${maze.maze[data.gridZ][data.gridX]}`);
            } else {
                console.log('🏗️ Cannot update wall - maze not available or invalid grid coords');
                console.log('maze:', !!maze, 'maze.maze:', !!(maze && maze.maze), 'gridX:', data.gridX, 'gridZ:', data.gridZ);
                return;
            }
            
            // Minimal feedback for architect
            console.log(`🏗️ Wall ${data.action}ed at grid (${data.gridX}, ${data.gridZ})`);
            
            // Update ALL views that need to reflect the maze changes
            
            // 1. Redraw the guide view if visible (for guide and architect)
            if ((playerRole === 'guide' || playerRole === 'architect') && window.guideViewConfig && guideCanvas && guideCtx) {
                console.log('🏗️ FORCE REDRAWING 2D VIEW for', playerRole);
                console.log('🏗️ Guide canvas dimensions:', guideCanvas.width, 'x', guideCanvas.height);
                
                // IMMEDIATELY redraw with visible changes
                try {
                    // Flash the canvas border to show it's updating
                    guideCanvas.style.border = '5px solid #ff0000';
                    setTimeout(() => {
                        guideCanvas.style.border = '1px solid #333';
                    }, 500);
                    
                    drawGuideView(maze, null, null);
                    console.log('🏗️ 2D VIEW REDRAWN for', playerRole);
                } catch (error) {
                    console.error('🏗️ Error redrawing 2D view:', error);
                }
            } else {
                console.log('🏗️ CANNOT redraw 2D view for', playerRole, ':', {
                    isGuideOrArchitect: (playerRole === 'guide' || playerRole === 'architect'),
                    hasConfig: !!window.guideViewConfig,
                    hasCanvas: !!guideCanvas,
                    hasCtx: !!guideCtx
                });
            }
            
            // 2. For ALL players in 3D mode, update the visual walls
            if (mazeGroup && scene && (playerRole === 'player' || playerRole === 'monster')) {
                console.log('🏗️ FORCE UPDATING 3D WALLS for', playerRole);
                
                // Add a bright indicator cube first
                const indicatorCube = new THREE.Mesh(
                    new THREE.BoxGeometry(2, 8, 2),
                    new THREE.MeshBasicMaterial({ color: 0x00ff00 })
                );
                indicatorCube.position.set(data.gridX * maze.cellSize, 4, data.gridZ * maze.cellSize);
                scene.add(indicatorCube);
                
                // Remove indicator after 2 seconds
                setTimeout(() => {
                    scene.remove(indicatorCube);
                }, 2000);
                
                updateWallVisual(data.gridX, data.gridZ, data.action);
                console.log('🏗️ 3D WALLS UPDATED for', playerRole);
            } else {
                console.log('🏗️ CANNOT update 3D walls for', playerRole, ':', {
                    hasMazeGroup: !!mazeGroup,
                    hasScene: !!scene,
                    is3DRole: (playerRole === 'player' || playerRole === 'monster')
                });
            }
            
            // 3. Update any other views that might be affected (e.g., minimap, architect view)
            if (playerRole === 'architect' && window.architectViewCanvas) {
                console.log('🏗️ Updating architect view');
                // Redraw architect view if it exists
                setTimeout(() => {
                    if (window.drawArchitectView) {
                        drawArchitectView();
                    }
                }, 50);
            }
            
            console.log(`🏗️ Wall ${data.action}ed at grid (${data.gridX}, ${data.gridZ}) - All views updated`);
        }

        function updateWallVisual(gridX, gridZ, action) {
            console.log(`🔥🔥🔥 updateWallVisual CALLED: action=${action}, grid=(${gridX}, ${gridZ}) 🔥🔥🔥`);
            
            // Validate input parameters
            if (typeof gridX === 'undefined' || typeof gridZ === 'undefined' || typeof action === 'undefined') {
                console.error('🔥 Invalid parameters to updateWallVisual:', {gridX, gridZ, action});
                return;
            }
            
            if (!mazeGroup || !maze || !scene) {
                console.error('🏗️ updateWallVisual: missing required objects', {
                    mazeGroup: !!mazeGroup,
                    maze: !!maze,
                    scene: !!scene
                });
                return;
            }
            
            const worldX = gridX * maze.cellSize;
            const worldZ = gridZ * maze.cellSize;
            
            console.log(`🏗️ Wall action at grid(${gridX}, ${gridZ}) -> world(${worldX}, ${worldZ})`);
            
            // Update maze data
            maze.maze[gridZ][gridX] = action === 'add' ? 1 : 0;
            
            if (action === 'add') {
                console.log('🏗️ ADDING wall...');
                
                // Check if wall already exists at this position
                const existingWall = mazeGroup.children.find(child => 
                    child.userData && child.userData.gridX === gridX && child.userData.gridZ === gridZ
                );
                
                if (existingWall) {
                    console.log('🏗️ Wall already exists, skipping');
                    return;
                }
                
                // Create new wall - make it VERY visible for architect
                const wallGeometry = new THREE.BoxGeometry(maze.cellSize, maze.wallHeight, maze.cellSize);
                
                // Create a bright, easily visible material for architect walls
                const wallMaterial = new THREE.MeshBasicMaterial({
                    color: 0xff6600, // Bright orange for architect walls
                    transparent: false
                });
                
                const wall = new THREE.Mesh(wallGeometry, wallMaterial);
                wall.position.set(worldX, maze.wallHeight / 2, worldZ);
                wall.userData = { gridX: gridX, gridZ: gridZ, architectPlaced: true };
                wall.castShadow = true;
                wall.receiveShadow = true;
                
                mazeGroup.add(wall);
                console.log('🏗️ BRIGHT ORANGE WALL ADDED at position:', wall.position);
                
                // Add a glowing indicator above the wall for extra visibility
                const glowGeometry = new THREE.SphereGeometry(0.5, 8, 8);
                const glowMaterial = new THREE.MeshBasicMaterial({
                    color: 0x00ff00,
                    transparent: true,
                    opacity: 0.7
                });
                const glow = new THREE.Mesh(glowGeometry, glowMaterial);
                glow.position.set(worldX, maze.wallHeight + 2, worldZ);
                glow.userData = { isGlow: true, parentWall: wall };
                scene.add(glow);
                console.log('🏗️ GLOWING GREEN SPHERE ADDED above wall');
                
            } else if (action === 'remove') {
                console.log('🏗️ REMOVING wall...');
                
                // Find walls to remove (use fuzzy matching for better precision)
                const wallsToRemove = mazeGroup.children.filter(child => {
                    if (!child.userData) return false;
                    
                    // Check exact grid coordinates first
                    if (child.userData.gridX === gridX && child.userData.gridZ === gridZ) {
                        return true;
                    }
                    
                    // Fallback: check if world position is close (within 0.5 units)
                    const worldX = gridX * maze.cellSize;
                    const worldZ = gridZ * maze.cellSize;
                    const childX = child.position.x;
                    const childZ = child.position.z;
                    
                    if (Math.abs(childX - worldX) < 0.5 && Math.abs(childZ - worldZ) < 0.5) {
                        console.log('🏗️ Found wall by position matching:', childX, childZ, 'vs target:', worldX, worldZ);
                        return true;
                    }
                    
                    return false;
                });
                
                if (wallsToRemove.length > 0) {
                    wallsToRemove.forEach((wall, index) => {
                        console.log(`🏗️ Removing wall ${index + 1}/${wallsToRemove.length} from scene`);
                        mazeGroup.remove(wall);
                        wall.geometry.dispose();
                        wall.material.dispose();
                        
                        // Also remove any glow indicators
                        const glowToRemove = scene.children.find(child =>
                            child.userData && child.userData.isGlow && child.userData.parentWall === wall
                        );
                        if (glowToRemove) {
                            scene.remove(glowToRemove);
                            glowToRemove.geometry.dispose();
                            glowToRemove.material.dispose();
                            console.log('🏗️ Glow indicator REMOVED');
                        }
                    });
                    console.log(`🏗️ Successfully removed ${wallsToRemove.length} wall(s)`);
                } else {
                    // List all available walls for debugging
                    console.log('🏗️ No wall found to remove. Available walls:');
                    mazeGroup.children.forEach((child, index) => {
                        if (child.userData && (child.userData.gridX !== undefined)) {
                            const distance = Math.abs(child.userData.gridX - gridX) + Math.abs(child.userData.gridZ - gridZ);
                            console.log(`  ${index}: grid(${child.userData.gridX}, ${child.userData.gridZ}), distance: ${distance}, position: (${child.position.x}, ${child.position.z})`);
                        }
                    });
                    
                    // Check if there's a wall in the maze data but not in 3D scene
                    if (maze.maze[gridZ] && maze.maze[gridZ][gridX] === 1) {
                        console.log('🏗️ WARNING: Maze data shows wall exists but not found in 3D scene!');
                    }
                }
            }
            
            console.log(`🏗️ Wall ${action} completed. MazeGroup children: ${mazeGroup.children.length}`);
        }

        function startGameTimer() {
            // Create timer display
            const timerDisplay = document.createElement('div');
            timerDisplay.id = 'gameTimer';
            timerDisplay.style.cssText = `
                position: fixed;
                top: 20px;
                right: 20px;
                background: rgba(0, 0, 0, 0.8);
                color: white;
                padding: 10px 20px;
                border-radius: 10px;
                font-size: 18px;
                font-weight: bold;
                z-index: 10000;
                border: 2px solid #4CAF50;
                box-shadow: 0 0 20px rgba(76, 175, 80, 0.3);
            `;
            document.body.appendChild(timerDisplay);
            
            let timeRemaining = gameTimeLimit;
            
            const updateTimer = () => {
                const minutes = Math.floor(timeRemaining / 60000);
                const seconds = Math.floor((timeRemaining % 60000) / 1000);
                timerDisplay.textContent = `⏱️ ${minutes}:${seconds.toString().padStart(2, '0')}`;
                
                // Change color as time runs out
                if (timeRemaining <= 60000) { // Last minute
                    timerDisplay.style.borderColor = '#ff0000';
                    timerDisplay.style.color = '#ff0000';
                    timerDisplay.style.boxShadow = '0 0 20px rgba(255, 0, 0, 0.5)';
                } else if (timeRemaining <= 120000) { // Last 2 minutes
                    timerDisplay.style.borderColor = '#ff9800';
                    timerDisplay.style.color = '#ff9800';
                    timerDisplay.style.boxShadow = '0 0 20px rgba(255, 152, 0, 0.3)';
                }
                
                timeRemaining -= 1000;
                
                if (timeRemaining <= 0) {
                    clearInterval(gameTimer);
                    handleTimeUp();
                }
            };
            
            updateTimer(); // Initial display
            gameTimer = setInterval(updateTimer, 1000);
        }

        function stopGameTimer() {
            if (gameTimer) {
                clearInterval(gameTimer);
                gameTimer = null;
            }
            
            const timerDisplay = document.getElementById('gameTimer');
            if (timerDisplay) {
                timerDisplay.remove();
            }
        }

        function handleTimeUp() {
            if (!gameStarted) return;
            gameStarted = false;
            
            // Stop the timer
            stopGameTimer();
            
            // Create time up screen
            const timeUpScreen = document.createElement('div');
            timeUpScreen.style.cssText = `
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: rgba(255, 152, 0, 0.95);
                color: white;
                padding: 30px;
                border-radius: 15px;
                text-align: center;
                font-size: 24px;
                z-index: 10000;
                box-shadow: 0 0 30px rgba(255, 152, 0, 0.7);
            `;
            
            if (playerRole === 'architect') {
                timeUpScreen.innerHTML = `
                    <h2>⏰ Time's Up! Architect Wins! 🏗️</h2>
                    <p>You successfully wasted enough time!</p>
                `;
            } else {
                timeUpScreen.innerHTML = `
                    <h2>⏰ Time's Up! 😔</h2>
                    <p>The architect has won by running out the clock!</p>
                `;
            }
            
            document.body.appendChild(timeUpScreen);
            
            // Send game over message to server
            if (multiplayerManager && multiplayerManager.connected) {
                multiplayerManager.socket.send(JSON.stringify({
                    type: 'game_over',
                    winner: 'architect',
                    roomCode: multiplayerManager.roomCode
                }));
            }
            
            // Clean up after a short delay
            setTimeout(() => {
                document.body.removeChild(timeUpScreen);
                window.location.reload(); // Force page reload
            }, 3000);
        }

        function animate() {
            requestAnimationFrame(animate);
            
            if (gameStarted && controls && controls.update) {
                controls.update(); // Call the controls update function
                
                // Check if player has reached the end marker
                if (playerRole === 'player' && maze && maze.endPosition) {
                    const distanceToEnd = Math.sqrt(
                        Math.pow(camera.position.x - maze.endPosition.x, 2) +
                        Math.pow(camera.position.z - maze.endPosition.z, 2)
                    );
                    if (distanceToEnd < 1.0) { // If player is within 1 unit of the end marker
                        handlePlayerWin();
                    }
                }
                
                if ((playerRole === 'player' || playerRole === 'monster') && multiplayerManager && multiplayerManager.connected) {
                    const now = Date.now();
                    // Only send position updates at most every 50ms
                    if (now - lastPositionUpdate >= POSITION_UPDATE_INTERVAL) {
                        lastPositionUpdate = now;
                        
                        // Send position update to server
                        const position = {
                            x: camera.position.x,
                            y: camera.position.y,
                            z: camera.position.z
                        };
                        const rotation = {
                            x: camera.rotation.x,
                            y: camera.rotation.y,
                            z: camera.rotation.z
                        };
                        
                        // Send position and rotation update to server with correct type
                        if (multiplayerManager.socket && multiplayerManager.socket.readyState === WebSocket.OPEN) {
                            multiplayerManager.socket.send(JSON.stringify({
                                type: playerRole === 'monster' ? 'monster_position' : 'player_position',
                                position: position,
                                rotation: rotation,
                                roomCode: multiplayerManager.roomCode,
                                sessionId: multiplayerManager.gameState.sessionId
                            }));
                        }
                    }
                }
            }
            
            if (renderer && scene && camera) {
                renderer.render(scene, camera);
            }
        }

        // Event Listeners
        document.getElementById('singlePlayerButton').addEventListener('click', () => {
            console.log('Single player button clicked');
            startGame('single');
        });
        document.getElementById('multiplayerButton').addEventListener('click', () => {
            console.log('Multiplayer button clicked');
            showMultiplayerMenu();
        });
        document.getElementById('createRoomButton').addEventListener('click', () => {
            console.log('Create room button clicked');
            createRoom();
        });
        document.getElementById('joinRoomButton').addEventListener('click', () => {
            console.log('Join room button clicked');
            showJoinRoom();
        });
        document.getElementById('backToMainButton').addEventListener('click', () => {
            document.getElementById('multiplayerMenu').style.display = 'none';
            document.getElementById('startScreen').style.display = 'block';
        });
        document.getElementById('roomCodeInput').addEventListener('keyup', (e) => {
            if (e.key === 'Enter') {
                joinRoom();
            }
        });

        // Add click handler for room code copying
        document.getElementById('roomCode').addEventListener('click', function() {
            copyRoomCode(this);
        });

        // Handle window resizing
        window.addEventListener('resize', () => {
            if (camera && renderer) {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            }
        });

        // Clean up when leaving the game
        window.addEventListener('beforeunload', () => {
            if (multiplayerManager) {
                multiplayerManager.disconnect();
            }
            gameStarted = false;
        });

        // Handle visibility change to prevent reconnection loops
        document.addEventListener('visibilitychange', () => {
            if (document.hidden) {
                console.log('Page hidden, handling cleanup...');
                // Store current game state before going hidden
                if (multiplayerManager && multiplayerManager.gameState.active) {
                    multiplayerManager.gameState.lastKnownState = {
                        roomCode: multiplayerManager.roomCode,
                        role: multiplayerManager.role,
                        isHost: multiplayerManager.isHost,
                        position: camera ? { x: camera.position.x, y: camera.position.y, z: camera.position.z } : null
                    };
                }
            } else {
                console.log('Page visible, checking game state...');
                if (multiplayerManager && multiplayerManager.gameState.active) {
                    // Verify connection and game state when becoming visible
                    if (!multiplayerManager.connected || multiplayerManager.gameState.reconnecting) {
                        console.log('Connection lost while hidden, attempting to restore...');
                        multiplayerManager.connect();
                    } else {
                        // Send a ping to verify connection is still alive
                        multiplayerManager.socket.send(JSON.stringify({
                            type: 'ping',
                            timestamp: Date.now()
                        }));
                    }
                }
            }
        });

        // Update the MultiplayerManager to handle disconnections better
        MultiplayerManager.prototype.handleDisconnect = function() {
            console.log('Handling disconnection...');
            this.connected = false;
            
            if (gameStarted && !this.disconnecting) {
                // Show a reconnection message
                let reconnectMessage = document.getElementById('reconnectMessage');
                if (!reconnectMessage) {
                    reconnectMessage = document.createElement('div');
                    reconnectMessage.id = 'reconnectMessage';
                    reconnectMessage.style.cssText = `
                        position: fixed;
                        top: 50%;
                        left: 50%;
                        transform: translate(-50%, -50%);
                        background: rgba(0, 0, 0, 0.8);
                        color: white;
                        padding: 20px;
                        border-radius: 10px;
                        z-index: 1000;
                        text-align: center;
                    `;
                    document.body.appendChild(reconnectMessage);
                }
                
                reconnectMessage.innerHTML = `
                    <h3>Connection Lost</h3>
                    <p>Attempting to reconnect...</p>
                    <button onclick="location.reload()" style="margin-top: 10px; padding: 5px 10px;">Restart Game</button>
                `;
                
                // Try to reconnect
                this.reconnect();
                
                // Set a timeout to show the menu if reconnection fails
                setTimeout(() => {
                    if (!this.connected && gameStarted) {
                        console.log('Reconnection failed, showing start screen');
                        hideAllMenus();
                        
                        // Only show start screen if we're completely disconnected
                        if (!this.socket || this.socket.readyState !== WebSocket.CONNECTING) {
                            document.getElementById('startScreen').style.display = 'block';
                            gameStarted = false;
                            
                            // Remove reconnect message
                            if (reconnectMessage) {
                                reconnectMessage.remove();
                            }
                            
                            // Show an error message to the user
                            alert('Lost connection to the game. Please try again.');
                        }
                    }
                }, 15000); // Give even more time for reconnection attempts
            }
        };

        // Override MultiplayerManager message handling completely
        MultiplayerManager.prototype.handleMessage = function(message) {
            console.log('🔔 CLIENT: Received message:', message.type, message);
            
            switch (message.type) {
                case 'room_created':
                    console.log('🏠 Room created, setting up...');
                    this.roomCode = message.roomCode;
                    this.isHost = true;
                    this.role = message.role;
                    playerRole = message.role; // This will be 'waiting' initially
                    this.gameState.players.add('host');
                    this.gameState.playerCount = 1;
                    this.gameState.canStart = false;
                    this.gameState.allPlayersJoined = false;
                    if (this.onRoomCreated) {
                        this.onRoomCreated(message.roomCode);
                    }
                    break;

                case 'room_joined':
                    console.log('🚪 Room joined, setting up...');
                    this.roomCode = message.roomCode;
                    this.role = message.role;
                    playerRole = message.role; // This will be 'waiting' initially
                    this.gameState.canStart = false;
                    this.gameState.allPlayersJoined = false;
                    if (this.onRoomJoined) {
                        this.onRoomJoined();
                    }
                    break;

                case 'player_joined':
                    console.log('👥 Player joined');
                    this.gameState.players.add(message.playerId);
                    this.gameState.playerCount++;
                    if (this.onPlayerJoined) {
                        this.onPlayerJoined(message.playerId, message.role);
                    }
                    break;

                case 'role_assigned':
                    console.log('🎭 ROLE ASSIGNED:', message.role);
                    this.role = message.role;
                    playerRole = message.role; // This is the actual game role
                    if (this.onRoleAssigned) {
                        console.log('🎭 Calling onRoleAssigned callback');
                        this.onRoleAssigned(message.role, message.message);
                    }
                    break;

                case 'game_ready':
                    console.log('🎮 GAME READY - Starting game');
                    this.gameState.allPlayersJoined = true;
                    this.gameState.canStart = true;
                    if (this.onGameReady) {
                        console.log('🎮 Calling onGameReady callback');
                        this.onGameReady();
                    }
                    break;

                case 'waiting_for_players':
                    console.log('⏳ Waiting for players...');
                    this.gameState.allPlayersJoined = false;
                    this.gameState.canStart = false;
                    break;

                case 'player_left':
                    console.log('👋 Player left');
                    this.gameState.players.delete(message.playerId);
                    this.gameState.playerCount--;
                    this.gameState.canStart = false;
                    this.gameState.allPlayersJoined = false;
                    if (this.onPlayerLeft) {
                        this.onPlayerLeft(message.playerId);
                    }
                    break;

                case 'maze_data':
                    console.log('🗺️ Received maze data');
                    maze = message.maze;
                    maze.wallPositions = maze.wallPositions || [];
                    break;

                case 'error':
                    console.error('❌ Server error:', message.error);
                    if (this.onError) {
                        this.onError(message.error);
                    }
                    break;

                case 'player_position':
                case 'monster_position':
                    // Handle position updates separately
                    handleMultiplayerMessage(message);
                    break;

                default:
                    console.log('❓ Unknown message type:', message.type);
                    break;
            }
        };

        function handleMultiplayerMessage(message) {
            console.log('Handling message:', message);
            
            switch (message.type) {
                case 'player_position':
                    if (!message.position || typeof message.position.x !== 'number' || typeof message.position.z !== 'number') {
                        console.error('Invalid player position received:', message.position);
                        return;
                    }

                    if (playerRole === 'guide' || playerRole === 'architect') {
                        // Store position for this specific player ID
                        playerPositions[message.playerId] = {
                            x: message.position.x,
                            y: message.position.y,
                            z: message.position.z,
                            rotation: message.rotation
                        };
                        
                        // Guide: Update 2D view
                        if (playerRole === 'guide' && maze && guideCanvas && guideCtx) {
                            requestAnimationFrame(() => {
                                // Get the first (and should be only) player position
                                const playerPos = Object.values(playerPositions)[0] || null;
                                const monsterPos = Object.values(monsterPositions)[0] || null;
                                drawGuideView(maze, playerPos, monsterPos);
                            });
                        }
                        
                        // Architect: Update 3D view
                        if (playerRole === 'architect') {
                            console.log('Architect received player position:', message);
                            if (otherPlayers[message.playerId]) {
                                // Update existing player representation
                                otherPlayers[message.playerId].visible = true;
                                otherPlayers[message.playerId].position.set(
                                    message.position.x,
                                    message.position.y,
                                    message.position.z
                                );
                                if (message.rotation) {
                                    otherPlayers[message.playerId].rotation.set(
                                        message.rotation.x,
                                        message.rotation.y,
                                        message.rotation.z
                                    );
                                }
                            } else {
                                // Create player representation for architect's 3D view
                                console.log('Creating player representation for architect 3D view');
                                const playerGeometry = new THREE.Group();
                                
                                const body = new THREE.Mesh(
                                    new THREE.CylinderGeometry(0.4, 0.4, 2.5, 8),
                                    new THREE.MeshPhongMaterial({ 
                                        color: 0x00ff00,
                                        emissive: 0x00ff00,
                                        emissiveIntensity: 0.5
                                    })
                                );
                                playerGeometry.add(body);
                                
                                const ring = new THREE.Mesh(
                                    new THREE.TorusGeometry(0.5, 0.1, 8, 16),
                                    new THREE.MeshPhongMaterial({
                                        color: 0xffff00,
                                        emissive: 0xffff00,
                                        emissiveIntensity: 0.7
                                    })
                                );
                                ring.position.y = 1.5;
                                ring.rotation.x = Math.PI / 2;
                                playerGeometry.add(ring);
                                
                                otherPlayers[message.playerId] = playerGeometry;
                                otherPlayers[message.playerId].position.set(
                                    message.position.x,
                                    message.position.y,
                                    message.position.z
                                );
                                otherPlayers[message.playerId].visible = true;
                                scene.add(otherPlayers[message.playerId]);
                                console.log('Added player representation to architect 3D scene');
                            }
                        }

                        // Check if player reached the end
                        if (maze && maze.endPosition) {
                            const distanceToEnd = Math.sqrt(
                                Math.pow(message.position.x - maze.endPosition.x, 2) +
                                Math.pow(message.position.z - maze.endPosition.z, 2)
                            );
                            if (distanceToEnd < 1.0) { // If player is within 1 unit of the end marker
                                handlePlayerWin();
                            }
                        }
                    } else if (playerRole === 'monster') {
                        console.log('Monster received player position:', message);
                        if (otherPlayers[message.playerId]) {
                            // Update player position for monster view
                            otherPlayers[message.playerId].visible = true;
                            otherPlayers[message.playerId].position.set(
                                message.position.x,
                                message.position.y,
                                message.position.z
                            );
                            if (message.rotation) {
                                otherPlayers[message.playerId].rotation.set(
                                    message.rotation.x,
                                    message.rotation.y,
                                    message.rotation.z
                                );
                            }
                            
                            // Calculate and update distance to player
                            const distance = Math.sqrt(
                                Math.pow(camera.position.x - message.position.x, 2) +
                                Math.pow(camera.position.z - message.position.z, 2)
                            );
                            updateDistanceIndicator(distance);

                            // Check if monster caught the player
                            if (distance < 1.5) { // If monster is within 1.5 units of the player
                                handleMonsterWin();
                            }
                        } else {
                            console.log('Creating player representation for monster view');
                            // Create player representation for monster's view
                            const playerGeometry = new THREE.Group();
                            
                            // Main body - taller and brighter cylinder
                            const body = new THREE.Mesh(
                                new THREE.CylinderGeometry(0.4, 0.4, 2.5, 8),
                                new THREE.MeshPhongMaterial({ 
                                    color: 0x00ff00,
                                    emissive: 0x00ff00,
                                    emissiveIntensity: 0.5
                                })
                            );
                            playerGeometry.add(body);
                            
                            // Add glowing ring at the top
                            const ring = new THREE.Mesh(
                                new THREE.TorusGeometry(0.5, 0.1, 8, 16),
                                new THREE.MeshPhongMaterial({
                                    color: 0xffff00,
                                    emissive: 0xffff00,
                                    emissiveIntensity: 0.7
                                })
                            );
                            ring.position.y = 1.5;
                            ring.rotation.x = Math.PI / 2;
                            playerGeometry.add(ring);
                            
                            otherPlayers[message.playerId] = playerGeometry;
                            otherPlayers[message.playerId].position.set(
                                message.position.x,
                                message.position.y,
                                message.position.z
                            );
                            otherPlayers[message.playerId].visible = true;
                            scene.add(otherPlayers[message.playerId]);
                        }
                    }
                    break;

                case 'monster_position':
                    if (playerRole === 'guide' || playerRole === 'architect') {
                        if (!message.position || typeof message.position.x !== 'number' || typeof message.position.z !== 'number') {
                            console.error('Invalid monster position received:', message.position);
                            return;
                        }
                        
                        // Store position for this specific monster ID
                        monsterPositions[message.playerId] = {
                            x: message.position.x,
                            y: message.position.y,
                            z: message.position.z,
                            rotation: message.rotation
                        };
                        
                        // Guide: Update 2D view
                        if (playerRole === 'guide' && maze && guideCanvas && guideCtx) {
                            requestAnimationFrame(() => {
                                // Get the first (and should be only) player and monster positions
                                const playerPos = Object.values(playerPositions)[0] || null;
                                const monsterPos = Object.values(monsterPositions)[0] || null;
                                drawGuideView(maze, playerPos, monsterPos);
                            });
                        }
                        
                        // Architect: Update 3D view
                        if (playerRole === 'architect') {
                            console.log('Architect received monster position:', message);
                            if (otherPlayers[message.playerId]) {
                                // Update existing monster representation
                                otherPlayers[message.playerId].visible = true;
                                otherPlayers[message.playerId].position.set(
                                    message.position.x,
                                    message.position.y,
                                    message.position.z
                                );
                                if (message.rotation) {
                                    otherPlayers[message.playerId].rotation.set(
                                        message.rotation.x,
                                        message.rotation.y,
                                        message.rotation.z
                                    );
                                }
                            } else {
                                // Create monster representation for architect's 3D view
                                console.log('Creating monster representation for architect 3D view');
                                const monsterMesh = new THREE.Mesh(
                                    new THREE.CylinderGeometry(0.3, 0.3, 2, 8),
                                    new THREE.MeshPhongMaterial({ 
                                        color: 0xff0000,
                                        emissive: 0xff0000,
                                        emissiveIntensity: 0.5
                                    })
                                );
                                
                                otherPlayers[message.playerId] = monsterMesh;
                                otherPlayers[message.playerId].position.set(
                                    message.position.x,
                                    message.position.y,
                                    message.position.z
                                );
                                otherPlayers[message.playerId].visible = true;
                                scene.add(otherPlayers[message.playerId]);
                                console.log('Added monster representation to architect 3D scene');
                            }
                        }
                    } else if (playerRole === 'player') {
                        // Player sees monster position
                        console.log('Player received monster position:', message);
                        if (otherPlayers[message.playerId]) {
                            otherPlayers[message.playerId].position.set(
                                message.position.x,
                                message.position.y,
                                message.position.z
                            );
                            if (message.rotation) {
                                otherPlayers[message.playerId].rotation.set(
                                    message.rotation.x,
                                    message.rotation.y,
                                    message.rotation.z
                                );
                            }

                            // Check if monster caught the player
                            const distance = Math.sqrt(
                                Math.pow(camera.position.x - message.position.x, 2) +
                                Math.pow(camera.position.z - message.position.z, 2)
                            );
                            if (distance < 1.5) { // If monster is within 1.5 units of the player
                                handleMonsterWin();
                            }
                        }
                    }
                    break;

                case 'maze_data':
                    console.log('Received maze data:', message.maze);
                    maze = message.maze;
                    maze.wallPositions = maze.wallPositions || [];
                    
                    // Initialize the maze for all roles
                    if (playerRole === 'player' || playerRole === 'monster') {
                        generateNewMaze();
                    } else if (playerRole === 'guide' || playerRole === 'architect') {
                        drawGuideView(maze);
                    }
                    break;

                case 'waiting_for_players':
                    console.log('Waiting for players:', message);
                    const instructionsElement = document.getElementById('roomCodeInstructions');
                    if (instructionsElement) {
                        instructionsElement.textContent = message.message || 'Waiting for more players...';
                        instructionsElement.style.display = 'block';
                    }
                    break;

                case 'host_assigned':
                    console.log('Host assigned:', message);
                    if (message.isHost) {
                        this.isHost = true;
                    }
                    break;

                case 'error':
                    console.error('Server error:', message.error);
                    if (this.onError) {
                        this.onError(message.error);
                    }
                    break;

                case 'player_joined':
                    if (this.onPlayerJoined) {
                        this.onPlayerJoined(message.playerId, message.role);
                    }
                    break;

                case 'player_left':
                    if (this.onPlayerLeft) {
                        this.onPlayerLeft(message.playerId);
                    }
                    break;

                case 'game_over':
                    if (!message.winner) return;
                    
                    if (message.winner === 'player' && playerRole !== 'player') {
                        handlePlayerWin();
                    } else if (message.winner === 'monster' && playerRole !== 'monster') {
                        handleMonsterWin();
                    }
                    
                    // Cleanup and disconnect after a short delay
                    setTimeout(() => {
                        cleanupGame();
                    }, 2000);
                    break;

                case 'game_terminated':
                    console.log('Game terminated by server, winner:', message.winner);
                    gameStarted = false;
                    
                    // Disable all controls
                    if (controls) {
                        controls.enabled = false;
                    }
                    
                    // Show appropriate win screen based on winner (for all roles including guide)
                    const isPlayerWin = message.winner === 'player';
                    const winScreen = document.createElement('div');
                    winScreen.style.cssText = `
                        position: fixed;
                        top: 50%;
                        left: 50%;
                        transform: translate(-50%, -50%);
                        background: ${isPlayerWin ? 'rgba(0, 255, 0, 0.9)' : 'rgba(255, 0, 0, 0.9)'};
                        color: white;
                        padding: 30px;
                        border-radius: 15px;
                        text-align: center;
                        font-size: 24px;
                        z-index: 1000;
                        box-shadow: 0 0 20px ${isPlayerWin ? 'rgba(0, 255, 0, 0.5)' : 'rgba(255, 0, 0, 0.5)'};
                    `;
                    
                    // Show different message based on player role
                    if (playerRole === 'guide') {
                        winScreen.innerHTML = isPlayerWin ? `
                            <h2>🎉 Player and Guide Win! 🎉</h2>
                            <p>You successfully guided the player to safety!</p>
                        ` : `
                            <h2>👻 Monster Wins! 👻</h2>
                            <p>The monster caught the player despite your guidance!</p>
                        `;
                    } else if (playerRole === 'architect') {
                        winScreen.innerHTML = isPlayerWin ? `
                            <h2>🎉 Player Escaped! 😔</h2>
                            <p>The player found the exit despite your efforts!</p>
                        ` : `
                            <h2>⏰ Time's Up! Architect Wins! 🏗️</h2>
                            <p>You successfully wasted enough time!</p>
                        `;
                    } else {
                        winScreen.innerHTML = isPlayerWin ? `
                            <h2>🎉 Player Wins! 🎉</h2>
                            <p>The player successfully reached the exit!</p>
                        ` : `
                            <h2>👻 Monster Wins! 👻</h2>
                            <p>The monster caught the player!</p>
                        `;
                    }
                    
                    document.body.appendChild(winScreen);
                    
                    // Force page reload after delay (applies to all players including guide)
                    setTimeout(() => {
                        console.log(`${playerRole} being disconnected and reloaded`);
                        window.location.reload();
                    }, 1500);
                    break;

                default:
                    console.log('Unhandled message type:', message.type);
                    break;
            }
        };



        function initGame(isMultiplayer = false) {
            if (isMultiplayer && !gameStarted) {
                console.log('Cannot start multiplayer game yet - waiting for players');
                return;
            }
            
            // ... rest of initGame function ...
        }

        function getRandomEmptyCell(maze) {
            const width = maze.maze[0].length;
            const height = maze.maze.length;
            let attempts = 0;
            const maxAttempts = 100;

            while (attempts < maxAttempts) {
                const x = Math.floor(Math.random() * width);
                const z = Math.floor(Math.random() * height);
                
                // Check if this cell is empty (not a wall) and not the start position
                if (!maze.maze[z][x] && 
                    (x !== Math.floor(maze.startPosition.x / maze.cellSize) || 
                     z !== Math.floor(maze.startPosition.z / maze.cellSize))) {
                    return { x: x, z: z };
                }
                attempts++;
            }

            // If no empty cell found after max attempts, return a default position
            return { x: 2, z: 2 };
        }

        function handlePlayerMove(ws, data) {
            console.log('Received player position:', data);
            const room = rooms.get(ws.roomCode);
            if (!room) {
                console.log('Room not found for player position:', ws.roomCode);
                return;
            }

            // Update player position
            room.playerPositions.set(ws.playerId, {
                position: data.position,
                rotation: data.rotation
            });

            // Send position to all guide and monster players
            room.players.forEach((playerWs, playerId) => {
                const role = room.roles.get(playerId);
                if (role === 'guide' || role === 'monster') {
                    console.log(`Sending position to ${role}:`, {
                        position: data.position,
                        playerId: playerId
                    });
                    playerWs.send(JSON.stringify({
                        type: 'player_position',
                        position: data.position,
                        rotation: data.rotation
                    }));
                }
            });
        }

        // Add these new functions for monster features
        function updateDistanceIndicator(distance) {
            let indicator = document.getElementById('distanceIndicator');
            if (!indicator) {
                indicator = document.createElement('div');
                indicator.id = 'distanceIndicator';
                indicator.style.cssText = `
                    position: fixed;
                    top: 60px;
                    left: 20px;
                    color: #ff0000;
                    font-size: 16px;
                    text-shadow: 0 0 5px rgba(255, 0, 0, 0.5);
                    z-index: 1000;
                `;
                document.body.appendChild(indicator);
            }
            indicator.textContent = `Distance to player: ${Math.round(distance)} units`;
        }

        function handleMonsterCatch() {
            // Create catch notification
            const notification = document.createElement('div');
            notification.style.cssText = `
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: rgba(255, 0, 0, 0.8);
                color: white;
                padding: 20px;
                border-radius: 10px;
                font-size: 24px;
                text-align: center;
                z-index: 1000;
            `;
            notification.textContent = 'You caught the player!';
            document.body.appendChild(notification);

            // Remove notification after 3 seconds
            setTimeout(() => {
                notification.remove();
            }, 3000);

            // TODO: Add game end logic here
        }

        // Add these new functions for win conditions
        function handlePlayerWin() {
            if (!gameStarted) return;
            gameStarted = false;

            // Stop the timer if running
            stopGameTimer();

            // Disable controls immediately
            if (controls) {
                controls.enabled = false;
            }

            // Create win screen
            const winScreen = document.createElement('div');
            winScreen.style.cssText = `
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: rgba(0, 255, 0, 0.9);
                color: white;
                padding: 30px;
                border-radius: 15px;
                text-align: center;
                font-size: 24px;
                z-index: 1000;
                box-shadow: 0 0 20px rgba(0, 255, 0, 0.5);
            `;
            winScreen.innerHTML = `
                <h2>🎉 Player Wins! 🎉</h2>
                <p>The player successfully reached the exit!</p>
            `;
            document.body.appendChild(winScreen);

            // Send game over message to server
            if (multiplayerManager && multiplayerManager.connected) {
                multiplayerManager.socket.send(JSON.stringify({
                    type: 'game_over',
                    winner: 'player',
                    roomCode: multiplayerManager.roomCode
                }));
            }

            // Clean up after a short delay
            setTimeout(() => {
                document.body.removeChild(winScreen);
                window.location.reload(); // Force page reload
            }, 1500);
        }

        function handleMonsterWin() {
            if (!gameStarted) return;
            gameStarted = false;

            // Disable controls immediately
            if (controls) {
                controls.enabled = false;
            }

            // Create win screen
            const winScreen = document.createElement('div');
            winScreen.style.cssText = `
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: rgba(255, 0, 0, 0.9);
                color: white;
                padding: 30px;
                border-radius: 15px;
                text-align: center;
                font-size: 24px;
                z-index: 1000;
                box-shadow: 0 0 20px rgba(255, 0, 0, 0.5);
            `;
            winScreen.innerHTML = `
                <h2>👻 Monster Wins! 👻</h2>
                <p>The monster caught the player!</p>
            `;
            document.body.appendChild(winScreen);

            // Send game over message to server
            if (multiplayerManager && multiplayerManager.connected) {
                multiplayerManager.socket.send(JSON.stringify({
                    type: 'game_over',
                    winner: 'monster',
                    roomCode: multiplayerManager.roomCode
                }));
            }

            // Clean up after a short delay
            setTimeout(() => {
                document.body.removeChild(winScreen);
                window.location.reload(); // Force page reload
            }, 1500);
        }

        function testBroadcast() {
            console.log('🧪 Test broadcast button clicked');
            if (multiplayerManager && multiplayerManager.connected) {
                console.log('🧪 Sending test_broadcast message to server');
                multiplayerManager.socket.send(JSON.stringify({
                    type: 'test_broadcast'
                }));
            } else {
                console.log('🧪 Not connected to multiplayer server');
                alert('Not connected to multiplayer server');
            }
        }

        function cleanupGame() {
            // Disable all controls and game logic
            gameStarted = false;
            if (controls) {
                controls.enabled = false;
            }

            // Remove event listeners
            document.removeEventListener('pointerlockchange', onPointerLockChange);
            document.removeEventListener('pointerlockerror', onPointerLockError);
            document.removeEventListener('mousemove', onMouseMove);
            if (keydownListener) document.removeEventListener('keydown', keydownListener);
            if (keyupListener) document.removeEventListener('keyup', keyupListener);
            
            // Exit pointer lock if active
            if (document.pointerLockElement) {
                document.exitPointerLock();
            }

            // Disconnect from server
            if (multiplayerManager && multiplayerManager.connected) {
                multiplayerManager.disconnect();
            }

            // Clear any animation frames
            if (window.animationFrameId) {
                cancelAnimationFrame(window.animationFrameId);
            }

            // Clear the scene
            if (scene) {
                while(scene.children.length > 0) { 
                    scene.remove(scene.children[0]); 
                }
            }

            // Dispose of renderer
            if (renderer && renderer.domElement) {
                renderer.domElement.remove();
                renderer.dispose();
            }

            // Hide all game-related elements
            const elementsToHide = [
                'guideView',
                'winScreen',
                'multiplayerMenu',
                'roomCode',
                'roomCodeInstructions',
                'loadingScreen',
                'errorScreen'
            ];
            
            elementsToHide.forEach(id => {
                const element = document.getElementById(id);
                if (element) {
                    element.style.display = 'none';
                }
            });

            // Show start screen
            const startScreen = document.getElementById('startScreen');
            if (startScreen) {
                startScreen.style.display = 'block';
            }

            // Reset all game variables
            scene = null;
            camera = null;
            renderer = null;
            controls = null;
            maze = null;
            mazeGroup = null;
            otherPlayers = {};
            playerRole = null;
            gameMode = 'single';
            multiplayerManager = null;
            playerPositions = {};
            monsterPositions = {};
            allPlayersJoined = false;
            roomCode = null;
            lastPositionUpdate = 0;
            lastPlayerPos = null;
            lastMonsterPos = null;
        }

        // 3D click handling for architect
        function handleArchitect3DClick(event) {
            if (playerRole !== 'architect') return;
            
            console.log('🏗️ Architect 3D left click detected');
            
            // Cast ray from camera to determine where in the maze the architect clicked
            const raycaster = new THREE.Raycaster();
            const mouse = new THREE.Vector2();
            
            // Calculate mouse position in normalized device coordinates
            const rect = renderer.domElement.getBoundingClientRect();
            mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
            
            // Cast ray from camera
            raycaster.setFromCamera(mouse, camera);
            
            // Create a ground plane at y=0 to intersect with
            const groundPlane = new THREE.Plane(new THREE.Vector3(0, 1, 0), 0);
            const intersectionPoint = new THREE.Vector3();
            raycaster.ray.intersectPlane(groundPlane, intersectionPoint);
            
            if (intersectionPoint) {
                // Convert world coordinates to grid coordinates
                const gridX = Math.round(intersectionPoint.x / maze.cellSize);
                const gridZ = Math.round(intersectionPoint.z / maze.cellSize);
                
                console.log('🏗️ Clicked at world:', intersectionPoint, 'grid:', gridX, gridZ);
                
                // Validate grid coordinates
                if (gridX >= 0 && gridX < maze.maze[0].length && gridZ >= 0 && gridZ < maze.maze.length) {
                    performArchitectAction3D(gridX, gridZ, 'add');
                } else {
                    console.log('🏗️ Click outside maze bounds');
                }
            }
        }
        
        function handleArchitect3DRightClick(event) {
            if (playerRole !== 'architect') return;
            
            console.log('🏗️ Architect 3D right click detected');
            
            // Cast ray from camera to determine where in the maze the architect clicked
            const raycaster = new THREE.Raycaster();
            const mouse = new THREE.Vector2();
            
            // Calculate mouse position in normalized device coordinates
            const rect = renderer.domElement.getBoundingClientRect();
            mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
            
            // Cast ray from camera
            raycaster.setFromCamera(mouse, camera);
            
            // Create a ground plane at y=0 to intersect with
            const groundPlane = new THREE.Plane(new THREE.Vector3(0, 1, 0), 0);
            const intersectionPoint = new THREE.Vector3();
            raycaster.ray.intersectPlane(groundPlane, intersectionPoint);
            
            if (intersectionPoint) {
                // Convert world coordinates to grid coordinates
                const gridX = Math.round(intersectionPoint.x / maze.cellSize);
                const gridZ = Math.round(intersectionPoint.z / maze.cellSize);
                
                console.log('🏗️ Right-clicked at world:', intersectionPoint, 'grid:', gridX, gridZ);
                
                // Validate grid coordinates
                if (gridX >= 0 && gridX < maze.maze[0].length && gridZ >= 0 && gridZ < maze.maze.length) {
                    performArchitectAction3D(gridX, gridZ, 'remove');
                } else {
                    console.log('🏗️ Right-click outside maze bounds');
                }
            }
        }
        
        function performArchitectAction3D(gridX, gridZ, action) {
            if (playerRole !== 'architect') {
                console.log('🏗️ Not architect, ignoring action');
                return;
            }
            
            console.log(`🏗️ Performing 3D architect action: ${action} at grid (${gridX}, ${gridZ})`);
            
            // Check current state
            const currentValue = maze.maze[gridZ][gridX];
            console.log('🏗️ Current maze value at position:', currentValue);
            
            // Determine if action is valid
            if (action === 'add' && currentValue === 1) {
                console.log('🏗️ Wall already exists at this position');
                showArchitectMessage('Wall already exists here!', false);
                return;
            }
            
            if (action === 'remove' && currentValue === 0) {
                console.log('🏗️ No wall to remove at this position');
                showArchitectMessage('No wall to remove here!', false);
                return;
            }
            
            // Calculate world coordinates
            const worldX = gridX * maze.cellSize;
            const worldZ = gridZ * maze.cellSize;
            
            console.log(`🏗️ Sending architect update: action=${action}, grid=(${gridX}, ${gridZ}), world=(${worldX}, ${worldZ})`);
            
            // Send the update to the server
            if (multiplayerManager && multiplayerManager.connected) {
                const updateData = {
                    type: 'architect_update',
                    action: action,
                    gridX: gridX,
                    gridZ: gridZ,
                    x: worldX,
                    z: worldZ
                };
                
                multiplayerManager.socket.send(JSON.stringify(updateData));
                console.log('🏗️ Architect update sent to server:', updateData);
                
                // Show feedback
                showArchitectMessage(`Wall ${action === 'add' ? 'added' : 'removed'} at (${gridX}, ${gridZ})!`, true);
            } else {
                console.error('🏗️ Cannot send architect update - not connected to server');
                showArchitectMessage('Not connected to server!', false);
            }
        }
    </script>
</body>
</html> 