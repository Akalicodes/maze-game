<!DOCTYPE html>
<html>
<head>
    <title>3D Maze Game</title>
    <!-- Load Three.js from local file -->
            <script src="js/three.min.js?v=3"></script>
        <script src="js/maze-generator.js?v=3"></script>
        <script src="js/multiplayer.js?v=3"></script>
    <script>
        // Verify Three.js loaded
        window.addEventListener('load', function() {
            if (typeof THREE === 'undefined') {
                document.body.innerHTML = '<div style="color: red; text-align: center; margin-top: 50px;">Error: Failed to load 3D library. Please try refreshing the page.</div>';
            }
        });
    </script>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: Arial, sans-serif;
            background: #000;
            color: #fff;
        }
        #startScreen {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            background: none;
            color: white;
            padding: 30px;
            z-index: 1000;
            pointer-events: auto !important;
        }
        #startScreen h1 {
            color: #4CAF50;
            text-shadow: 0 0 15px rgba(76, 175, 80, 0.7);
            margin-bottom: 30px;
            font-size: 48px;
        }
        #startScreen .instruction {
            color: rgba(255, 255, 255, 0.9);
            margin: 8px 0;
            font-size: 18px;
            text-shadow: 0 0 10px rgba(255, 255, 255, 0.5);
        }
        .gameButton {
            background: rgba(76, 175, 80, 0.8);
            border: 2px solid rgba(255, 255, 255, 0.2);
            color: white;
            padding: 15px 30px;
            font-size: 20px;
            cursor: pointer;
            border-radius: 25px;
            transition: all 0.3s;
            margin: 15px;
            width: 200px;
            backdrop-filter: blur(5px);
            text-shadow: 0 0 5px rgba(0, 0, 0, 0.3);
        }
        .gameButton:hover {
            background: rgba(76, 175, 80, 1);
            transform: scale(1.05);
            box-shadow: 0 0 20px rgba(76, 175, 80, 0.4);
        }
        #multiplayerMenu {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 30px;
            border-radius: 15px;
            z-index: 1000;
            display: none;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
        }
        #roomCodeInput {
            padding: 10px;
            font-size: 18px;
            margin: 10px;
            border-radius: 5px;
            border: none;
            text-align: center;
            width: 180px;
        }
        .backButton {
            background: #666;
            border: none;
            color: white;
            padding: 10px 20px;
            font-size: 16px;
            cursor: pointer;
            border-radius: 5px;
            transition: all 0.3s;
            margin-top: 20px;
        }
        .backButton:hover {
            background: #555;
        }
        #roomCode {
            font-size: 48px;
            margin: 20px;
            padding: 30px;
            background: rgba(0, 0, 0, 0.9);
            border-radius: 15px;
            font-family: monospace;
            letter-spacing: 8px;
            text-align: center;
            border: 3px solid #4CAF50;
            color: #4CAF50;
            cursor: pointer;
            user-select: all;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 9999;
            box-shadow: 0 0 30px rgba(76, 175, 80, 0.5);
            transition: all 0.3s ease;
            animation: pulse 2s infinite;
            display: none;
        }
        @keyframes pulse {
            0% { box-shadow: 0 0 30px rgba(76, 175, 80, 0.5); }
            50% { box-shadow: 0 0 50px rgba(76, 175, 80, 0.8); }
            100% { box-shadow: 0 0 30px rgba(76, 175, 80, 0.5); }
        }
        #roomCodeInstructions {
            color: #fff;
            font-size: 18px;
            margin-top: 20px;
            text-align: center;
            position: fixed;
            top: calc(50% + 100px);
            left: 50%;
            transform: translateX(-50%);
            z-index: 1000;
            background: rgba(0, 0, 0, 0.8);
            padding: 15px 30px;
            border-radius: 10px;
            animation: fadeIn 0.5s ease-out;
        }
        @keyframes fadeIn {
            from { opacity: 0; transform: translate(-50%, 20px); }
            to { opacity: 1; transform: translate(-50%, 0); }
        }
        @keyframes pulse {
            0% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.05); opacity: 0.8; }
            100% { transform: scale(1); opacity: 1; }
        }
        #loadingScreen {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 20px;
            border-radius: 10px;
            z-index: 2000;
            display: none;
        }
        #loadingMessage {
            margin-top: 10px;
            font-size: 18px;
        }
        #errorScreen {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            background: rgba(255, 0, 0, 0.9);
            color: white;
            padding: 30px;
            border-radius: 15px;
            z-index: 3000;
            display: none;
            max-width: 80%;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
        }
        #errorMessage {
            margin: 20px 0;
            font-size: 16px;
            white-space: pre-wrap;
            text-align: left;
        }
        #debugInfo {
            margin-top: 20px;
            font-size: 14px;
            color: #ddd;
            text-align: left;
            font-family: monospace;
            background: rgba(0, 0, 0, 0.3);
            padding: 10px;
            border-radius: 5px;
            max-height: 200px;
            overflow-y: auto;
        }
        .spinner {
            border: 4px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            border-top: 4px solid white;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 10px auto;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        #winScreen {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 30px;
            border-radius: 15px;
            text-align: center;
            z-index: 2000;
            display: none;
            animation: popIn 0.5s ease-out;
        }
        @keyframes popIn {
            0% { transform: translate(-50%, -50%) scale(0.5); opacity: 0; }
            100% { transform: translate(-50%, -50%) scale(1); opacity: 1; }
        }
        #winScreen h2 {
            color: #4CAF50;
            margin-bottom: 20px;
            font-size: 32px;
            text-shadow: 0 0 10px rgba(76, 175, 80, 0.5);
        }
        #winScreen p {
            font-size: 20px;
            margin: 15px 0;
            color: #fff;
        }
        #winScreen button {
            background: #4CAF50;
            border: none;
            color: white;
            padding: 15px 30px;
            border-radius: 5px;
            cursor: pointer;
            margin: 10px;
            font-size: 20px;
            transition: all 0.3s;
        }
        #winScreen button:hover {
            background: #45a049;
            transform: scale(1.1);
        }
        /* Remove crosshair cursor */
        canvas {
            pointer-events: auto !important;
            cursor: default !important;
            outline: none;
            z-index: 1;
        }
        
        /* Update win screen styles */
        #winScreen button {
            background: #4CAF50;
            border: none;
            color: white;
            padding: 15px 30px;
            font-size: 24px;
            cursor: pointer;
            border-radius: 8px;
            transition: all 0.3s;
            margin-top: 20px;
        }
        
        #winScreen button:hover {
            background: #45a049;
            transform: scale(1.1);
        }
        * {
            pointer-events: auto !important;
            cursor: default;
        }
        #gameContainer {
            position: relative;
            width: 100%;
            height: 100%;
        }
        .no-cursor {
            cursor: none;
        }
        .game-canvas {
            outline: none;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            -khtml-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
            pointer-events: auto !important;
        }
        #guideInstructions {
            position: absolute;
            top: 20px;
            left: 20px;
            color: #4CAF50;
            font-size: 18px;
            text-shadow: 0 0 5px rgba(76, 175, 80, 0.5);
        }
        #guideView {
            display: none;
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000;
            pointer-events: auto !important;
        }
        #guideCanvas {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: #111;
            pointer-events: auto !important;
        }
    </style>
</head>
<body>
    <div id="startScreen">
        <h1>3D Maze Game</h1>
        <div class="instruction">Navigate through the maze to find the exit</div>
        <div class="instruction">Use WASD to move and mouse to look around</div>
        <button class="gameButton" id="singlePlayerButton">Single Player</button>
        <button class="gameButton" id="multiplayerButton">Multiplayer</button>
    </div>

    <div id="roomCode" class="room-code"></div>
    <div id="roomCodeInstructions" class="room-code-instructions"></div>

    <div id="multiplayerMenu">
        <h2>Multiplayer Mode</h2>
        <button class="gameButton" id="createRoomButton">Create Room</button>
        <button class="gameButton" id="joinRoomButton">Join Room</button>
        <input type="text" id="roomCodeInput" placeholder="Enter Room Code" style="display: none;">
        <button class="backButton" id="backToMainButton">Back to Main Menu</button>
    </div>

    <div id="loadingScreen">
        <div class="spinner"></div>
        <div id="loadingMessage">Loading Game...</div>
    </div>

    <!-- Add new waiting and role assignment screens -->
    <div id="waitingScreen" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); text-align: center; background: rgba(0, 0, 0, 0.9); color: white; padding: 40px; border-radius: 20px; z-index: 2000; border: 3px solid #4CAF50; box-shadow: 0 0 30px rgba(76, 175, 80, 0.5);">
        <h2 style="color: #4CAF50; font-size: 32px; margin-bottom: 20px; text-shadow: 0 0 10px rgba(76, 175, 80, 0.5);">üéÆ Waiting for Players</h2>
        <div class="spinner"></div>
        <div id="waitingMessage" style="font-size: 20px; margin: 20px 0;">Waiting for players to join...</div>
                        <div id="playerCount" style="font-size: 18px; color: #4CAF50;">Players joined: 1/4</div>
        <div style="margin-top: 30px; text-align: center;">
            <div style="font-size: 18px; color: #ccc; margin-bottom: 10px;">Room Code:</div>
            <div id="waitingRoomCode" style="font-family: monospace; color: #4CAF50; cursor: pointer; padding: 15px 25px; border: 3px solid #4CAF50; border-radius: 10px; font-size: 32px; font-weight: bold; letter-spacing: 4px; background: rgba(76, 175, 80, 0.1); transition: all 0.3s; display: inline-block;" onclick="copyRoomCode(this)" title="Click to copy" onmouseover="this.style.background='rgba(76, 175, 80, 0.2)'" onmouseout="this.style.background='rgba(76, 175, 80, 0.1)'"></div>
            <div style="font-size: 14px; color: #999; margin-top: 10px;">Click to copy ‚Ä¢ Share with other players</div>
        </div>
    </div>

    <div id="roleAssignmentScreen" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); text-align: center; background: rgba(0, 0, 0, 0.9); color: white; padding: 40px; border-radius: 20px; z-index: 2000; border: 3px solid #FFD700; box-shadow: 0 0 30px rgba(255, 215, 0, 0.5);">
        <h2 style="color: #FFD700; font-size: 32px; margin-bottom: 20px; text-shadow: 0 0 10px rgba(255, 215, 0, 0.5);">üé≤ Assigning Roles</h2>
        <div class="spinner" style="border-top-color: #FFD700;"></div>
        <div style="font-size: 20px; margin: 20px 0;">All players joined! Assigning roles...</div>
        <div style="font-size: 16px; color: #ccc;">Please wait while roles are being assigned</div>
    </div>

    <div id="yourRoleScreen" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); text-align: center; background: rgba(0, 0, 0, 0.9); color: white; padding: 40px; border-radius: 20px; z-index: 2000; border: 3px solid #FF6B6B; box-shadow: 0 0 30px rgba(255, 107, 107, 0.5);">
        <h2 style="color: #FF6B6B; font-size: 32px; margin-bottom: 20px; text-shadow: 0 0 10px rgba(255, 107, 107, 0.5);">üé≠ Your Role</h2>
        <div id="assignedRole" style="font-size: 36px; font-weight: bold; margin: 20px 0; color: #4CAF50;"></div>
        <div id="roleDescription" style="font-size: 18px; margin: 20px 0; line-height: 1.5;"></div>
        <div style="font-size: 16px; color: #FFD700; margin-top: 20px;">Game starting in 3 seconds...</div>
    </div>

    <div id="errorScreen">
        <h2>Error</h2>
        <div id="errorMessage"></div>
        <div id="debugInfo"></div>
        <button onclick="location.reload()" style="margin-top: 15px; padding: 10px 20px; cursor: pointer; background: white; color: red; border: none; border-radius: 5px; font-weight: bold;">Reload Game</button>
    </div>

    <div id="winScreen">
        <h2>üéâ You Won! üéâ</h2>
        <p>Congratulations! You made it through the maze!</p>
        <p>Refresh the page to play again</p>
    </div>

    <div id="guideView" style="display: none;">
        <canvas id="guideCanvas"></canvas>
        <div id="guideInstructions">
            <span id="roleTitle">Guide View</span>
        </div>
    </div>

    <!-- Test button removed for cleaner UI -->

    <script>
        let scene, camera, renderer, controls;
        let maze, mazeGroup;
        const MAZE_SIZE = { width: 25, height: 25 };
        let keydownListener, keyupListener;
        let textureLoader;
        let architectWallMaterial = null; // Global material for architect walls
        let handleWallChangedCallCount = 0; // Track how many times handleWallChanged is called
        let gameMode = 'single';
        let multiplayerManager = null;
        let otherPlayers = {};
        let gameStarted = false;
        let playerRole = null;
        let gameTimer = null;
        let gameTimeLimit = 300000; // 5 minutes in milliseconds
        let guideCanvas, guideCtx;
        let playerPositions = {}; // Track positions by player ID
        let monsterPositions = {}; // Track monster positions by player ID
        let allPlayersJoined = false;
        let requiredPlayers = 4;
        let roomCode = null;
        let architectWallChanges = { added: new Set(), removed: new Set() }; // Track architect changes
        
        // Expose architectWallChanges globally so all players can access it
        window.architectWallChanges = architectWallChanges;
        let lastPositionUpdate = 0;
        const POSITION_UPDATE_INTERVAL = 100; // Throttle position updates for better performance
        let monsterTexture = null;
        // Add smoothing state variables at the top of the file, after other variable declarations
        let lastPlayerPos = null;
        let lastMonsterPos = null;
        const positionSmoothingFactor = 0.3;
        const rotationSmoothingFactor = 0.3;
        // Performance optimization variables
        let lastArrowUpdate = 0;
        const ARROW_UPDATE_INTERVAL = 100; // Update arrow every 100ms for better performance
        let rotationBuffer = [];
        const ROTATION_BUFFER_SIZE = 3; // Reduce buffer size for memory efficiency

        function createMonsterMesh() {
            // Create a plane geometry that always faces the camera
            const monsterGeometry = new THREE.PlaneGeometry(2, 2);
            const monsterMaterial = new THREE.MeshBasicMaterial({
                map: textureLoader.load('monster.png'),
                transparent: true,
                side: THREE.DoubleSide
            });
            const monster = new THREE.Mesh(monsterGeometry, monsterMaterial);
            
            // Create a container for the monster to handle positioning
            const monsterContainer = new THREE.Object3D();
            monsterContainer.add(monster);
            
            // Make the monster plane always face the camera
            monster.onBeforeRender = function(renderer, scene, camera) {
                monster.quaternion.copy(camera.quaternion);
            };
            
            return monsterContainer;
        }

        function createRoom() {
            if (gameStarted) {
                console.log('Game already started, ignoring createRoom');
                return;
            }
            
            showLoadingScreen('Creating Room...');
            console.log('Creating room...');
            
            // Initialize multiplayer manager
            multiplayerManager = new MultiplayerManager();
            
            // Set up callbacks
            multiplayerManager.onConnectionSuccess = () => {
                console.log('Successfully connected, creating room...');
                multiplayerManager.createRoom();
            };

            multiplayerManager.onMazeDataReceived = (mazeData) => {
                console.log('üó∫Ô∏è Maze data received and loaded!', mazeData);
                maze = mazeData;
                maze.wallPositions = maze.wallPositions || [];
                
                // Now that we have maze data, we can safely initialize the scene
                // But only if we have a proper role assigned
                console.log('üé¨ Maze data received (createRoom), checking if ready to initialize...');
                console.log('üé¨ Current playerRole:', playerRole, 'isHost:', multiplayerManager?.isHost);
                if (playerRole && playerRole !== 'waiting') {
                    console.log('üé¨ Role assigned, initializing scene...');
                    if (playerRole === 'guide' || playerRole === 'architect') {
                        console.log('üéÆ Initializing 2D view for:', playerRole);
                        initGuideView(mazeData);
                        if (playerRole === 'architect') {
                            try {
                                setupArchitectControls();
                            } catch (error) {
                                console.error('Error setting up architect controls:', error);
                            }
                        }
                    } else {
                        init(false);
                    }
                } else {
                    console.log('üîÑ Waiting for role assignment before initializing scene...');
                }
            };

            multiplayerManager.onRoomCreated = (roomCode) => {
                console.log('Room created with code:', roomCode);
                hideLoadingScreen();
                
                // Hide all menus
                hideAllMenus();
                
                // Show waiting screen
                document.getElementById('waitingScreen').style.display = 'block';
                document.getElementById('waitingRoomCode').textContent = roomCode;
                document.getElementById('playerCount').textContent = 'Players joined: 1/4';
                document.getElementById('waitingMessage').textContent = 'Waiting for 3 more players to join...';
                
                // Set the game mode but don't start yet
                gameMode = 'multiplayer';
                playerRole = 'waiting';
                allPlayersJoined = false;
                gameStarted = false;
                
                // Host should generate maze data immediately and send it to server
                console.log('üè† Room created, host generating maze data...');
                const generator = new MazeGenerator(MAZE_SIZE.width, MAZE_SIZE.height);
                maze = generator.generate();
                
                // Send maze data to server for distribution to all players
                multiplayerManager.socket.send(JSON.stringify({
                    type: 'maze_data',
                    maze: maze
                }));
                
                console.log('üó∫Ô∏è Maze generated and sent to server');
                
                // DON'T initialize yet - wait for role assignment
                console.log('üîÑ Host waiting for role assignment before initialization...');
            };

            // üö® CRITICAL FIX: Add the missing onGameReady callback for host!
            multiplayerManager.onGameReady = () => {
                console.log('üéÆ HOST onGameReady called - Current role:', playerRole, 'Maze exists:', !!maze);
                allPlayersJoined = true;
                gameStarted = true;
                
                // Hide all UI screens
                hideAllMenus();
                
                // Wait for maze data if not available
                if (!maze) {
                    console.log('üéÆ No maze data yet, waiting...');
                    setTimeout(() => {
                        if (maze) {
                            console.log('üéÆ Maze data now available, starting game');
                            multiplayerManager.onGameReady();
                        } else {
                            console.error('üéÆ Still no maze data after waiting');
                        }
                    }, 100);
                    return;
                }
                
                // Add a 3-second countdown before starting
                setTimeout(() => {
                    // Force game start based on role
                    console.log('üéÆ HOST Starting game for role:', playerRole);
                    if (playerRole === 'guide') {
                        console.log('üéÆ Starting GUIDE view (2D only)');
                        initGuideView(maze);
                    } else if (playerRole === 'architect') {
                        console.log('üéÆ Starting ARCHITECT view (2D with wall editing)');
                        console.log('üèóÔ∏è ARCHITECT INITIALIZATION - Maze data:', !!maze, 'Guide canvas:', !!guideCanvas);
                        // Architect gets 2D view with wall editing
                        initGuideView(maze);
                        
                        // Setup architect click controls
                        try {
                            console.log('üèóÔ∏è CALLING setupArchitectControls...');
                            setupArchitectControls();
                            console.log('üèóÔ∏è setupArchitectControls COMPLETED!');
                        } catch (error) {
                            console.error('‚ùå Error in architect setup:', error);
                            console.error('‚ùå Error stack:', error.stack);
                        }
                    } else if (playerRole === 'player' || playerRole === 'monster') {
                        console.log('üéÆ HOST Starting 3D view for:', playerRole);
                        console.log('üéÆ HOST Pre-start state check:', {
                            playerRole: playerRole,
                            controlsExist: !!controls,
                            sceneExists: !!scene,
                            cameraExists: !!camera,
                            isInitialized: isInitialized,
                            gameStartedBefore: gameStarted
                        });
                        
                        // Ensure scene is initialized first
                        if (!isInitialized || !scene || !controls) {
                            console.log('üîß HOST Scene not ready, initializing now...');
                            init(true); // Initialize with game started
                        } else {
                            console.log('üîß HOST Scene ready, just enabling controls...');
                            gameStarted = true;
                            if (controls) {
                                controls.enabled = true;
                            }
                            
                            // Request pointer lock for player and monster - DISABLED
                            // if (renderer && renderer.domElement) {
                            //     renderer.domElement.requestPointerLock();
                            //     console.log('üé¨ HOST Pointer lock requested for game start');
                            // }
                        }
                        
                        console.log('üéÆ HOST Game controls should now be ENABLED for:', playerRole);
                    } else {
                        console.log('üéÆ HOST Unknown role:', playerRole);
                    }
                }, 3000);
            };

            // Add role assignment callback for host (same as joinRoom)
            multiplayerManager.onRoleAssigned = (role, message) => {
                console.log('üé≠ HOST Role assigned:', role, message);
                playerRole = role;
                
                // Hide role assignment screen and show your role screen
                document.getElementById('roleAssignmentScreen').style.display = 'none';
                document.getElementById('yourRoleScreen').style.display = 'block';
                
                // Update role information
                document.getElementById('assignedRole').textContent = role.toUpperCase();
                
                // Set role descriptions
                let description = '';
                switch(role) {
                    case 'player':
                        description = 'Navigate through the maze to find the green exit. Use WASD to move and mouse to look around. Avoid the monster!';
                        break;
                    case 'guide':
                        description = 'Help the player reach the exit using your top-down 2D view. You can see the entire maze layout and all player positions.';
                        break;
                    case 'architect':
                        description = 'Architect: Click to add/remove walls.';
                        break;
                    case 'monster':
                        description = 'Hunt the player in first-person view! Use WASD to move and mouse to look around. Catch the player before they escape!';
                        break;
                    default:
                        description = message || 'Unknown role';
                }
                document.getElementById('roleDescription').textContent = description;
                
                // DON'T initialize the scene yet - wait for onGameReady
                console.log('üé≠ HOST Role assigned, waiting for game ready signal...');
            };

            multiplayerManager.onPlayerJoined = (playerId, role) => {
                console.log('Player joined:', playerId, 'as', role);
                
                // Initialize player count only once when first player joins
                if (typeof window.playerJoinCount === 'undefined') {
                    window.playerJoinCount = 1; // Start with host
                }
                window.playerJoinCount++; // Add the newly joined player
                
                console.log('üî¢ Player count update - total players:', window.playerJoinCount);
                document.getElementById('playerCount').textContent = `Players joined: ${window.playerJoinCount}/4`;
                
                const playersNeeded = requiredPlayers - window.playerJoinCount;
                if (playersNeeded > 0) {
                    document.getElementById('waitingMessage').textContent = `Waiting for ${playersNeeded} more player${playersNeeded > 1 ? 's' : ''} to join...`;
                } else {
                    // All players joined - show role assignment screen
                    document.getElementById('waitingScreen').style.display = 'none';
                    document.getElementById('roleAssignmentScreen').style.display = 'block';
                    
                    document.getElementById('waitingMessage').textContent = 'All players joined! Assigning roles...';
                }
                
                if (!otherPlayers[playerId] && (playerRole === 'player' || playerRole === 'monster' || playerRole === 'architect')) {
                    console.log('üé≠ Creating representation for player:', playerId, 'with role:', role, 'for viewer:', playerRole);
                    console.log('üé¨ Scene exists:', !!scene, 'Scene children:', scene?.children?.length);
                    
                    // Create a more visible representation for players
                    let playerMesh;
                    if (role === 'monster') {
                        // Monster representation - red cylinder for all viewers
                        playerMesh = new THREE.Mesh(
                            new THREE.CylinderGeometry(0.5, 0.5, 3, 16), // Made bigger and more detailed
                            new THREE.MeshPhongMaterial({ 
                                color: 0xff0000,
                                emissive: 0xff0000,
                                emissiveIntensity: 0.8 // Increased glow
                            })
                        );
                        console.log('üî¥ Created MONSTER representation for', playerRole, 'viewer');
                    } else if (role === 'player') {
                        // Player representation - bright green cylinder for all viewers
                        const playerGeometry = new THREE.Group();
                        
                        // Main body - taller and brighter cylinder
                        const body = new THREE.Mesh(
                            new THREE.CylinderGeometry(0.4, 0.4, 2.5, 8),
                            new THREE.MeshPhongMaterial({ 
                                color: 0x00ff00,
                                emissive: 0x00ff00,
                                emissiveIntensity: 0.5
                            })
                        );
                        playerGeometry.add(body);
                        
                        // Add glowing ring at the top
                        const ring = new THREE.Mesh(
                            new THREE.TorusGeometry(0.5, 0.1, 8, 16),
                            new THREE.MeshPhongMaterial({
                                color: 0xffff00,
                                emissive: 0xffff00,
                                emissiveIntensity: 0.7
                            })
                        );
                        ring.position.y = 1.5;
                        ring.rotation.x = Math.PI / 2;
                        playerGeometry.add(ring);
                        
                        playerMesh = playerGeometry;
                        console.log('üü¢ Created PLAYER representation for', playerRole, 'viewer');
                    }
                    
                    if (playerMesh && scene) {
                        otherPlayers[playerId] = playerMesh;
                        otherPlayers[playerId].position.set(0, 2, 0); // Raised higher for visibility
                        otherPlayers[playerId].visible = true;
                        scene.add(otherPlayers[playerId]);
                        console.log('‚úÖ Added', role, 'representation to scene for', playerRole, ':', playerId);
                        console.log('üìä Scene now has', scene.children.length, 'objects');
                    } else {
                        console.error('‚ùå Failed to add player representation - scene not ready:', !!scene, 'playerMesh:', !!playerMesh);
                        
                        // Store for later addition when scene is ready
                        if (playerMesh) {
                            console.log('üíæ Storing player representation for later addition');
                            if (!window.pendingPlayers) window.pendingPlayers = [];
                            window.pendingPlayers.push({
                                playerId: playerId,
                                role: role,
                                mesh: playerMesh
                            });
                        }
                    }
                }
            };

            multiplayerManager.onRoleAssigned = (role, message) => {
                console.log('üé≠ Role assigned:', role, message);
                playerRole = role;
                
                // Hide role assignment screen and show your role screen
                document.getElementById('roleAssignmentScreen').style.display = 'none';
                document.getElementById('yourRoleScreen').style.display = 'block';
                
                // Update role information
                document.getElementById('assignedRole').textContent = role.toUpperCase();
                
                // Set role descriptions
                let description = '';
                switch(role) {
                    case 'player':
                        description = 'Navigate through the maze to find the green exit. Use WASD to move and mouse to look around. Avoid the monster!';
                        break;
                    case 'guide':
                        description = 'Help the player reach the exit using your top-down 2D view. You can see the entire maze layout and all player positions.';
                        break;
                    case 'architect':
                        description = 'Architect: Click to add/remove walls.';
                        break;
                    case 'monster':
                        description = 'Hunt the player in first-person view! Use WASD to move and mouse to look around. Catch the player before they escape!';
                        break;
                    default:
                        description = message || 'Unknown role';
                }
                document.getElementById('roleDescription').textContent = description;
                
                // DON'T initialize the scene yet - wait for onGameReady
                // This prevents race conditions with maze data loading
                console.log('üé≠ Role assigned, waiting for game ready signal...');
            };

            multiplayerManager.onGameReady = () => {
                console.log('üéÆ onGameReady called - Current role:', playerRole, 'Maze exists:', !!maze);
                allPlayersJoined = true;
                gameStarted = true;
                
                // Hide all UI screens
                hideAllMenus();
                
                // Wait for maze data if not available
                if (!maze) {
                    console.log('üéÆ No maze data yet, waiting...');
                    setTimeout(() => {
                        if (maze) {
                            console.log('üéÆ Maze data now available, starting game');
                            multiplayerManager.onGameReady();
                        } else {
                            console.error('üéÆ Still no maze data after waiting');
                        }
                    }, 100);
                    return;
                }
                
                // REMOVED DUPLICATE onGameReady HANDLER - Using the complete one below
            };

            multiplayerManager.onPlayerLeft = (playerId) => {
                if (otherPlayers[playerId]) {
                    scene.remove(otherPlayers[playerId]);
                    delete otherPlayers[playerId];
                }
                
                // Clean up position tracking for disconnected player
                delete playerPositions[playerId];
                delete monsterPositions[playerId];
                
                // Update UI to show disconnection and waiting state
                const currentPlayers = Object.keys(otherPlayers).length + 1;
                if (currentPlayers < requiredPlayers) {
                    allPlayersJoined = false;
                    gameStarted = false;
                    
                    // Show waiting message
                    const instructionsElement = document.getElementById('roomCodeInstructions');
                    instructionsElement.style.display = 'block';
                    instructionsElement.textContent = `A player has disconnected ‚Ä¢ Waiting for ${requiredPlayers - currentPlayers} more player${requiredPlayers - currentPlayers > 1 ? 's' : ''}...`;
                    
                    // Show room code again
                    const roomCodeElement = document.getElementById('roomCode');
                    roomCodeElement.style.display = 'block';
                }
            };

            multiplayerManager.onError = (error) => {
                console.error('Error in multiplayer:', error);
                hideLoadingScreen();
                alert(error);
                showMultiplayerMenu();
            };

            // Start connection
            multiplayerManager.connect();
        }

        function startMultiplayerGame() {
            if (!gameStarted) {
                console.log('Starting multiplayer game...');
                gameStarted = true;
                
                // Hide all menus
                document.getElementById('startScreen').style.display = 'none';
                document.getElementById('multiplayerMenu').style.display = 'none';
                document.getElementById('winScreen').style.display = 'none';
                
                // Set up multiplayer components
                setupMultiplayer();
                
                // Start the animation loop
                animate();
            }
        }

        function startGame(mode = 'single') {
            if (mode === 'multiplayer') {
                console.log('Redirecting multiplayer start to startMultiplayerGame');
                startMultiplayerGame();
                return;
            }
            
            console.log('Starting single player game...');
            gameStarted = false; // Reset first
            playerRole = 'player'; // Set role for single player
            
            // Hide ALL menu elements
            hideAllMenus();
            
            // Remove old renderer and clean up
            cleanupRenderer();

            // Clean up old multiplayer resources
            cleanupMultiplayer();
            
            // Start fresh game
            gameStarted = true;
            gameMode = mode;
            init();
        }

        function hideAllMenus() {
            const menuElements = [
                'startScreen',
                'multiplayerMenu',
                'winScreen',
                'roomCode',
                'roomCodeInstructions',
                'loadingScreen',
                'errorScreen',
                'guideView',
                'waitingScreen',
                'roleAssignmentScreen',
                'yourRoleScreen',
                'simple-waiting'
            ];
            
            menuElements.forEach(elementId => {
                const element = document.getElementById(elementId);
                if (element) {
                    element.style.display = 'none';
                }
            });
        }

        function cleanupRenderer() {
            if (window.animationFrameId) {
                cancelAnimationFrame(window.animationFrameId);
                window.animationFrameId = null;
            }
            
            if (renderer && renderer.domElement && renderer.domElement.parentNode) {
                // Remove pointer lock event listeners
                document.removeEventListener('pointerlockchange', onPointerLockChange);
                document.removeEventListener('pointerlockerror', onPointerLockError);
                document.removeEventListener('mousemove', onMouseMove);
                
                // Exit pointer lock if active
                if (document.pointerLockElement === renderer.domElement) {
                    document.exitPointerLock();
                }
                
                renderer.domElement.parentNode.removeChild(renderer.domElement);
                renderer.dispose();
                renderer = null;
            }
            
            // Clean up event listeners
            if (keydownListener) {
                document.removeEventListener('keydown', keydownListener);
                keydownListener = null;
            }
            if (keyupListener) {
                document.removeEventListener('keyup', keyupListener);
                keyupListener = null;
            }
            
            // Reset initialization flags
            isInitialized = false;
            animateDebugCount = 0;
        }

        function cleanupMultiplayer() {
            if (multiplayerManager) {
                multiplayerManager.disconnect();
                multiplayerManager = null;
            }
        }

        let isInitialized = false;
        
        function init(shouldStartAnimation = true) {
            // Prevent initialization for waiting/unassigned roles
            if (!playerRole || playerRole === 'waiting') {
                console.log('‚è≥ Skipping init() - waiting for role assignment. Current role:', playerRole);
                return;
            }
            
            // Allow proper re-initialization when needed
            if (isInitialized && (playerRole === 'player' || playerRole === 'monster') && scene && controls && !shouldStartAnimation) {
                console.log('‚ö†Ô∏è Scene already fully initialized for 3D role:', playerRole, '- enabling controls only');
                gameStarted = true;
                if (controls) {
                    controls.enabled = true;
                }
                return;
            }
            
            try {
                // Guide and architect both get only 2D view
                if (playerRole === 'guide' || playerRole === 'architect') {
                    console.log(`üéÆ Initializing ${playerRole.toUpperCase()} view (2D only)...`);
                    // Initialize guide view
                    document.body.style.cursor = 'default';
                    if (maze) {
                        console.log('üó∫Ô∏è Maze data available for 2D view, calling initGuideView');
                        initGuideView(maze);
                    } else {
                        console.error('‚ùå No maze data available for 2D view');
                        document.body.innerHTML = '<div style="color: red; text-align: center; margin-top: 50px;">Error: No maze data available. Please try refreshing the page.</div>';
                    }
                    return;
                }

                console.log('üéÆ Initializing 3D view for role:', playerRole);

                // Both player and monster get the same 3D setup
                console.log('üé® Creating THREE.js scene...');
                            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x333333); // Dark grey background - visible but moody
                
                // Create renderer
                console.log('üñ•Ô∏è Creating WebGL renderer...');
                renderer = new THREE.WebGLRenderer({ 
                    antialias: true,
                    powerPreference: "high-performance"
                });
                renderer.setSize(window.innerWidth, window.innerHeight);
                renderer.setPixelRatio(window.devicePixelRatio);
                
                // Style the renderer canvas properly
                renderer.domElement.style.position = 'fixed';
                renderer.domElement.style.top = '0';
                renderer.domElement.style.left = '0';
                renderer.domElement.style.width = '100%';
                renderer.domElement.style.height = '100%';
                renderer.domElement.style.zIndex = '1';
                renderer.domElement.style.display = 'block';
                
                // For architect, make the canvas slightly transparent so they can see both views
                if (playerRole === 'architect') {
                    renderer.domElement.style.opacity = '0.8';
                    renderer.domElement.style.zIndex = '10';
                    console.log('üéÆ Architect renderer canvas made semi-transparent');
                }
                
                document.body.appendChild(renderer.domElement);
                console.log('üñ•Ô∏è Renderer canvas added to DOM');
                
                // Create first-person camera
                camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
                
                // Make scene, camera, and renderer globally accessible for wall updates
                window.scene = scene;
                window.camera = camera;
                window.renderer = renderer;
                console.log('üåç Made scene, camera, and renderer globally accessible');
                
                // Load textures
                textureLoader = new THREE.TextureLoader();
                
                // Generate new maze only for single player mode
                if (gameMode === 'single' && !maze) {
                    const generator = new MazeGenerator(MAZE_SIZE.width, MAZE_SIZE.height);
                    maze = generator.generate();
                    console.log('‚úÖ Generated maze for single player mode');
                }
                
                if (!maze) {
                    console.error('‚ùå No maze data available when trying to init 3D view');
                    throw new Error('No maze data available');
                }
                console.log('‚úÖ Maze data is available for 3D view');

                // Clean up any existing role labels first
                const existingLabels = document.querySelectorAll('.role-label');
                existingLabels.forEach(label => label.remove());

                // Set starting position based on role
                if (playerRole === 'monster') {
                    // Place monster at a random position
                    const randomCell = getRandomEmptyCell(maze);
                    camera.position.set(
                        randomCell.x * maze.cellSize,
                        1.5,
                        randomCell.z * maze.cellSize
                    );
                    console.log('Monster spawned at:', camera.position);

                    // Add monster UI overlay
                    const monsterInstructions = document.createElement('div');
                    monsterInstructions.className = 'role-label';
                    monsterInstructions.style.cssText = `
                        position: fixed;
                        top: 20px;
                        left: 20px;
                        color: #ff0000;
                        font-size: 18px;
                        text-shadow: 0 0 5px rgba(255, 0, 0, 0.5);
                        z-index: 1000;
                    `;
                    monsterInstructions.innerHTML = `Monster View`;
                    document.body.appendChild(monsterInstructions);

                    // Start game timer for monster in multiplayer
                    if (gameMode === 'multiplayer') {
                        startGameTimer();
                    }
                } else if (playerRole === 'player') {
                    // Set player starting position
                    camera.position.set(
                        maze.startPosition.x,
                        1.5,
                        maze.startPosition.z
                    );
                    console.log('Player spawned at:', camera.position);

                    // Add player UI overlay
                    const playerInstructions = document.createElement('div');
                    playerInstructions.className = 'role-label';
                    playerInstructions.style.cssText = `
                        position: fixed;
                        top: 20px;
                        left: 20px;
                        color: #4CAF50;
                        font-size: 18px;
                        text-shadow: 0 0 5px rgba(76, 175, 80, 0.5);
                        z-index: 1000;
                    `;
                    playerInstructions.innerHTML = `Player - Enhanced Horror Effects Active`;
                    document.body.appendChild(playerInstructions);
                }

                // Hide guide view for all 3D roles (player, monster only, not architect)
                const guideView = document.getElementById('guideView');
                if (guideView) {
                    guideView.style.display = 'none';
                }
                
                // Generate maze geometry
                mazeGroup = new THREE.Group();
                generateNewMaze();
                
                // Set up controls
                controls = setupControls();
                
                // ALWAYS start animation for 3D views to prevent black screen
                console.log('üé¨ Starting animation for 3D view...', {
                    playerRole: playerRole,
                    sceneExists: !!scene,
                    rendererExists: !!renderer,
                    cameraExists: !!camera,
                    mazeExists: !!maze,
                    sceneChildren: scene?.children.length || 0
                });
                animate();
                
                // Set initial game state - controls will be enabled when game is ready
                gameStarted = shouldStartAnimation;
                if (shouldStartAnimation) {
                    console.log('üé¨ Game fully started with controls enabled');
                    
                    // Request pointer lock for player and monster, but not architect - DISABLED
                    // if (playerRole !== 'architect') {
                    //     renderer.domElement.requestPointerLock();
                    //     console.log('üé¨ Pointer lock requested');
                    // }
                } else {
                    console.log('üé¨ Scene initialized, controls will be enabled when all players ready');
                }
                
                if (playerRole !== 'architect') {
                    console.log('Game initialized in mode:', gameMode, 'role:', playerRole, 'with first-person view');
                }
                
                // Mark as initialized for 3D roles
                if (playerRole === 'player' || playerRole === 'monster') {
                    isInitialized = true;
                    console.log('üéØ 3D initialization completed for:', playerRole);
                    
                    // Add any pending player representations that were waiting for scene
                    addPendingPlayers();
                }
            } catch (error) {
                console.error('‚ùå Error initializing game:', error);
                // Show detailed error information
                const errorDiv = document.createElement('div');
                errorDiv.style.cssText = `
                    position: fixed;
                    top: 50%;
                    left: 50%;
                    transform: translate(-50%, -50%);
                    background: rgba(0, 0, 0, 0.9);
                    color: white;
                    padding: 20px;
                    border-radius: 10px;
                    text-align: center;
                    z-index: 9999;
                    max-width: 80%;
                `;
                errorDiv.innerHTML = `
                    <h3>üö® Game Initialization Error</h3>
                    <p>Role: ${playerRole || 'Unknown'}</p>
                    <p>Maze available: ${!!maze ? 'Yes' : 'No'}</p>
                    <p>Scene exists: ${!!scene ? 'Yes' : 'No'}</p>
                    <p>Error: ${error.message}</p>
                    <button onclick="location.reload()" style="margin-top: 15px; padding: 10px 20px; background: #ff4444; color: white; border: none; border-radius: 5px; cursor: pointer;">
                        Reload Game
                    </button>
                `;
                document.body.appendChild(errorDiv);
            }
        }

        function generateNewMaze() {
            if (mazeGroup) {
                // Remove all objects from the scene
                while(scene.children.length > 0){ 
                    scene.remove(scene.children[0]); 
                }
                mazeGroup = new THREE.Group();
            }

            // Initialize maze.wallPositions array
            if (!maze.wallPositions) {
                maze.wallPositions = [];
            }

            mazeGroup = new THREE.Group();
            
            // Add static lights in a sparser grid pattern
            const mazeWidth = MAZE_SIZE.width * maze.cellSize;
            const mazeHeight = MAZE_SIZE.height * maze.cellSize;
            
            // Calculate positions for a few strategic lights
            const lights = [
                // Center light
                {x: 0, z: 0, intensity: 8.0, distance: 70},
                
                // Four quadrant lights
                {x: -mazeWidth/4, z: -mazeHeight/4, intensity: 6.0, distance: 50},
                {x: mazeWidth/4, z: -mazeHeight/4, intensity: 6.0, distance: 50},
                {x: -mazeWidth/4, z: mazeHeight/4, intensity: 6.0, distance: 50},
                {x: mazeWidth/4, z: mazeHeight/4, intensity: 6.0, distance: 50},
                
                // Additional corner lights
                {x: -mazeWidth/2, z: -mazeHeight/2, intensity: 5.0, distance: 40},
                {x: mazeWidth/2, z: -mazeHeight/2, intensity: 5.0, distance: 40},
                {x: -mazeWidth/2, z: mazeHeight/2, intensity: 5.0, distance: 40},
                {x: mazeWidth/2, z: mazeHeight/2, intensity: 5.0, distance: 40}
            ];
            
            // Atmospheric lighting setup - brighter but still moody
            const ambientLight = new THREE.AmbientLight(0x666666, 0.5); // Brighter ambient light
            scene.add(ambientLight);
            
            // Main directional light for better visibility
            const directionalLight = new THREE.DirectionalLight(0x888888, 0.6);
            directionalLight.position.set(10, 20, 10);
            directionalLight.target.position.set(0, 0, 0);
            scene.add(directionalLight);
            scene.add(directionalLight.target);
            
            // Add red flickering lights in a regular grid pattern
            const flickeringLights = [];
            const lightGridWidth = MAZE_SIZE.width * maze.cellSize;
            const lightGridHeight = MAZE_SIZE.height * maze.cellSize;
            
            // Create a grid of red flickering lights every 4 blocks
            const spacing = maze.cellSize * 4; // Every 4 blocks
            
            for (let x = -lightGridWidth/2; x <= lightGridWidth/2; x += spacing) {
                for (let z = -lightGridHeight/2; z <= lightGridHeight/2; z += spacing) {
                    const flickerLight = new THREE.PointLight(0xff0000, 2.5, 30); // Red lights
                    flickerLight.position.set(x, 6, z); // Fixed height
                    
                    flickeringLights.push({
                        light: flickerLight,
                        baseIntensity: 2.5,
                        isOn: Math.random() > 0.5, // Random initial state
                        lastChange: 0,
                        changeInterval: 100 + Math.random() * 500 // Random timing
                    });
                    scene.add(flickerLight);
                }
            }
            
            console.log(`üî• Added ${flickeringLights.length} red flickering lights in grid pattern`);
            
            // Store flickering lights globally for animation
            window.flickeringLights = flickeringLights;

            // Load wall texture with error handling
            const wallTexture = textureLoader.load(
                'wall.jpg',
                function(texture) {
                    console.log('‚úÖ Wall texture loaded successfully');
                },
                undefined,
                function(error) {
                    console.error('‚ùå Error loading wall texture:', error);
                }
            );
            wallTexture.wrapS = wallTexture.wrapT = THREE.RepeatWrapping;
            wallTexture.repeat.set(1, 1);

            // Create wall geometry and material only once for better performance
            const wallGeometry = new THREE.BoxGeometry(maze.cellSize, maze.wallHeight, maze.cellSize);
            const wallMaterial = new THREE.MeshPhongMaterial({
                map: wallTexture,
                color: 0xffffff, // Bright white to show textures clearly
                specular: 0x444444,
                shininess: 15,
                transparent: false,
                opacity: 1.0,
                side: THREE.FrontSide,
                depthWrite: true,
                depthTest: true
            });

            // Create architect wall material for reuse
            const architectWallTexture = textureLoader.load('wall.jpg');
            architectWallTexture.wrapS = architectWallTexture.wrapT = THREE.RepeatWrapping;
            architectWallTexture.repeat.set(1, 1);
            
            architectWallMaterial = new THREE.MeshPhongMaterial({
                map: architectWallTexture,
                color: 0xff0000, // Red color for architect walls
                specular: 0x222222,
                shininess: 10,
                transparent: false,
                opacity: 1.0,
                side: THREE.FrontSide,
                depthWrite: true,
                depthTest: true
            });

            // Clear existing walls array
            maze.wallPositions = [];

            function addWall(x, z) {
                const wall = new THREE.Mesh(wallGeometry, wallMaterial);
                wall.position.set(x * maze.cellSize, maze.wallHeight / 2, z * maze.cellSize);
                wall.castShadow = true;
                wall.receiveShadow = true;
                wall.matrixAutoUpdate = false; // Optimize performance
                wall.userData = { gridX: x, gridZ: z }; // Store grid coordinates for architect functionality
                wall.updateMatrix();
                mazeGroup.add(wall);
                
                maze.wallPositions.push({ x: x * maze.cellSize, z: z * maze.cellSize });
            }

            // Clear existing walls
            while(mazeGroup.children.length > 0) {
                const obj = mazeGroup.children[0];
                obj.geometry.dispose();
                obj.material.dispose();
                mazeGroup.remove(obj);
            }

            // Add maze walls
            for (let y = 0; y < MAZE_SIZE.height; y++) {
                for (let x = 0; x < MAZE_SIZE.width; x++) {
                    if (maze.maze[y][x] === 1) {
                        addWall(x, y);
                    }
                }
            }

            // Add boundary walls
            for (let x = -1; x <= MAZE_SIZE.width; x++) {
                addWall(x, -1);
                addWall(x, MAZE_SIZE.height);
            }

            for (let z = -1; z <= MAZE_SIZE.height; z++) {
                addWall(-1, z);
                addWall(MAZE_SIZE.width, z);
            }

            // Add textured floor
            const floorGeometry = new THREE.PlaneGeometry(
                (MAZE_SIZE.width + 2) * maze.cellSize,
                (MAZE_SIZE.height + 2) * maze.cellSize
            );
            
            // Load floor texture with error handling
            const floorTexture = textureLoader.load(
                'floor.webp',
                function(texture) {
                    console.log('‚úÖ Floor texture loaded successfully');
                },
                undefined,
                function(error) {
                    console.error('‚ùå Error loading floor texture:', error);
                }
            );
            floorTexture.wrapS = floorTexture.wrapT = THREE.RepeatWrapping;
            floorTexture.repeat.set(4, 4); // Reduced tiling for better visibility
            
            const floorMaterial = new THREE.MeshPhongMaterial({
                map: floorTexture,
                color: 0xffffff, // Bright white to show texture clearly
                specular: 0x333333,
                shininess: 20,
                side: THREE.FrontSide,
                depthWrite: true
            });
            const floor = new THREE.Mesh(floorGeometry, floorMaterial);
            floor.rotation.x = -Math.PI / 2;
            floor.position.set(
                (MAZE_SIZE.width * maze.cellSize) / 2,
                0,
                (MAZE_SIZE.height * maze.cellSize) / 2
            );
            mazeGroup.add(floor);

            // Dark patches will be added dynamically when walls are removed

            // Add textured ceiling
            const ceilingGeometry = new THREE.PlaneGeometry(
                (MAZE_SIZE.width + 2) * maze.cellSize,
                (MAZE_SIZE.height + 2) * maze.cellSize
            );
            
            // Load ceiling texture with error handling
            const ceilingTexture = textureLoader.load(
                'ceiling.jpg',
                function(texture) {
                    console.log('‚úÖ Ceiling texture loaded successfully');
                },
                undefined,
                function(error) {
                    console.error('‚ùå Error loading ceiling texture:', error);
                    // Create fallback pattern texture if loading fails
                    ceilingTexture.image = createFallbackTexture('#8B4513', '#A0522D');
                    ceilingTexture.needsUpdate = true;
                }
            );
            ceilingTexture.wrapS = ceilingTexture.wrapT = THREE.RepeatWrapping;
            ceilingTexture.repeat.set(3, 3); // Reduced tiling for better visibility
            
            const ceilingMaterial = new THREE.MeshPhongMaterial({
                map: ceilingTexture,
                color: 0xffffff, // Bright white
                specular: 0x222222,
                shininess: 10,
                side: THREE.DoubleSide, // Render both sides to ensure visibility
                depthWrite: true
            });
            const ceiling = new THREE.Mesh(ceilingGeometry, ceilingMaterial);
            ceiling.rotation.x = -Math.PI / 2; // Face downward correctly
            ceiling.position.set(
                (MAZE_SIZE.width * maze.cellSize) / 2,
                maze.wallHeight - 0.5, // Just below the top of walls
                (MAZE_SIZE.height * maze.cellSize) / 2
            );
            mazeGroup.add(ceiling);

            // Add end marker with improved material
            const endMarkerGeometry = new THREE.CylinderGeometry(0.4, 0.4, 0.1, 32);
            const endMarkerMaterial = new THREE.MeshPhongMaterial({ 
                color: 0x00ff00,
                emissive: 0x00ff00,
                emissiveIntensity: 0.5,
                transparent: false,
                opacity: 1.0,
                depthWrite: true
            });
            const endMarker = new THREE.Mesh(endMarkerGeometry, endMarkerMaterial);
            
            // Place end marker at the correct world position (don't multiply by cellSize again)
            endMarker.position.set(
                maze.endPosition.x,
                0.05,
                maze.endPosition.z
            );
            
            // Add point light to end marker for glow
            const endLight = new THREE.PointLight(0x00ff00, 1, 5);
            endLight.position.copy(endMarker.position);
            endLight.position.y = 1;
            
            mazeGroup.add(endMarker);
            mazeGroup.add(endLight);

            // Add the entire maze group to the scene
            scene.add(mazeGroup);
        }

        function checkCollision(position) {
            if (!maze || !maze.wallPositions || !Array.isArray(maze.wallPositions)) {
                console.log('Maze or wall positions not properly initialized');
                return { x: false, z: false };
            }

            const playerRadius = 0.5;
            const wallBuffer = 0.3;
            let collisionX = false;
            let collisionZ = false;
            let nearestWallDist = Infinity;
            let slideX = 0;
            let slideZ = 0;
            
            // Check collision with each wall
            for (const wall of maze.wallPositions) {
                // Calculate distances for each axis
                const dx = position.x - wall.x;
                const dz = position.z - wall.z;
                const distance = Math.sqrt(dx * dx + dz * dz);
                
                // Calculate the minimum distance needed to avoid collision
                const minDistance = maze.cellSize / 2 + playerRadius + wallBuffer;
                
                // If we're within collision range
                if (distance < minDistance) {
                    // Update nearest wall distance
                    if (distance < nearestWallDist) {
                        nearestWallDist = distance;
                        
                        // Calculate normalized direction from wall to player
                        const nx = dx / distance;
                        const nz = dz / distance;
                        
                        // Calculate slide vector
                        const penetration = minDistance - distance;
                        slideX = nx * penetration;
                        slideZ = nz * penetration;
                    }
                    
                    // Set collision flags based on approach angle
                    const dotX = Math.abs(dx / distance);
                    const dotZ = Math.abs(dz / distance);
                    
                    if (dotX > 0.7) collisionX = true;
                    if (dotZ > 0.7) collisionZ = true;
                }
            }
            
            return {
                x: collisionX,
                z: collisionZ,
                slideX: slideX,
                slideZ: slideZ
            };
        }

        function setupControls() {
            const moveSpeed = playerRole === 'architect' ? 0.2 : 0.15; // Same speed for monster and player
            const turnSpeed = 0.06;
            let isPointerLocked = false;
            
            const controls = {
                enabled: true,
                update: null
            };
            
            const keys = {
                forward: false,
                backward: false,
                left: false,
                right: false
            };

            // Remove any existing listeners
            if (keydownListener) document.removeEventListener('keydown', keydownListener);
            if (keyupListener) document.removeEventListener('keyup', keyupListener);

            function onMouseMove(event) {
                if (isPointerLocked && (playerRole === 'player' || playerRole === 'monster')) {
                    camera.rotation.y -= event.movementX * 0.002;
                }
                // Architect doesn't need mouse look - they have fixed overhead view
            }

            function onPointerLockChange() {
                isPointerLocked = document.pointerLockElement === renderer.domElement;
            }

            function onPointerLockError() {
                console.error('Pointer lock error');
            }

            document.addEventListener('pointerlockchange', onPointerLockChange);
            document.addEventListener('pointerlockerror', onPointerLockError);
            document.addEventListener('mousemove', onMouseMove);

            if (renderer && renderer.domElement) {
                renderer.domElement.addEventListener('click', (event) => {
                                    // Architect uses 2D view, so no 3D clicking
                if (playerRole !== 'architect') {
                        // Mouse lock disabled - user prefers free mouse movement
                    }
                });
                
                // Handle right-click for 3D view only (architect uses 2D)
                renderer.domElement.addEventListener('contextmenu', (event) => {
                    if (playerRole !== 'architect') {
                        // Only handle 3D right-click for non-architects
                    }
                });
            }

            document.addEventListener('keydown', (e) => {
                if (e.key === 'Escape' && isPointerLocked) {
                    document.exitPointerLock();
                }
            });

            keydownListener = (e) => {
                // Debug key presses for player and monster
                if ((playerRole === 'player' || playerRole === 'monster') && ['w','s','a','d','arrowup','arrowdown','arrowleft','arrowright'].includes(e.key.toLowerCase())) {
                    console.log(`üîß ${playerRole.toUpperCase()} key pressed:`, e.key, 'Role:', playerRole);
                }
                
                switch(e.key.toLowerCase()) {
                    case 'w':
                    case 'arrowup':
                        keys.forward = true;
                        break;
                    case 's':
                    case 'arrowdown':
                        keys.backward = true;
                        break;
                    case 'a':
                    case 'arrowleft':
                        keys.left = true;
                        break;
                    case 'd':
                    case 'arrowright':
                        keys.right = true;
                        break;
                }
            };

            keyupListener = (e) => {
                switch(e.key.toLowerCase()) {
                    case 'w':
                    case 'arrowup':
                        keys.forward = false;
                        break;
                    case 's':
                    case 'arrowdown':
                        keys.backward = false;
                        break;
                    case 'a':
                    case 'arrowleft':
                        keys.left = false;
                        break;
                    case 'd':
                    case 'arrowright':
                        keys.right = false;
                        break;
                }
            };

            document.addEventListener('keydown', keydownListener);
            document.addEventListener('keyup', keyupListener);

            controls.update = function updateControls() {
                if (!controls.enabled || !camera || !maze) {
                    // Debug why controls aren't updating
                    if (playerRole === 'monster' && animateDebugCount < 5) {
                        console.log('üêõ Monster controls update blocked:', {
                            enabled: controls.enabled,
                            camera: !!camera,
                            maze: !!maze,
                            playerRole: playerRole
                        });
                    }
                    return;
                }

                const moveSpeed = 0.15; // Same speed for both monster and player
                const turnSpeed = 0.06;
                const newPosition = camera.position.clone();
                const oldPosition = camera.position.clone();
                
                // Debug movement for both roles
                if (animateDebugCount === 2) {
                    console.log('üêõ', playerRole, 'controls update running! Speed:', moveSpeed, 'Position:', camera.position);
                    if (playerRole === 'player' || playerRole === 'monster') {
                        console.log(`üîß ${playerRole.toUpperCase()} controls state:`, {
                            enabled: controls.enabled,
                            keysPressed: Object.entries(keys).filter(([k,v]) => v),
                            position: {x: camera.position.x, z: camera.position.z}
                        });
                    }
                }

                // First-person movement for player and monster (WITH collision detection)
                let moveVector = new THREE.Vector3(0, 0, 0);
                    if (keys.forward) {
                        moveVector.x -= Math.sin(camera.rotation.y) * moveSpeed;
                        moveVector.z -= Math.cos(camera.rotation.y) * moveSpeed;
                    }
                    if (keys.backward) {
                        moveVector.x += Math.sin(camera.rotation.y) * moveSpeed;
                        moveVector.z += Math.cos(camera.rotation.y) * moveSpeed;
                    }
                    if (keys.left) {
                        camera.rotation.y += turnSpeed;
                    }
                    if (keys.right) {
                        camera.rotation.y -= turnSpeed;
                    }
                    
                    // Apply movement and check collision for non-architects
                    if (moveVector.length() > 0) {
                        // Try to move to new position
                        const targetPos = {
                            x: newPosition.x + moveVector.x,
                            z: newPosition.z + moveVector.z
                        };
                        
                        // Check collision at target position
                        const collision = checkCollision(targetPos);
                        
                        // If there's a collision, try to slide along walls
                        if (collision.x || collision.z) {
                            if (!collision.x) newPosition.x = targetPos.x;
                            if (!collision.z) newPosition.z = targetPos.z;
                            
                            // Apply sliding motion if available
                            if (collision.slideX || collision.slideZ) {
                                newPosition.x += collision.slideX * 0.5;
                                newPosition.z += collision.slideZ * 0.5;
                            }
                        } else {
                            // No collision, move freely
                            newPosition.x = targetPos.x;
                            newPosition.z = targetPos.z;
                        }
                    }

                // Update position and send update if changed
                camera.position.copy(newPosition);
                
                // Debug successful movement (once)
                if ((camera.position.x !== oldPosition.x || camera.position.z !== oldPosition.z) && animateDebugCount === 1) {
                    console.log('‚úÖ MOVEMENT WORKING for', playerRole, '! Position:', {x: camera.position.x, z: camera.position.z});
                }
                
                if (camera.position.x !== oldPosition.x || camera.position.z !== oldPosition.z) {
                    if (multiplayerManager && multiplayerManager.connected) {
                        multiplayerManager.sendPosition(camera.position, camera.rotation);
                    }
                }
            };

            return controls;
        }

        function showWinScreen() {
            document.getElementById('winScreen').style.display = 'block';
            // Reset game state
            gameStarted = false;
        }

        // Show the multiplayer menu
        function showMultiplayerMenu() {
            console.log('Showing multiplayer menu');
            if (gameStarted) {
                console.log('Game in progress, cleaning up first');
                cleanupRenderer();
                cleanupMultiplayer();
            }
            
            gameStarted = false;
            gameMode = 'single'; // Reset game mode
            hideAllMenus();
            document.getElementById('multiplayerMenu').style.display = 'block';
            document.getElementById('createRoomButton').style.display = 'block';
            document.getElementById('joinRoomButton').style.display = 'block';
        }

        // Show join room input
        function showJoinRoom() {
            document.getElementById('createRoomButton').style.display = 'none';
            document.getElementById('joinRoomButton').style.display = 'none';
            document.getElementById('roomCodeInput').style.display = 'block';
            document.getElementById('roomCodeInput').value = '';
        }

        function joinRoom() {
            const roomCode = document.getElementById('roomCodeInput').value.trim().toUpperCase();
            if (!roomCode) {
                alert('Please enter a room code');
                return;
            }

            showLoadingScreen('Joining Room...');
            console.log('Attempting to join room:', roomCode);
            
            // Initialize multiplayer manager
            multiplayerManager = new MultiplayerManager();
            
            // Set up callbacks
            multiplayerManager.onConnectionSuccess = () => {
                console.log('Successfully connected to server, attempting to join room:', roomCode);
                multiplayerManager.joinRoom(roomCode);
            };

            multiplayerManager.onMazeDataReceived = (mazeData) => {
                console.log('üó∫Ô∏è Maze data received and loaded!', mazeData);
                maze = mazeData;
                maze.wallPositions = maze.wallPositions || [];
                
                // Now that we have maze data, we can safely initialize the scene
                // But only if we have a proper role assigned
                console.log('üé¨ Maze data received (joinRoom), checking if ready to initialize...');
                console.log('üé¨ Current playerRole:', playerRole, 'isHost:', multiplayerManager?.isHost);
                if (playerRole && playerRole !== 'waiting') {
                    console.log('üé¨ Role assigned, initializing scene...');
                    if (playerRole === 'guide' || playerRole === 'architect') {
                        console.log('üéÆ Initializing 2D view for:', playerRole);
                        initGuideView(mazeData);
                        if (playerRole === 'architect') {
                            try {
                                setupArchitectControls();
                            } catch (error) {
                                console.error('Error setting up architect controls:', error);
                            }
                        }
                    } else {
                        init(false);
                    }
                } else {
                    console.log('üîÑ Waiting for role assignment before initializing scene...');
                }
            };

            multiplayerManager.onRoomJoined = () => {
                console.log('Successfully joined room:', roomCode);
                hideLoadingScreen();
                
                // Hide all menus
                hideAllMenus();
                
                // Show simple waiting message
                const waitingDiv = document.createElement('div');
                waitingDiv.id = 'simple-waiting';
                waitingDiv.style.cssText = `
                    position: fixed;
                    top: 50%;
                    left: 50%;
                    transform: translate(-50%, -50%);
                    color: white;
                    font-size: 24px;
                    text-align: center;
                    z-index: 1000;
                `;
                waitingDiv.innerHTML = 'Waiting for players...';
                document.body.appendChild(waitingDiv);
                
                // Set the game mode but don't start yet
                gameMode = 'multiplayer';
                playerRole = 'waiting';
                allPlayersJoined = false;
                gameStarted = false;
                
                console.log('üè† Room joined, showing simple waiting message...');
            };

            // Add the same event handlers as createRoom
            multiplayerManager.onPlayerJoined = (playerId, role) => {
                console.log('Player joined:', playerId, 'as', role);
                
                // For joinRoom, just wait silently - no UI updates needed
                const currentPlayers = Object.keys(otherPlayers).length + 2;
                const playersNeeded = requiredPlayers - currentPlayers;
                
                if (playersNeeded > 0) {
                    console.log(`Waiting for ${playersNeeded} more player${playersNeeded > 1 ? 's' : ''} to join...`);
                } else {
                    console.log('All players joined! Waiting for role assignment...');
                }
            };

            multiplayerManager.onRoleAssigned = (role, message) => {
                console.log('üé≠ Role assigned:', role, message);
                playerRole = role;
                
                // Remove simple waiting message if it exists
                const simpleWaiting = document.getElementById('simple-waiting');
                if (simpleWaiting) {
                    simpleWaiting.remove();
                }
                
                // Hide role assignment screen and show your role screen
                document.getElementById('roleAssignmentScreen').style.display = 'none';
                document.getElementById('yourRoleScreen').style.display = 'block';
                
                // Update role information
                document.getElementById('assignedRole').textContent = role.toUpperCase();
                
                // Set role descriptions
                let description = '';
                switch(role) {
                    case 'player':
                        description = 'Navigate through the maze to find the green exit. Use WASD to move and mouse to look around. Avoid the monster!';
                        break;
                    case 'guide':
                        description = 'Help the player reach the exit using your top-down 2D view. You can see the entire maze layout and all player positions.';
                        break;
                    case 'architect':
                        description = 'Architect: Click to add/remove walls.';
                        break;
                    case 'monster':
                        description = 'Hunt the player in first-person view! Use WASD to move and mouse to look around. Catch the player before they escape!';
                        break;
                    default:
                        description = message || 'Unknown role';
                }
                document.getElementById('roleDescription').textContent = description;
                
                // DON'T initialize the scene yet - wait for onGameReady
                console.log('üé≠ Role assigned, waiting for game ready signal...');
            };

            multiplayerManager.onGameReady = () => {
                console.log('üéÆ onGameReady called - Current role:', playerRole, 'Maze exists:', !!maze);
                allPlayersJoined = true;
                gameStarted = true;
                
                // Hide all UI screens
                hideAllMenus();
                
                // Wait for maze data if not available
                if (!maze) {
                    console.log('üéÆ No maze data yet, waiting...');
                    setTimeout(() => {
                        if (maze) {
                            console.log('üéÆ Maze data now available, starting game');
                            multiplayerManager.onGameReady();
                        } else {
                            console.error('üéÆ Still no maze data after waiting');
                        }
                    }, 100);
                    return;
                }
                
                // Add a 3-second countdown before starting
                setTimeout(() => {
                    // Force game start based on role
                    console.log('üéÆ Starting game for role:', playerRole);
                    if (playerRole === 'guide') {
                        console.log('üéÆ Starting GUIDE view (2D only)');
                        initGuideView(maze);
                    } else if (playerRole === 'architect') {
                        console.log('üéÆ Starting ARCHITECT view (2D with wall editing)');
                        console.log('üèóÔ∏è ARCHITECT INITIALIZATION - Maze data:', !!maze, 'Guide canvas:', !!guideCanvas);
                        // Architect gets 2D view with wall editing
                        initGuideView(maze);
                        
                        // Setup architect click controls
                        try {
                            console.log('üèóÔ∏è CALLING setupArchitectControls...');
                            setupArchitectControls();
                            console.log('üèóÔ∏è setupArchitectControls COMPLETED!');
                        } catch (error) {
                            console.error('‚ùå Error in architect setup:', error);
                            console.error('‚ùå Error stack:', error.stack);
                        }
                    } else if (playerRole === 'player' || playerRole === 'monster') {
                        console.log('üéÆ Starting 3D view for:', playerRole);
                        console.log('üéÆ Pre-start state check:', {
                            playerRole: playerRole,
                            controlsExist: !!controls,
                            sceneExists: !!scene,
                            cameraExists: !!camera,
                            isInitialized: isInitialized,
                            gameStartedBefore: gameStarted
                        });
                        
                        // Ensure scene is initialized first
                        if (!isInitialized || !scene || !controls) {
                            console.log('üîß Scene not ready, initializing now...');
                            init(true); // Initialize with game started
                        } else {
                            console.log('üîß Scene ready, just enabling controls...');
                            gameStarted = true;
                            if (controls) {
                                controls.enabled = true;
                            }
                            
                            // Request pointer lock for player and monster - DISABLED
                            // if (renderer && renderer.domElement) {
                            //     renderer.domElement.requestPointerLock();
                            //     console.log('üé¨ Pointer lock requested for game start');
                            // }
                        }
                        
                        // FORCED FIX: Ensure controls are definitely enabled for movement
                        setTimeout(() => {
                            if (controls) {
                                controls.enabled = true;
                                gameStarted = true;
                                console.log('üîß FORCED control enablement for', playerRole, '- Controls enabled:', controls.enabled, 'Game started:', gameStarted);
                                
                                // Extra debug for player role
                                if (playerRole === 'player') {
                                    console.log('üîß PLAYER SPECIFIC DEBUG:', {
                                        controlsExists: !!controls,
                                        controlsEnabled: controls.enabled,
                                        gameStarted: gameStarted,
                                        cameraExists: !!camera,
                                        mazeExists: !!maze,
                                        sceneExists: !!scene,
                                        isInitialized: isInitialized
                                    });
                                }
                            } else {
                                console.error('‚ùå NO CONTROLS OBJECT FOUND for', playerRole, '!');
                                // Try to create controls if missing
                                if (scene && camera && maze) {
                                    console.log('üîß Attempting to create missing controls for', playerRole);
                                    controls = setupControls();
                                    if (controls) {
                                        controls.enabled = true;
                                        gameStarted = true;
                                        console.log('‚úÖ Successfully created controls for', playerRole);
                                    }
                                }
                            }
                        }, 500);
                        
                        console.log('üéÆ Game controls should now be ENABLED for:', playerRole);
                    } else {
                        console.log('üéÆ Unknown role:', playerRole);
                    }
                }, 3000);
            };

            multiplayerManager.onError = (error) => {
                console.error('Error joining room:', error);
                hideLoadingScreen();
                alert('Error joining room: ' + error);
                showMultiplayerMenu();
            };

            // Start connection
            multiplayerManager.connect();
        }

        function showLoadingScreen(message = 'Loading Game...') {
            document.getElementById('loadingMessage').textContent = message;
            document.getElementById('loadingScreen').style.display = 'block';
        }

        function hideLoadingScreen() {
            document.getElementById('loadingScreen').style.display = 'none';
        }

        function setupMultiplayer() {
            console.log('Setting up multiplayer components with role:', playerRole);
            
            // Create other player representation based on role
            if (playerRole === 'player' || playerRole === 'monster') {
                let otherPlayerMesh;
                if (playerRole === 'monster') {
                    // Create player representation for monster's view
                    const playerGeometry = new THREE.Group();
                    
                    // Main body - taller and brighter cylinder
                    const body = new THREE.Mesh(
                        new THREE.CylinderGeometry(0.4, 0.4, 2.5, 8),
                        new THREE.MeshPhongMaterial({ 
                            color: 0x00ff00,
                            emissive: 0x00ff00,
                            emissiveIntensity: 0.5
                        })
                    );
                    playerGeometry.add(body);
                    
                    // Add glowing ring at the top
                    const ring = new THREE.Mesh(
                        new THREE.TorusGeometry(0.5, 0.1, 8, 16),
                        new THREE.MeshPhongMaterial({
                            color: 0xffff00,
                            emissive: 0xffff00,
                            emissiveIntensity: 0.7
                        })
                    );
                    ring.position.y = 1.5;
                    ring.rotation.x = Math.PI / 2;
                    playerGeometry.add(ring);
                    
                    otherPlayerMesh = playerGeometry;
                } else {
                    // Monster representation for player's view
                    otherPlayerMesh = new THREE.Mesh(
                        new THREE.CylinderGeometry(0.3, 0.3, 2, 8),
                        new THREE.MeshPhongMaterial({ 
                            color: 0xff0000,
                            emissive: 0xff0000,
                            emissiveIntensity: 0.5
                        })
                    );
                }
                
                otherPlayers[multiplayerManager.playerId] = otherPlayerMesh;
                otherPlayers[multiplayerManager.playerId].position.set(0, 1, 0);
                otherPlayers[multiplayerManager.playerId].visible = true;
                scene.add(otherPlayers[multiplayerManager.playerId]);
            }

            // Set up multiplayer event handlers
            multiplayerManager.onPlayerJoined = (playerId, role) => {
                console.log('Player joined:', playerId, 'as', role);
                
                // Update player count for host's waiting screen
                if (multiplayerManager.isHost) {
                    // Initialize player count only once when first player joins
                    if (typeof window.playerJoinCount === 'undefined') {
                        window.playerJoinCount = 1; // Start with host
                    }
                    window.playerJoinCount++; // Add the newly joined player
                    
                    console.log('üî¢ Player count update - total players:', window.playerJoinCount);
                    const playerCountElement = document.getElementById('playerCount');
                    if (playerCountElement) {
                        playerCountElement.textContent = `Players joined: ${window.playerJoinCount}/4`;
                    }
                    
                    const playersNeeded = requiredPlayers - window.playerJoinCount;
                    const waitingMessageElement = document.getElementById('waitingMessage');
                    if (waitingMessageElement && playersNeeded > 0) {
                        waitingMessageElement.textContent = `Waiting for ${playersNeeded} more player${playersNeeded > 1 ? 's' : ''} to join...`;
                    } else if (waitingMessageElement && playersNeeded <= 0) {
                        // All players joined - show role assignment screen
                        document.getElementById('waitingScreen').style.display = 'none';
                        document.getElementById('roleAssignmentScreen').style.display = 'block';
                        waitingMessageElement.textContent = 'All players joined! Assigning roles...';
                    }
                }
                
                if (!otherPlayers[playerId] && (playerRole === 'player' || playerRole === 'monster')) {
                    console.log('Creating representation for player:', playerId, 'with role:', role);
                    
                    // Create a more visible representation for players
                    let playerMesh;
                    if (role === 'monster') {
                        // Monster representation
                        playerMesh = new THREE.Mesh(
                            new THREE.CylinderGeometry(0.3, 0.3, 2, 8),
                            new THREE.MeshPhongMaterial({ 
                                color: 0xff0000,
                                emissive: 0xff0000,
                                emissiveIntensity: 0.5
                            })
                        );
                    } else {
                        // Player representation - more visible for monster
                        const playerGeometry = new THREE.Group();
                        
                        // Main body - taller and brighter cylinder
                        const body = new THREE.Mesh(
                            new THREE.CylinderGeometry(0.4, 0.4, 2.5, 8),
                            new THREE.MeshPhongMaterial({ 
                                color: 0x00ff00,
                                emissive: 0x00ff00,
                                emissiveIntensity: 0.5
                            })
                        );
                        playerGeometry.add(body);
                        
                        // Add glowing ring at the top
                        const ring = new THREE.Mesh(
                            new THREE.TorusGeometry(0.5, 0.1, 8, 16),
                            new THREE.MeshPhongMaterial({
                                color: 0xffff00,
                                emissive: 0xffff00,
                                emissiveIntensity: 0.7
                            })
                        );
                        ring.position.y = 1.5;
                        ring.rotation.x = Math.PI / 2;
                        playerGeometry.add(ring);
                        
                        playerMesh = playerGeometry;
                    }
                    
                    otherPlayers[playerId] = playerMesh;
                    otherPlayers[playerId].position.set(0, 1, 0);
                    otherPlayers[playerId].visible = true;
                    scene.add(otherPlayers[playerId]);
                    
                    console.log('Added player representation to scene:', playerId);
                }
            };

            multiplayerManager.onPlayerLeft = (playerId) => {
                console.log('Player left:', playerId);
                if (otherPlayers[playerId]) {
                    scene.remove(otherPlayers[playerId]);
                    delete otherPlayers[playerId];
                }
            };

            multiplayerManager.onPlayerMove = (playerId, position, rotation) => {
                console.log('Received player move:', playerId, position, rotation);
                if (otherPlayers[playerId]) {
                    otherPlayers[playerId].visible = true;
                    otherPlayers[playerId].position.set(position.x, position.y, position.z);
                    otherPlayers[playerId].rotation.set(rotation.x, rotation.y, rotation.z);
                }
            };
        }

        function copyRoomCode(element) {
            const code = element.textContent;
            navigator.clipboard.writeText(code).then(() => {
                element.classList.add('copied');
                setTimeout(() => element.classList.remove('copied'), 500);
            });
        }

        function initGuideView(mazeData) {
            try {
                if (!mazeData) throw new Error('No maze data provided');
                console.log('üó∫Ô∏è Initializing guide view with maze data:', mazeData);

                // Update role title based on actual player role
                const roleTitleElement = document.getElementById('roleTitle');
                if (roleTitleElement) {
                    if (playerRole === 'architect') {
                        roleTitleElement.textContent = 'Architect View';
                    } else {
                        roleTitleElement.textContent = 'Guide View';
                    }
                }

                // Clean up
                if (renderer?.domElement?.parentNode) {
                    renderer.domElement.parentNode.removeChild(renderer.domElement);
                    renderer.dispose();
                }

                // Hide other screens
                ['startScreen', 'multiplayerMenu', 'winScreen', 'loadingScreen'].forEach(id => {
                    const element = document.getElementById(id);
                    if (element) element.style.display = 'none';
                });

                // Setup guide container
                const guideView = document.getElementById('guideView');
                guideView.style.cssText = `
                    position: fixed;
                    top: 0;
                    left: 0;
                    width: 100vw;
                    height: 100vh;
                    display: flex;
                    justify-content: center;
                    align-items: center;
                    background-color: #000000;
                `;
                guideView.style.display = 'block';

                // Setup canvas
                guideCanvas = document.getElementById('guideCanvas');
                guideCtx = guideCanvas.getContext('2d', { alpha: false });

                // Calculate optimal size
                const margin = 80;
                const maxWidth = window.innerWidth - margin * 2;
                const maxHeight = window.innerHeight - margin * 2;
                
                // Calculate cell size to maintain aspect ratio
                const mazeWidth = mazeData.maze[0].length;
                const mazeHeight = mazeData.maze.length;
                const cellSizeX = Math.floor(maxWidth / mazeWidth);
                const cellSizeY = Math.floor(maxHeight / mazeHeight);
                const cellSize = Math.min(cellSizeX, cellSizeY);

                // Set canvas size
                guideCanvas.width = mazeWidth * cellSize + margin * 2;
                guideCanvas.height = mazeHeight * cellSize + margin * 2;

                // Store settings globally
                window.guideViewConfig = {
                    cellSize,
                    margin,
                    mazeWidth,
                    mazeHeight,
                    worldCellSize: mazeData.cellSize
                };

                // Initial draw
                drawGuideView(mazeData, null, null);
                
                // Add architect-specific functionality
                if (playerRole === 'architect') {
                    // setupArchitectControls(); // Removed - will be called in onGameReady
                }
                
                // Start game timer if multiplayer
                if (gameMode === 'multiplayer') {
                    startGameTimer();
                }
                
                gameStarted = true;

            } catch (error) {
                console.error('Guide view error:', error);
                const msg = document.createElement('div');
                msg.style.cssText = 'position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);background:rgba(0,0,0,0.8);color:red;padding:20px;border-radius:10px;text-align:center;';
                msg.innerHTML = `Error: ${error.message}<br><button onclick="location.reload()" style="margin-top:15px;padding:10px;background:white;color:red;border:none;border-radius:5px;cursor:pointer;">Reload</button>`;
                document.body.appendChild(msg);
            }
        }

        function smoothPosition(current, last) {
            if (!last) return current;
            return {
                x: last.x + (current.x - last.x) * positionSmoothingFactor,
                y: last.y + (current.y - last.y) * positionSmoothingFactor,
                z: last.z + (current.z - last.z) * positionSmoothingFactor,
                rotation: {
                    x: last.rotation?.x + (current.rotation?.x - last.rotation?.x) * rotationSmoothingFactor || current.rotation?.x,
                    y: last.rotation?.y + (current.rotation?.y - last.rotation?.y) * rotationSmoothingFactor || current.rotation?.y,
                    z: last.rotation?.z + (current.rotation?.z - last.rotation?.z) * rotationSmoothingFactor || current.rotation?.z
                }
            };
        }

        function drawGuideView(mazeData, playerPos, monsterPos) {
            if (!mazeData || !mazeData.maze) return;
            
            const config = window.guideViewConfig;
            if (!config) return;

            // Apply position smoothing
            if (playerPos) {
                if (!lastPlayerPos) {
                    lastPlayerPos = { ...playerPos };
                } else {
                    playerPos = smoothPosition(playerPos, lastPlayerPos);
                    lastPlayerPos = { ...playerPos };
                }
            }
            
            if (monsterPos) {
                if (!lastMonsterPos) {
                    lastMonsterPos = { ...monsterPos };
                } else {
                    monsterPos = smoothPosition(monsterPos, lastMonsterPos);
                    lastMonsterPos = { ...monsterPos };
                }
            }

            const { cellSize, margin, worldCellSize } = config;

            // Create an off-screen canvas for double buffering
            const offscreenCanvas = document.createElement('canvas');
            offscreenCanvas.width = guideCanvas.width;
            offscreenCanvas.height = guideCanvas.height;
            const offscreenCtx = offscreenCanvas.getContext('2d', { alpha: false });
            
            // Enable image smoothing for smoother rendering
            offscreenCtx.imageSmoothing = true;
            offscreenCtx.imageSmoothingQuality = 'high';

            // Clear offscreen canvas with a solid color
            offscreenCtx.fillStyle = '#000000';
            offscreenCtx.fillRect(0, 0, offscreenCanvas.width, offscreenCanvas.height);

            // Draw floor with anti-aliasing
            offscreenCtx.fillStyle = '#e0e0e0';
            offscreenCtx.fillRect(
                Math.round(margin),
                Math.round(margin),
                Math.round(mazeData.maze[0].length * cellSize),
                Math.round(mazeData.maze.length * cellSize)
            );

            // Draw walls with special colors for architect changes - flip the z-axis by using (mazeData.maze.length - 1 - z)
            for (let z = 0; z < mazeData.maze.length; z++) {
                for (let x = 0; x < mazeData.maze[z].length; x++) {
                    const coordKey = `${x},${z}`;
                    const canvasX = (mazeData.maze[z].length - 1 - x) * cellSize + margin;
                    const canvasY = (mazeData.maze.length - 1 - z) * cellSize + margin;
                    
                    if (mazeData.maze[z][x] === 1) {
                        // Check if this is an architect-added wall
                        if (window.architectWallChanges?.added.has(coordKey)) {
                            offscreenCtx.fillStyle = '#ff0000'; // Red for architect-added walls
                        } else {
                            offscreenCtx.fillStyle = '#1a1a1a'; // Very dark gray for original walls
                        }
                        offscreenCtx.fillRect(canvasX, canvasY, cellSize, cellSize);
                    } else {
                        // Check if this is an architect-removed area
                        if (window.architectWallChanges?.removed.has(coordKey)) {
                            offscreenCtx.fillStyle = '#bbbbbb'; // Light grey for removed walls
                            offscreenCtx.fillRect(canvasX, canvasY, cellSize, cellSize);
                        }
                    }
                }
            }

            // Draw exit - flip both x and z coordinates
            const exitX = Math.floor((mazeData.maze[0].length - 1 - (mazeData.endPosition.x / worldCellSize))) * cellSize + margin;
            const exitZ = Math.floor(mazeData.maze.length - 1 - (mazeData.endPosition.z / worldCellSize)) * cellSize + margin;
            
            // Draw exit marker with glow effect
            offscreenCtx.shadowColor = '#4CAF50';
            offscreenCtx.shadowBlur = 15;
            offscreenCtx.fillStyle = '#4CAF50';
            offscreenCtx.fillRect(exitX - cellSize/4, exitZ - cellSize/4, cellSize/2, cellSize/2);

            // Draw player position if available
            if (playerPos && typeof playerPos.x === 'number' && typeof playerPos.z === 'number') {
                const squareSize = cellSize * 0.6;
                
                // Calculate canvas coordinates for player
                const canvasX = ((mazeData.maze[0].length - 1) - (playerPos.x / worldCellSize)) * cellSize + margin + cellSize/2;
                const canvasZ = ((mazeData.maze.length - 1) - (playerPos.z / worldCellSize)) * cellSize + margin + cellSize/2;
                
                // Draw player marker
                offscreenCtx.shadowColor = '#2196F3';
                offscreenCtx.shadowBlur = 10;
                offscreenCtx.strokeStyle = '#2196F3';
                offscreenCtx.lineWidth = 3;
                
                // Draw player square
                offscreenCtx.strokeRect(
                    canvasX - squareSize/2,
                    canvasZ - squareSize/2,
                    squareSize,
                    squareSize
                );

                // Direction indicator removed - was causing flickering
            }

            // Draw monster position if available
            if (monsterPos && typeof monsterPos.x === 'number' && typeof monsterPos.z === 'number') {
                const diamondSize = cellSize * 0.6;
                
                // Calculate canvas coordinates for monster
                const canvasX = ((mazeData.maze[0].length - 1) - (monsterPos.x / worldCellSize)) * cellSize + margin + cellSize/2;
                const canvasZ = ((mazeData.maze.length - 1) - (monsterPos.z / worldCellSize)) * cellSize + margin + cellSize/2;
                
                // Draw monster marker
                offscreenCtx.shadowColor = '#ff0000';
                offscreenCtx.shadowBlur = 10;
                offscreenCtx.strokeStyle = '#ff0000';
                offscreenCtx.lineWidth = 3;
                
                // Draw diamond shape
                offscreenCtx.beginPath();
                offscreenCtx.moveTo(canvasX, canvasZ - diamondSize/2);
                offscreenCtx.lineTo(canvasX + diamondSize/2, canvasZ);
                offscreenCtx.lineTo(canvasX, canvasZ + diamondSize/2);
                offscreenCtx.lineTo(canvasX - diamondSize/2, canvasZ);
                offscreenCtx.closePath();
                offscreenCtx.stroke();
            }

            // Reset shadow
            offscreenCtx.shadowBlur = 0;

            // Copy the offscreen canvas to the visible canvas
            guideCtx.clearRect(0, 0, guideCanvas.width, guideCanvas.height);
            guideCtx.drawImage(offscreenCanvas, 0, 0);
        }

        function setupArchitectControls() {
            // Prevent duplicate setup
            if (window.architectControlsSetup) {
                console.log('Architect controls already set up, skipping...');
                return;
            }
            window.architectControlsSetup = true;
            console.log('Setting up architect controls...');
            
            // Create cooldown indicator
            const cooldownIndicator = document.createElement('div');
            cooldownIndicator.id = 'architectCooldown';
            cooldownIndicator.style.cssText = `
                position: fixed;
                top: 20px;
                left: 50%;
                transform: translateX(-50%);
                background: rgba(255, 69, 0, 0.9);
                color: white;
                padding: 10px 20px;
                border-radius: 20px;
                font-size: 18px;
                font-weight: bold;
                z-index: 10000;
                display: none;
                text-shadow: 0 0 5px rgba(0, 0, 0, 0.5);
                box-shadow: 0 4px 15px rgba(255, 69, 0, 0.4);
                pointer-events: none;
            `;
            document.body.appendChild(cooldownIndicator);
            
            // Instructions panel disabled - user prefers clean interface
            // const instructions = document.createElement('div');
            // instructions.id = 'architectInstructions';
            // instructions.style.cssText = `... (disabled)`;
            // document.body.appendChild(instructions);
            
            // Add click handlers to guide canvas
            console.log('üèóÔ∏è Setting up architect controls for canvas:', guideCanvas);
            console.log('üèóÔ∏è Canvas getBoundingClientRect:', guideCanvas?.getBoundingClientRect());
            console.log('üèóÔ∏è Canvas style display:', guideCanvas?.style?.display);
            console.log('üèóÔ∏è Canvas offsetWidth/Height:', guideCanvas?.offsetWidth, guideCanvas?.offsetHeight);
            
            // Remove any existing event listeners first
            guideCanvas.removeEventListener('click', handleArchitectClick);
            guideCanvas.removeEventListener('contextmenu', handleArchitectRightClick);
            
            // Ensure canvas is properly clickable
            guideCanvas.style.position = 'relative';
            guideCanvas.style.zIndex = '5000';
            guideCanvas.style.display = 'block';
            guideCanvas.style.pointerEvents = 'auto';
            

            
            console.log('üî•üî• ADDING EVENT LISTENERS TO CANVAS! üî•üî•', {
                canvasExists: !!guideCanvas,
                canvasDisplay: guideCanvas?.style?.display,
                canvasPointerEvents: guideCanvas?.style?.pointerEvents,
                canvasRect: guideCanvas?.getBoundingClientRect()
            });
            
            guideCanvas.addEventListener('click', handleArchitectClick);
            guideCanvas.addEventListener('contextmenu', handleArchitectRightClick);
            
            // Add a test click handler to see if ANY clicks are being detected
            guideCanvas.addEventListener('mousedown', (e) => {
                console.log('üñ±Ô∏è MOUSEDOWN detected on canvas:', {
                    button: e.button,
                    clientX: e.clientX,
                    clientY: e.clientY,
                    target: e.target.tagName,
                    playerRole: playerRole
                });
            });
            
            // Add visual feedback for architect interactions
            guideCanvas.style.cursor = 'crosshair';
            guideCanvas.style.border = '3px solid #FF4500';
            guideCanvas.style.boxShadow = '0 0 15px rgba(255, 69, 0, 0.5)';
            
            // Add hover effects
            guideCanvas.addEventListener('mouseenter', () => {
                guideCanvas.style.boxShadow = '0 0 25px rgba(255, 69, 0, 0.8)';
            });
            
            guideCanvas.addEventListener('mouseleave', () => {
                guideCanvas.style.boxShadow = '0 0 15px rgba(255, 69, 0, 0.5)';
            });
            
            // Reminder messages disabled - user prefers clean interface
            // let reminderCount = 0;
            // const reminderInterval = setInterval(() => {
            //     if (reminderCount < 3) {
            //         showArchitectMessage('üèóÔ∏è REMINDER: Click on the 2D maze view to modify walls!', true);
            //         reminderCount++;
            //     } else {
            //         clearInterval(reminderInterval);
            //     }
            // }, 10000); // Every 10 seconds, 3 times
        }

        function handleArchitectClick(event) {
            console.log('Architect click detected');
            
            if (playerRole !== 'architect') {
                console.log('Not architect role, ignoring click');
                return;
            }
            
            event.preventDefault();
            const rect = guideCanvas.getBoundingClientRect();
            const canvasX = event.clientX - rect.left;
            const canvasY = event.clientY - rect.top;
            
            console.log('Adding wall at canvas coords:', {canvasX, canvasY});
            performArchitectAction(canvasX, canvasY, 'add');
        }



        function handleArchitectRightClick(event) {
            console.log('Architect right-click detected');
            
            if (playerRole !== 'architect') {
                console.log('Not architect role, ignoring right-click');
                return;
            }
            
            event.preventDefault();
            event.stopPropagation();
            const rect = guideCanvas.getBoundingClientRect();
            const canvasX = event.clientX - rect.left;
            const canvasY = event.clientY - rect.top;
            
            console.log('Removing wall at canvas coords:', {canvasX, canvasY});
            performArchitectAction(canvasX, canvasY, 'remove');
            
            return false; // Extra prevention of context menu
        }

        function performArchitectAction(canvasX, canvasY, action) {
            console.log('üèóÔ∏è performArchitectAction called:', {canvasX, canvasY, action, playerRole});
            
            const config = window.guideViewConfig;
            if (!config || !maze) {
                console.log('üèóÔ∏è Missing config or maze:', {config, maze});
                return;
            }
            
            const { cellSize, margin } = config;
            console.log('üèóÔ∏è Config values:', {cellSize, margin});
            
            // Convert canvas coordinates to flipped grid coordinates (matching drawGuideView)
            const canvasGridX = Math.floor((canvasX - margin) / cellSize);
            const canvasGridZ = Math.floor((canvasY - margin) / cellSize);
            
            // Unflip the coordinates to get actual maze grid coordinates
            // In drawGuideView: canvas_x = (maze.width - 1 - grid_x), so grid_x = maze.width - 1 - canvas_x
            const gridX = maze.maze[0].length - 1 - canvasGridX;
            const gridZ = maze.maze.length - 1 - canvasGridZ;
            
            // Convert grid coordinates to world coordinates
            const worldX = gridX * maze.cellSize;
            const worldZ = gridZ * maze.cellSize;
            
            console.log('üèóÔ∏è Coordinate conversion:', {
                canvas: {canvasX, canvasY},
                canvasGrid: {canvasGridX, canvasGridZ},
                actualGrid: {gridX, gridZ},
                world: {worldX, worldZ},
                cellSize: maze.cellSize,
                mazeSize: {width: maze.maze[0].length, height: maze.maze.length}
            });
            
            // Bounds check on actual grid coordinates
            if (gridX < 0 || gridX >= maze.maze[0].length || gridZ < 0 || gridZ >= maze.maze.length) {
                console.log('üèóÔ∏è Click outside maze bounds');
                return;
            }
            
            // Check current maze state at this position
            const currentValue = maze.maze[gridZ][gridX];
            console.log(`üèóÔ∏è Current maze value at grid(${gridX}, ${gridZ}): ${currentValue} (${currentValue === 1 ? 'wall' : 'empty'})`);
            
            // üèóÔ∏è VALIDATE MAZE STRUCTURE RULES
            if (action === 'add' && currentValue === 1) {
                console.log('üö® Cannot add wall - already exists at this position!');
                showArchitectMessage('‚ùå Cannot add wall - space already occupied!', false);
                return;
            }
            
            if (action === 'remove' && currentValue === 0) {
                console.log('üö® Cannot remove wall - no wall exists at this position!');
                showArchitectMessage('‚ùå Cannot remove wall - no wall exists here!', false);
                return;
            }
            
            console.log(`‚úÖ Valid ${action} action: ${currentValue === 1 ? 'removing existing wall' : 'adding wall to empty space'}`);
            
            // Update maze immediately for instant visual feedback
            maze.maze[gridZ][gridX] = action === 'add' ? 1 : 0;
            
            // üîß CRITICAL FIX: Update collision detection immediately for architect too
            // Note: worldX and worldZ are already declared above
            
            if (!maze.wallPositions) {
                maze.wallPositions = [];
            }
            
            if (action === 'add') {
                // Add wall position for collision detection
                const wallPos = { x: worldX, z: worldZ };
                // Check if position already exists to avoid duplicates
                const exists = maze.wallPositions.some(pos => 
                    Math.abs(pos.x - wallPos.x) < 0.1 && Math.abs(pos.z - wallPos.z) < 0.1
                );
                if (!exists) {
                    maze.wallPositions.push(wallPos);
                    console.log('üîß performArchitectAction: Added wall position for collision:', wallPos);
                }
            } else if (action === 'remove') {
                // Remove wall position from collision detection
                const initialLength = maze.wallPositions.length;
                maze.wallPositions = maze.wallPositions.filter(pos => 
                    !(Math.abs(pos.x - worldX) < 0.1 && Math.abs(pos.z - worldZ) < 0.1)
                );
                const removedCount = initialLength - maze.wallPositions.length;
                console.log(`üîß performArchitectAction: Removed ${removedCount} wall position(s) from collision at:`, {x: worldX, z: worldZ});
            }
            
            console.log('üîß performArchitectAction: Updated maze.wallPositions array, now has', maze.wallPositions.length, 'walls');
            
            // Redraw the architect's view immediately
            if (guideCanvas && guideCtx) {
                const currentPlayerPos = Object.values(playerPositions)[0] || null;
                const currentMonsterPos = Object.values(monsterPositions)[0] || null;
                drawGuideView(maze, currentPlayerPos, currentMonsterPos);
            }
            
            // Send wall change request to server
            console.log('üöÄ SENDING ARCHITECT MESSAGE TO SERVER:', {
                connected: multiplayerManager?.connected,
                socketState: multiplayerManager?.socket?.readyState,
                roomCode: multiplayerManager?.roomCode
            });
            
            if (multiplayerManager && multiplayerManager.socket && multiplayerManager.socket.readyState === WebSocket.OPEN) {
                const message = {
                    type: 'architect_wall_change',
                    x: worldX,
                    z: worldZ,
                    action: action
                };
                
                console.log('üíå ARCHITECT MESSAGE BEING SENT:', message);
                
                // Flash screen to show message being sent
                document.body.style.backgroundColor = '#00ffff';
                setTimeout(() => {
                    document.body.style.backgroundColor = '#000';
                }, 150);
                
                multiplayerManager.socket.send(JSON.stringify(message));
                console.log('‚úÖ ARCHITECT MESSAGE SENT TO SERVER!');
                
            } else {
                console.error('Cannot send message - connection not ready');
            }
        }

        function showArchitectCooldown(seconds) {

            const cooldownIndicator = document.getElementById('architectCooldown');
            if (cooldownIndicator) {
                cooldownIndicator.textContent = `üî• Cooldown: ${seconds}s`;
                cooldownIndicator.style.display = 'block';
                
                const countdownTimer = setInterval(() => {
                    seconds--;
                    if (seconds <= 0) {
                        cooldownIndicator.style.display = 'none';
                        clearInterval(countdownTimer);
                    } else {
                        cooldownIndicator.textContent = `üî• Cooldown: ${seconds}s`;
                    }
                }, 1000);
            }
        }

        // In-game message display function - disabled to reduce UI clutter
        function showArchitectMessage(message, isSuccess = false) {
            console.log('üì¢ Architect message:', message, 'isSuccess:', isSuccess);
            
            // Popup messages disabled - user prefers clean interface
            // Only log to console now
            
            // Remove any existing messages (cleanup)
            const existingMessages = document.querySelectorAll('.architect-message');
            existingMessages.forEach(msg => msg.remove());
            
            // UI popup disabled - messages only go to console now
        }
        
        // Backward compatibility function
        function showArchitectError(message) {
            showArchitectMessage(message, false);
        }

        // Expose functions globally so multiplayer.js can access them
        window.handleWallChanged = handleWallChanged;
        window.showArchitectCooldown = showArchitectCooldown;
        window.showArchitectError = showArchitectError;
        window.showArchitectMessage = showArchitectMessage;
        
        // Function to add pending players when scene becomes ready
        function addPendingPlayers() {
            if (!window.pendingPlayers || !scene) return;
            
            console.log('üîÑ Adding', window.pendingPlayers.length, 'pending players to scene');
            
            window.pendingPlayers.forEach(pendingPlayer => {
                if (!otherPlayers[pendingPlayer.playerId]) {
                    otherPlayers[pendingPlayer.playerId] = pendingPlayer.mesh;
                    otherPlayers[pendingPlayer.playerId].position.set(0, 2, 0);
                    otherPlayers[pendingPlayer.playerId].visible = true;
                    scene.add(otherPlayers[pendingPlayer.playerId]);
                    console.log('‚úÖ Added pending', pendingPlayer.role, 'to scene:', pendingPlayer.playerId);
                }
            });
            
            // Clear pending players
            window.pendingPlayers = [];
        }
        
        // Create fallback texture when loading fails
        function createFallbackTexture(color1, color2) {
            const canvas = document.createElement('canvas');
            canvas.width = 64;
            canvas.height = 64;
            const ctx = canvas.getContext('2d');
            
            // Create a checkerboard pattern
            const tileSize = 8;
            for (let x = 0; x < canvas.width; x += tileSize) {
                for (let y = 0; y < canvas.height; y += tileSize) {
                    const isEven = ((x / tileSize) + (y / tileSize)) % 2 === 0;
                    ctx.fillStyle = isEven ? color1 : color2;
                    ctx.fillRect(x, y, tileSize, tileSize);
                }
            }
            
            return canvas;
        }
        

        
        // DEBUGGING: Track role changes and clicks  
        let lastKnownRole = null;
        setInterval(() => {
            if (playerRole !== lastKnownRole) {
                console.log('üé≠ ROLE CHANGED! From:', lastKnownRole, 'To:', playerRole);
                lastKnownRole = playerRole;
                document.title = `Maze Game - Role: ${playerRole || 'none'}`;
            }
        }, 1000);
        

        

        

        

        


        function handleWallChanged(data) {
            if (!data || !maze) return;
            
            // Note: mazeGroup is only needed for 3D views (player/monster), not 2D views (guide/architect)
            
            // Update the local maze data
            if (maze && maze.maze && data.gridX !== undefined && data.gridZ !== undefined) {
                maze.maze[data.gridZ][data.gridX] = data.action === 'add' ? 1 : 0;
                
                // Track architect changes for visual highlighting
                const coordKey = `${data.gridX},${data.gridZ}`;
                if (data.action === 'add') {
                    architectWallChanges.added.add(coordKey);
                    architectWallChanges.removed.delete(coordKey); // Remove from removed if it was there
                    window.architectWallChanges.added.add(coordKey);
                    window.architectWallChanges.removed.delete(coordKey);
                } else if (data.action === 'remove') {
                    architectWallChanges.removed.add(coordKey);
                    architectWallChanges.added.delete(coordKey); // Remove from added if it was there
                    window.architectWallChanges.removed.add(coordKey);
                    window.architectWallChanges.added.delete(coordKey);
                }
                
                // üîß CRITICAL FIX: Update collision detection wallPositions array
                const worldX = data.gridX * maze.cellSize;
                const worldZ = data.gridZ * maze.cellSize;
                
                if (!maze.wallPositions) {
                    maze.wallPositions = [];
                }
                
                if (data.action === 'add') {
                    // Add wall position for collision detection
                    const wallPos = { x: worldX, z: worldZ };
                    // Check if position already exists to avoid duplicates
                    const exists = maze.wallPositions.some(pos => 
                        Math.abs(pos.x - wallPos.x) < 0.1 && Math.abs(pos.z - wallPos.z) < 0.1
                    );
                    if (!exists) {
                        maze.wallPositions.push(wallPos);
                        console.log('üîß Added wall position for collision:', wallPos);
                    }
                } else if (data.action === 'remove') {
                    // Remove wall position from collision detection
                    maze.wallPositions = maze.wallPositions.filter(pos => 
                        !(Math.abs(pos.x - worldX) < 0.1 && Math.abs(pos.z - worldZ) < 0.1)
                    );
                    console.log('üîß Removed wall position from collision at:', {x: worldX, z: worldZ});
                }
                
                console.log('üîß Updated maze.wallPositions array, now has', maze.wallPositions.length, 'walls');
            } else {
                return;
            }
            
            // Update 2D view for guide and architect with current player positions
            if ((playerRole === 'guide' || playerRole === 'architect') && window.guideViewConfig && guideCanvas && guideCtx) {
                try {
                    // Get current player and monster positions to preserve them in the redraw
                    const currentPlayerPos = Object.values(playerPositions)[0] || null;
                    const currentMonsterPos = Object.values(monsterPositions)[0] || null;
                    
                    console.log('üîÑ Redrawing 2D view after wall change for:', playerRole);
                    console.log('üé® Architect changes visible:', {
                        added: Array.from(architectWallChanges.added),
                        removed: Array.from(architectWallChanges.removed)
                    });
                    drawGuideView(maze, currentPlayerPos, currentMonsterPos);
                } catch (error) {
                    console.error('Error redrawing 2D view:', error);
                }
            }
            
            // Update 3D walls for player and monster (only if they have 3D scenes)
            if (mazeGroup && scene && (playerRole === 'player' || playerRole === 'monster')) {
                const worldX = data.gridX * maze.cellSize;
                const worldZ = data.gridZ * maze.cellSize;
                
                if (data.action === 'add') {
                    const wallGeometry = new THREE.BoxGeometry(maze.cellSize, maze.wallHeight, maze.cellSize);
                    
                    let wallMaterial;
                    if (typeof wallTexture !== 'undefined' && wallTexture) {
                        wallMaterial = new THREE.MeshLambertMaterial({ 
                            map: wallTexture,
                            color: 0xff0000 
                        });
                    } else {
                        wallMaterial = new THREE.MeshLambertMaterial({ 
                            color: 0xff0000 
                        });
                    }
                    const wall = new THREE.Mesh(wallGeometry, wallMaterial);
                    
                    wall.position.set(worldX, maze.wallHeight / 2, worldZ);
                    wall.userData = { 
                        gridX: data.gridX, 
                        gridZ: data.gridZ, 
                        isArchitectWall: true 
                    };
                    
                    mazeGroup.add(wall);
                    
                    // Remove any dark patch that might be at this location
                    const patchesToRemove = [];
                    mazeGroup.traverse((child) => {
                        if (child.userData && 
                            child.userData.isRemovedWallPatch &&
                            child.userData.gridX === data.gridX && 
                            child.userData.gridZ === data.gridZ) {
                            patchesToRemove.push(child);
                        }
                    });
                    
                    patchesToRemove.forEach(patch => {
                        mazeGroup.remove(patch);
                        if (patch.geometry) patch.geometry.dispose();
                        if (patch.material) patch.material.dispose();
                    });
                    
                } else if (data.action === 'remove') {
                    const wallsToRemove = [];
                    mazeGroup.traverse((child) => {
                        if (child.userData && 
                            child.userData.gridX === data.gridX && 
                            child.userData.gridZ === data.gridZ) {
                            wallsToRemove.push(child);
                        }
                    });
                    
                    wallsToRemove.forEach(wall => {
                        mazeGroup.remove(wall);
                        if (wall.geometry) wall.geometry.dispose();
                        if (wall.material) wall.material.dispose();
                    });
                    
                    // Add dark patch where wall was removed
                    console.log('üî≤ Creating dark patch at:', {worldX, worldZ, gridX: data.gridX, gridZ: data.gridZ});
                    const patchGeometry = new THREE.PlaneGeometry(maze.cellSize * 0.9, maze.cellSize * 0.9);
                    const patchMaterial = new THREE.MeshBasicMaterial({
                        color: 0x222222, // Very dark grey
                        transparent: true,
                        opacity: 0.8
                    });
                    const patch = new THREE.Mesh(patchGeometry, patchMaterial);
                    patch.rotation.x = -Math.PI / 2;
                    patch.position.set(worldX, 0.02, worldZ); // Slightly above floor
                    patch.userData = { 
                        isRemovedWallPatch: true, 
                        gridX: data.gridX, 
                        gridZ: data.gridZ 
                    };
                    mazeGroup.add(patch);
                    console.log('‚úÖ Dark patch added to mazeGroup, total children:', mazeGroup.children.length);
                }
                
                updateWallVisual(data.gridX, data.gridZ, data.action);
            }
            
            // Update architect view if it exists
            if (playerRole === 'architect' && window.architectViewCanvas && window.drawArchitectView) {
                setTimeout(() => {
                    drawArchitectView();
                }, 50);
            }
        }

        function updateWallVisual(gridX, gridZ, action) {
            
            // Validate input parameters
            if (typeof gridX === 'undefined' || typeof gridZ === 'undefined' || typeof action === 'undefined') {
                console.error('üî• Invalid parameters to updateWallVisual:', {gridX, gridZ, action});
                return;
            }
            
            if (!mazeGroup || !maze || !scene) {
                console.error('üèóÔ∏è updateWallVisual: missing required objects', {
                    mazeGroup: !!mazeGroup,
                    maze: !!maze,
                    scene: !!scene
                });
                return;
            }
            
            const worldX = gridX * maze.cellSize;
            const worldZ = gridZ * maze.cellSize;
            
            console.log(`üèóÔ∏è Wall action at grid(${gridX}, ${gridZ}) -> world(${worldX}, ${worldZ})`);
            
            // Update maze data
            maze.maze[gridZ][gridX] = action === 'add' ? 1 : 0;
            
            // üîß CRITICAL FIX: Update collision detection wallPositions array
            // Note: worldX and worldZ are already declared above
            if (!maze.wallPositions) {
                maze.wallPositions = [];
            }
            
            if (action === 'add') {
                // Add wall position for collision detection
                const wallPos = { x: worldX, z: worldZ };
                // Check if position already exists to avoid duplicates
                const exists = maze.wallPositions.some(pos => 
                    Math.abs(pos.x - wallPos.x) < 0.1 && Math.abs(pos.z - wallPos.z) < 0.1
                );
                if (!exists) {
                    maze.wallPositions.push(wallPos);
                    console.log('üîß updateWallVisual: Added wall position for collision:', wallPos);
                }
            } else if (action === 'remove') {
                // Remove wall position from collision detection
                const initialLength = maze.wallPositions.length;
                maze.wallPositions = maze.wallPositions.filter(pos => 
                    !(Math.abs(pos.x - worldX) < 0.1 && Math.abs(pos.z - worldZ) < 0.1)
                );
                const removedCount = initialLength - maze.wallPositions.length;
                console.log(`üîß updateWallVisual: Removed ${removedCount} wall position(s) from collision at:`, {x: worldX, z: worldZ});
            }
            
            console.log('üîß updateWallVisual: Updated maze.wallPositions array, now has', maze.wallPositions.length, 'walls');
            
            if (action === 'add') {
                console.log('üèóÔ∏è ADDING wall...');
                
                // Check if wall already exists at this position
                const existingWall = mazeGroup.children.find(child => 
                    child.userData && child.userData.gridX === gridX && child.userData.gridZ === gridZ
                );
                
                if (existingWall) {
                    console.log('üèóÔ∏è Wall already exists, skipping');
                    return;
                }
                
                // Create new wall - make it VERY visible for architect
                const wallGeometry = new THREE.BoxGeometry(maze.cellSize, maze.wallHeight, maze.cellSize);
                
                // Create a bright, easily visible material for architect walls
                const wallMaterial = new THREE.MeshBasicMaterial({
                    color: 0xff0000, // Red color for architect walls
                    transparent: false
                });
                
                const wall = new THREE.Mesh(wallGeometry, wallMaterial);
                wall.position.set(worldX, maze.wallHeight / 2, worldZ);
                wall.userData = { gridX: gridX, gridZ: gridZ, architectPlaced: true };
                wall.castShadow = true;
                wall.receiveShadow = true;
                
                mazeGroup.add(wall);
                console.log('üèóÔ∏è BRIGHT ORANGE WALL ADDED at position:', wall.position);
                
                // Add a glowing indicator above the wall for extra visibility
                const glowGeometry = new THREE.SphereGeometry(0.5, 8, 8);
                const glowMaterial = new THREE.MeshBasicMaterial({
                    color: 0x00ff00,
                    transparent: true,
                    opacity: 0.7
                });
                const glow = new THREE.Mesh(glowGeometry, glowMaterial);
                glow.position.set(worldX, maze.wallHeight + 2, worldZ);
                glow.userData = { isGlow: true, parentWall: wall };
                scene.add(glow);
                console.log('üèóÔ∏è GLOWING GREEN SPHERE ADDED above wall');
                
            } else if (action === 'remove') {
                console.log('üèóÔ∏è REMOVING wall...');
                
                // Find walls to remove (use fuzzy matching for better precision)
                const wallsToRemove = mazeGroup.children.filter(child => {
                    if (!child.userData) return false;
                    
                    // Check exact grid coordinates first
                    if (child.userData.gridX === gridX && child.userData.gridZ === gridZ) {
                        return true;
                    }
                    
                    // Fallback: check if world position is close (within 0.5 units)
                    const worldX = gridX * maze.cellSize;
                    const worldZ = gridZ * maze.cellSize;
                    const childX = child.position.x;
                    const childZ = child.position.z;
                    
                    if (Math.abs(childX - worldX) < 0.5 && Math.abs(childZ - worldZ) < 0.5) {
                        console.log('üèóÔ∏è Found wall by position matching:', childX, childZ, 'vs target:', worldX, worldZ);
                        return true;
                    }
                    
                    return false;
                });
                
                if (wallsToRemove.length > 0) {
                    wallsToRemove.forEach((wall, index) => {
                        console.log(`üèóÔ∏è Removing wall ${index + 1}/${wallsToRemove.length} from scene`);
                        mazeGroup.remove(wall);
                        wall.geometry.dispose();
                        wall.material.dispose();
                        
                        // Also remove any glow indicators
                        const glowToRemove = scene.children.find(child =>
                            child.userData && child.userData.isGlow && child.userData.parentWall === wall
                        );
                        if (glowToRemove) {
                            scene.remove(glowToRemove);
                            glowToRemove.geometry.dispose();
                            glowToRemove.material.dispose();
                            console.log('üèóÔ∏è Glow indicator REMOVED');
                        }
                    });
                    console.log(`üèóÔ∏è Successfully removed ${wallsToRemove.length} wall(s)`);
                } else {
                    // List all available walls for debugging
                    console.log('üèóÔ∏è No wall found to remove. Available walls:');
                    mazeGroup.children.forEach((child, index) => {
                        if (child.userData && (child.userData.gridX !== undefined)) {
                            const distance = Math.abs(child.userData.gridX - gridX) + Math.abs(child.userData.gridZ - gridZ);
                            console.log(`  ${index}: grid(${child.userData.gridX}, ${child.userData.gridZ}), distance: ${distance}, position: (${child.position.x}, ${child.position.z})`);
                        }
                    });
                    
                    // Check if there's a wall in the maze data but not in 3D scene
                    if (maze.maze[gridZ] && maze.maze[gridZ][gridX] === 1) {
                        console.log('üèóÔ∏è WARNING: Maze data shows wall exists but not found in 3D scene!');
                    }
                }
            }
            
            console.log(`üèóÔ∏è Wall ${action} completed. MazeGroup children: ${mazeGroup.children.length}`);
        }

        function startGameTimer() {
            // Show timer for all roles
            console.log('üïí Starting timer for role:', playerRole);
            
            // Remove any existing timer first
            const existingTimer = document.getElementById('gameTimer');
            if (existingTimer) {
                existingTimer.remove();
                console.log('üóëÔ∏è Removed existing timer');
            }
            
            // Create timer display for all roles
            const timerDisplay = document.createElement('div');
            timerDisplay.id = 'gameTimer';
            
            timerDisplay.style.cssText = `
                position: fixed;
                top: 20px;
                right: 20px;
                background: rgba(255, 0, 0, 0.9);
                border: 3px solid #ff0000;
                box-shadow: 0 0 25px rgba(255, 0, 0, 0.5);
                color: white;
                padding: 12px 25px;
                border-radius: 15px;
                font-size: 20px;
                font-weight: bold;
                z-index: 10000;
                text-shadow: 0 0 5px rgba(0, 0, 0, 0.8);
            `;
            document.body.appendChild(timerDisplay);
            
            let timeRemaining = gameTimeLimit;
            
            const updateTimer = () => {
                const minutes = Math.floor(timeRemaining / 60000);
                const seconds = Math.floor((timeRemaining % 60000) / 1000);
                timerDisplay.textContent = `‚è∞ TIME: ${minutes}:${seconds.toString().padStart(2, '0')}`;
                
                // Change intensity as time runs out
                if (timeRemaining <= 60000) { // Last minute - very urgent
                    timerDisplay.style.background = 'rgba(255, 0, 0, 1.0)';
                    timerDisplay.style.borderColor = '#ffffff';
                    timerDisplay.style.boxShadow = '0 0 30px rgba(255, 0, 0, 0.8)';
                    timerDisplay.style.animation = 'pulse 0.5s infinite';
                } else if (timeRemaining <= 120000) { // Last 2 minutes - getting urgent
                    timerDisplay.style.background = 'rgba(255, 69, 0, 0.95)';
                    timerDisplay.style.borderColor = '#ff4500';
                    timerDisplay.style.boxShadow = '0 0 25px rgba(255, 69, 0, 0.7)';
                }
                
                timeRemaining -= 1000;
                
                if (timeRemaining <= 0) {
                    clearInterval(gameTimer);
                    handleTimeUp();
                }
            };
            
            updateTimer(); // Initial display
            gameTimer = setInterval(updateTimer, 1000);
        }

        function stopGameTimer() {
            if (gameTimer) {
                clearInterval(gameTimer);
                gameTimer = null;
            }
            
            const timerDisplay = document.getElementById('gameTimer');
            if (timerDisplay) {
                timerDisplay.remove();
            }
        }

        function handleTimeUp() {
            if (!gameStarted) return;
            gameStarted = false;
            
            // Stop the timer
            stopGameTimer();
            
            // Create time up screen
            const timeUpScreen = document.createElement('div');
            timeUpScreen.style.cssText = `
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: rgba(255, 152, 0, 0.95);
                color: white;
                padding: 30px;
                border-radius: 15px;
                text-align: center;
                font-size: 24px;
                z-index: 10000;
                box-shadow: 0 0 30px rgba(255, 152, 0, 0.7);
            `;
            
            timeUpScreen.innerHTML = `
                <h2>‚è∞ Time's Up! Game Over! ‚è∞</h2>
                <p>Everyone will be kicked out in 3 seconds...</p>
                <div style="font-size: 18px; margin-top: 15px;">
                    Thanks for playing! üéÆ
                </div>
            `;
            
            document.body.appendChild(timeUpScreen);
            
            // Send game over message to server
            if (multiplayerManager && multiplayerManager.connected) {
                multiplayerManager.socket.send(JSON.stringify({
                    type: 'game_over',
                    winner: 'time_up',
                    roomCode: multiplayerManager.roomCode
                }));
            }
            
            // Kick everyone out after a short delay
            setTimeout(() => {
                console.log('üö™ Kicking everyone out - timer ended!');
                if (timeUpScreen.parentNode) {
                    document.body.removeChild(timeUpScreen);
                }
                // Disconnect from multiplayer and go back to main menu
                if (multiplayerManager && multiplayerManager.connected) {
                    multiplayerManager.disconnect();
                }
                window.location.reload(); // Force page reload to main menu
            }, 3000);
        }

        let animateDebugCount = 0;
        
        // Simple direct player movement system as backup
        const simpleKeys = { w: false, s: false, a: false, d: false };
        
        document.addEventListener('keydown', (e) => {
            if (e.key.toLowerCase() === 'w') simpleKeys.w = true;
            if (e.key.toLowerCase() === 's') simpleKeys.s = true;
            if (e.key.toLowerCase() === 'a') simpleKeys.a = true;
            if (e.key.toLowerCase() === 'd') simpleKeys.d = true;
        });
        
        document.addEventListener('keyup', (e) => {
            if (e.key.toLowerCase() === 'w') simpleKeys.w = false;
            if (e.key.toLowerCase() === 's') simpleKeys.s = false;
            if (e.key.toLowerCase() === 'a') simpleKeys.a = false;
            if (e.key.toLowerCase() === 'd') simpleKeys.d = false;
        });
        
        function animate() {
            requestAnimationFrame(animate);
            
            // Increment debug counter
            if (animateDebugCount < 10) {
                animateDebugCount++;
            }
            
            // Basic validation to prevent errors
            if (!renderer || !scene || !camera) {
                console.error('‚ùå Animation loop missing critical components:', {
                    renderer: !!renderer,
                    scene: !!scene,
                    camera: !!camera,
                    playerRole: playerRole
                });
                return;
            }
            
            // SIMPLE DIRECT MOVEMENT FOR PLAYER AND MONSTER WITH COLLISION DETECTION
            if ((playerRole === 'player' || playerRole === 'monster') && camera && gameStarted && maze) {
                const moveSpeed = 0.15;
                let moved = false;
                const oldPosition = camera.position.clone();
                const newPosition = camera.position.clone();
                
                // Calculate movement vector
                let moveVector = { x: 0, z: 0 };
                if (simpleKeys.w) {
                    moveVector.x -= Math.sin(camera.rotation.y) * moveSpeed;
                    moveVector.z -= Math.cos(camera.rotation.y) * moveSpeed;
                }
                if (simpleKeys.s) {
                    moveVector.x += Math.sin(camera.rotation.y) * moveSpeed;
                    moveVector.z += Math.cos(camera.rotation.y) * moveSpeed;
                }
                
                // Apply movement with collision detection
                if (moveVector.x !== 0 || moveVector.z !== 0) {
                    const targetPos = {
                        x: newPosition.x + moveVector.x,
                        z: newPosition.z + moveVector.z
                    };
                    
                    // Check collision at target position
                    const collision = checkCollision(targetPos);
                    
                    // If there's a collision, try to slide along walls
                    if (collision.x || collision.z) {
                        if (!collision.x) newPosition.x = targetPos.x;
                        if (!collision.z) newPosition.z = targetPos.z;
                        
                        // Apply sliding motion if available
                        if (collision.slideX || collision.slideZ) {
                            newPosition.x += collision.slideX * 0.5;
                            newPosition.z += collision.slideZ * 0.5;
                        }
                    } else {
                        // No collision, move freely
                        newPosition.x = targetPos.x;
                        newPosition.z = targetPos.z;
                    }
                    
                    // Update camera position
                    camera.position.copy(newPosition);
                    moved = true;
                }
                
                // Handle rotation (no collision needed)
                if (simpleKeys.a) {
                    camera.rotation.y += 0.06;
                    moved = true;
                }
                if (simpleKeys.d) {
                    camera.rotation.y -= 0.06;
                    moved = true;
                }
                
                if (moved && animateDebugCount < 5) {
                    console.log(`üéÆ ${playerRole.toUpperCase()} MOVEMENT WITH COLLISION! Position:`, camera.position, 'Keys:', simpleKeys);
                }
                
                // Send position update for multiplayer
                if (moved && multiplayerManager && multiplayerManager.connected) {
                    const now = Date.now();
                    if (now - lastPositionUpdate >= POSITION_UPDATE_INTERVAL) {
                        lastPositionUpdate = now;
                        multiplayerManager.sendPosition(camera.position, camera.rotation);
                    }
                }
            }
            
            if (gameStarted && controls && controls.update) {
                // Debug player and monster movement issues
                if ((playerRole === 'player' || playerRole === 'monster') && animateDebugCount < 3) {
                    console.log(`üîß ${playerRole.toUpperCase()} animate() debug:`, {
                        gameStarted: gameStarted,
                        controlsExists: !!controls,
                        controlsEnabled: controls.enabled,
                        updateExists: !!controls.update,
                        playerRole: playerRole
                    });
                }
                
                // Skip controls.update() for player and monster since they're using simple movement
                if (playerRole !== 'player' && playerRole !== 'monster') {
                    controls.update(); // Call the controls update function for architects/guides only
                }
                
                // Check if player has reached the end marker
                if (playerRole === 'player' && maze && maze.endPosition) {
                    const distanceToEnd = Math.sqrt(
                        Math.pow(camera.position.x - maze.endPosition.x, 2) +
                        Math.pow(camera.position.z - maze.endPosition.z, 2)
                    );
                    if (distanceToEnd < 1.0) { // If player is within 1 unit of the end marker
                        handlePlayerWin();
                    }
                }
                
                if ((playerRole === 'player' || playerRole === 'monster') && multiplayerManager && multiplayerManager.connected) {
                    const now = Date.now();
                    // Only send position updates at most every 50ms
                    if (now - lastPositionUpdate >= POSITION_UPDATE_INTERVAL) {
                        lastPositionUpdate = now;
                        
                        // Send position update to server
                        const position = {
                            x: camera.position.x,
                            y: camera.position.y,
                            z: camera.position.z
                        };
                        const rotation = {
                            x: camera.rotation.x,
                            y: camera.rotation.y,
                            z: camera.rotation.z
                        };
                        
                        // Send position and rotation update to server with correct type
                        if (multiplayerManager.socket && multiplayerManager.socket.readyState === WebSocket.OPEN) {
                            multiplayerManager.socket.send(JSON.stringify({
                                type: playerRole === 'monster' ? 'monster_position' : 'player_position',
                                position: position,
                                rotation: rotation,
                                roomCode: multiplayerManager.roomCode,
                                sessionId: multiplayerManager.gameState.sessionId
                            }));
                        }
                    }
                }
            } else if (gameStarted && !controls && (playerRole === 'player' || playerRole === 'monster')) {
                // Critical fix: if game started but no controls, try to set them up
                console.error('üö® CRITICAL: Game started but no controls for', playerRole);
                if (scene && camera && maze) {
                    console.log('üîß Emergency control setup...');
                    controls = setupControls();
                }
            }
            
            // Animate red flickering lights - simple on/off pattern
            if (window.flickeringLights) {
                const time = Date.now();
                window.flickeringLights.forEach(flickerData => {
                    // Check if it's time to possibly change state
                    if (!flickerData.lastChange || time - flickerData.lastChange > flickerData.changeInterval) {
                        // Randomly decide to turn on or off
                        if (Math.random() < 0.4) { // 40% chance to change state each check
                            flickerData.isOn = !flickerData.isOn;
                            flickerData.lastChange = time;
                            flickerData.changeInterval = 100 + Math.random() * 500; // Random interval 100-600ms
                        }
                    }
                    
                    // Set light intensity based on on/off state
                    if (flickerData.isOn) {
                        flickerData.light.intensity = flickerData.baseIntensity;
                    } else {
                        flickerData.light.intensity = 0; // Completely off
                    }
                });
            }
            
            // ALWAYS render the scene to prevent black screen
            try {
                renderer.render(scene, camera);
                
                // Debug empty scene once
                if (animateDebugCount === 2 && scene.children.length === 0) {
                    console.warn('‚ö†Ô∏è Scene is empty! This will cause a black screen.');
                    console.log('Maze data:', !!maze);
                    console.log('MazeGroup:', !!mazeGroup);
                }
            } catch (error) {
                console.error('‚ùå Rendering error:', error);
                console.error('Scene children count:', scene.children.length);
                console.error('Camera position:', camera.position);
            }
        }

        // Event Listeners
        document.getElementById('singlePlayerButton').addEventListener('click', () => {
            console.log('Single player button clicked');
            startGame('single');
        });
        document.getElementById('multiplayerButton').addEventListener('click', () => {
            console.log('Multiplayer button clicked');
            showMultiplayerMenu();
        });
        document.getElementById('createRoomButton').addEventListener('click', () => {
            console.log('Create room button clicked');
            createRoom();
        });
        document.getElementById('joinRoomButton').addEventListener('click', () => {
            console.log('Join room button clicked');
            showJoinRoom();
        });
        document.getElementById('backToMainButton').addEventListener('click', () => {
            document.getElementById('multiplayerMenu').style.display = 'none';
            document.getElementById('startScreen').style.display = 'block';
        });
        document.getElementById('roomCodeInput').addEventListener('keyup', (e) => {
            if (e.key === 'Enter') {
                joinRoom();
            }
        });

        // Add click handler for room code copying
        document.getElementById('roomCode').addEventListener('click', function() {
            copyRoomCode(this);
        });

        // Handle window resizing
        window.addEventListener('resize', () => {
            if (camera && renderer) {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            }
        });

        // Clean up when leaving the game
        window.addEventListener('beforeunload', () => {
            if (multiplayerManager) {
                multiplayerManager.disconnect();
            }
            gameStarted = false;
        });

        // Handle visibility change to prevent reconnection loops
        document.addEventListener('visibilitychange', () => {
            if (document.hidden) {
                console.log('Page hidden, handling cleanup...');
                // Store current game state before going hidden
                if (multiplayerManager && multiplayerManager.gameState.active) {
                    multiplayerManager.gameState.lastKnownState = {
                        roomCode: multiplayerManager.roomCode,
                        role: multiplayerManager.role,
                        isHost: multiplayerManager.isHost,
                        position: camera ? { x: camera.position.x, y: camera.position.y, z: camera.position.z } : null
                    };
                }
            } else {
                console.log('Page visible, checking game state...');
                if (multiplayerManager && multiplayerManager.gameState.active) {
                    // Verify connection and game state when becoming visible
                    if (!multiplayerManager.connected || multiplayerManager.gameState.reconnecting) {
                        console.log('Connection lost while hidden, attempting to restore...');
                        multiplayerManager.connect();
                    } else {
                        // Send a ping to verify connection is still alive
                        multiplayerManager.socket.send(JSON.stringify({
                            type: 'ping',
                            timestamp: Date.now()
                        }));
                    }
                }
            }
        });

        // Update the MultiplayerManager to handle disconnections better
        MultiplayerManager.prototype.handleDisconnect = function() {
            console.log('Handling disconnection...');
            this.connected = false;
            
            if (gameStarted && !this.disconnecting) {
                // Show a reconnection message
                let reconnectMessage = document.getElementById('reconnectMessage');
                if (!reconnectMessage) {
                    reconnectMessage = document.createElement('div');
                    reconnectMessage.id = 'reconnectMessage';
                    reconnectMessage.style.cssText = `
                        position: fixed;
                        top: 50%;
                        left: 50%;
                        transform: translate(-50%, -50%);
                        background: rgba(0, 0, 0, 0.8);
                        color: white;
                        padding: 20px;
                        border-radius: 10px;
                        z-index: 1000;
                        text-align: center;
                    `;
                    document.body.appendChild(reconnectMessage);
                }
                
                reconnectMessage.innerHTML = `
                    <h3>Connection Lost</h3>
                    <p>Attempting to reconnect...</p>
                    <button onclick="location.reload()" style="margin-top: 10px; padding: 5px 10px;">Restart Game</button>
                `;
                
                // Try to reconnect
                this.reconnect();
                
                // Set a timeout to show the menu if reconnection fails
                setTimeout(() => {
                    if (!this.connected && gameStarted) {
                        console.log('Reconnection failed, showing start screen');
                        hideAllMenus();
                        
                        // Only show start screen if we're completely disconnected
                        if (!this.socket || this.socket.readyState !== WebSocket.CONNECTING) {
                            document.getElementById('startScreen').style.display = 'block';
                            gameStarted = false;
                            
                            // Remove reconnect message
                            if (reconnectMessage) {
                                reconnectMessage.remove();
                            }
                            
                            // Show an error message to the user
                            alert('Lost connection to the game. Please try again.');
                        }
                    }
                }, 15000); // Give even more time for reconnection attempts
            }
        };

        // Override MultiplayerManager message handling completely
        MultiplayerManager.prototype.handleMessage = function(message) {
            console.log('üîî CLIENT: Received message:', message.type, message);
            
            switch (message.type) {
                case 'room_created':
                    console.log('üè† Room created, setting up...');
                    this.roomCode = message.roomCode;
                    this.isHost = true;
                    this.role = message.role;
                    playerRole = message.role; // This will be 'waiting' initially
                    this.gameState.players.add('host');
                    this.gameState.playerCount = 1;
                    this.gameState.canStart = false;
                    this.gameState.allPlayersJoined = false;
                    if (this.onRoomCreated) {
                        this.onRoomCreated(message.roomCode);
                    }
                    break;

                case 'room_joined':
                    console.log('üö™ Room joined, setting up...');
                    this.roomCode = message.roomCode;
                    this.role = message.role;
                    playerRole = message.role; // This will be 'waiting' initially
                    this.gameState.canStart = false;
                    this.gameState.allPlayersJoined = false;
                    if (this.onRoomJoined) {
                        this.onRoomJoined();
                    }
                    break;

                case 'player_joined':
                    console.log('üë• Player joined');
                    this.gameState.players.add(message.playerId);
                    this.gameState.playerCount++;
                    if (this.onPlayerJoined) {
                        this.onPlayerJoined(message.playerId, message.role);
                    }
                    break;

                case 'role_assigned':
                    console.log('üé≠ ROLE ASSIGNED:', message.role);
                    this.role = message.role;
                    playerRole = message.role; // This is the actual game role
                    
                    // If we have maze data and this is a proper role, trigger initialization
                    if (maze && playerRole && playerRole !== 'waiting') {
                        console.log('üé¨ Role assigned with maze data available, triggering initialization...');
                        console.log('üé¨ Maze exists:', !!maze, 'PlayerRole:', playerRole, 'isHost:', multiplayerManager?.isHost);
                        // Small delay to ensure all role assignment processing is complete
                        setTimeout(() => {
                            if (playerRole === 'guide' || playerRole === 'architect') {
                                console.log('üéÆ Initializing 2D view for:', playerRole);
                                initGuideView(maze);
                                if (playerRole === 'architect') {
                                    try {
                                        setupArchitectControls();
                                    } catch (error) {
                                        console.error('Error setting up architect controls:', error);
                                    }
                                }
                            } else if (playerRole === 'player' || playerRole === 'monster') {
                                console.log('üéÆ Initializing 3D view for:', playerRole);
                                init(false);
                            }
                        }, 100);
                    } else {
                        console.log('üö® Role assigned but cannot initialize yet:', {
                            maze: !!maze,
                            playerRole: playerRole,
                            isWaiting: playerRole === 'waiting'
                        });
                    }
                    
                    if (this.onRoleAssigned) {
                        console.log('üé≠ Calling onRoleAssigned callback');
                        this.onRoleAssigned(message.role, message.message);
                    }
                    break;

                case 'game_ready':
                    console.log('üéÆ GAME READY - Starting game');
                    this.gameState.allPlayersJoined = true;
                    this.gameState.canStart = true;
                    if (this.onGameReady) {
                        console.log('üéÆ Calling onGameReady callback');
                        this.onGameReady();
                    }
                    break;

                case 'waiting_for_players':
                    console.log('‚è≥ Waiting for players...');
                    this.gameState.allPlayersJoined = false;
                    this.gameState.canStart = false;
                    break;

                case 'player_left':
                    console.log('üëã Player left');
                    this.gameState.players.delete(message.playerId);
                    this.gameState.playerCount--;
                    this.gameState.canStart = false;
                    this.gameState.allPlayersJoined = false;
                    if (this.onPlayerLeft) {
                        this.onPlayerLeft(message.playerId);
                    }
                    break;

                case 'maze_data':
                    console.log('üó∫Ô∏è Received maze data in main handler');
                    maze = message.maze;
                    maze.wallPositions = maze.wallPositions || [];
                    
                    // Check if we can initialize now that we have maze data
                    console.log('üé¨ Maze data received (main handler), checking if ready to initialize...');
                    console.log('üé¨ Current playerRole:', playerRole, 'isHost:', multiplayerManager?.isHost);
                    if (playerRole && playerRole !== 'waiting') {
                        console.log('üé¨ Role assigned, initializing scene...');
                        if (playerRole === 'guide' || playerRole === 'architect') {
                            console.log('üéÆ Initializing 2D view for:', playerRole);
                            initGuideView(maze);
                            if (playerRole === 'architect') {
                                try {
                                    setupArchitectControls();
                                } catch (error) {
                                    console.error('Error setting up architect controls:', error);
                                }
                            }
                        } else {
                            init(false);
                        }
                    } else {
                        console.log('üîÑ Waiting for role assignment before initializing scene...');
                    }
                    break;

                case 'error':
                    console.error('‚ùå Server error:', message.error);
                    if (this.onError) {
                        this.onError(message.error);
                    }
                    break;

                case 'player_position':
                case 'monster_position':
                    // Handle position updates separately
                    handleMultiplayerMessage(message);
                    break;

                case 'architect_update':
                    console.log('üèóÔ∏è ARCHITECT UPDATE received in main handler:', message);
                    // Call the wall changed handler directly
                    if (window.handleWallChanged) {
                        window.handleWallChanged(message);
                    } else {
                        console.error('‚ùå handleWallChanged function not available!');
                    }
                    break;

                default:
                    console.log('‚ùì Unknown message type:', message.type);
                    break;
            }
        };

        function handleMultiplayerMessage(message) {
            console.log('Handling message:', message);
            
            switch (message.type) {
                case 'player_position':
                    if (!message.position || typeof message.position.x !== 'number' || typeof message.position.z !== 'number') {
                        console.error('Invalid player position received:', message.position);
                        return;
                    }

                    if (playerRole === 'guide' || playerRole === 'architect') {
                        // Store position for this specific player ID
                        playerPositions[message.playerId] = {
                            x: message.position.x,
                            y: message.position.y,
                            z: message.position.z,
                            rotation: message.rotation
                        };
                        
                        // Guide and Architect: Update 2D view
                        if ((playerRole === 'guide' || playerRole === 'architect') && maze && guideCanvas && guideCtx) {
                            requestAnimationFrame(() => {
                                // Get the first (and should be only) player position
                                const playerPos = Object.values(playerPositions)[0] || null;
                                const monsterPos = Object.values(monsterPositions)[0] || null;
                                drawGuideView(maze, playerPos, monsterPos);
                            });
                        }
                        
                        // Architect: Update 3D view
                        if (playerRole === 'architect') {
                            console.log('Architect received player position:', message);
                            if (otherPlayers[message.playerId]) {
                                // Update existing player representation
                                otherPlayers[message.playerId].visible = true;
                                otherPlayers[message.playerId].position.set(
                                    message.position.x,
                                    message.position.y,
                                    message.position.z
                                );
                                if (message.rotation) {
                                    otherPlayers[message.playerId].rotation.set(
                                        message.rotation.x,
                                        message.rotation.y,
                                        message.rotation.z
                                    );
                                }
                            } else {
                                // Create player representation for architect's 3D view
                                console.log('Creating player representation for architect 3D view');
                                const playerGeometry = new THREE.Group();
                                
                                const body = new THREE.Mesh(
                                    new THREE.CylinderGeometry(0.4, 0.4, 2.5, 8),
                                    new THREE.MeshPhongMaterial({ 
                                        color: 0x00ff00,
                                        emissive: 0x00ff00,
                                        emissiveIntensity: 0.5
                                    })
                                );
                                playerGeometry.add(body);
                                
                                const ring = new THREE.Mesh(
                                    new THREE.TorusGeometry(0.5, 0.1, 8, 16),
                                    new THREE.MeshPhongMaterial({
                                        color: 0xffff00,
                                        emissive: 0xffff00,
                                        emissiveIntensity: 0.7
                                    })
                                );
                                ring.position.y = 1.5;
                                ring.rotation.x = Math.PI / 2;
                                playerGeometry.add(ring);
                                
                                otherPlayers[message.playerId] = playerGeometry;
                                otherPlayers[message.playerId].position.set(
                                    message.position.x,
                                    message.position.y,
                                    message.position.z
                                );
                                otherPlayers[message.playerId].visible = true;
                                scene.add(otherPlayers[message.playerId]);
                                console.log('Added player representation to architect 3D scene');
                            }
                        }

                        // Check if player reached the end
                        if (maze && maze.endPosition) {
                            const distanceToEnd = Math.sqrt(
                                Math.pow(message.position.x - maze.endPosition.x, 2) +
                                Math.pow(message.position.z - maze.endPosition.z, 2)
                            );
                            if (distanceToEnd < 1.0) { // If player is within 1 unit of the end marker
                                handlePlayerWin();
                            }
                        }
                    } else if (playerRole === 'monster') {
                        console.log('Monster received player position:', message);
                        if (otherPlayers[message.playerId]) {
                            // Update player position for monster view
                            otherPlayers[message.playerId].visible = true;
                            otherPlayers[message.playerId].position.set(
                                message.position.x,
                                message.position.y,
                                message.position.z
                            );
                            if (message.rotation) {
                                otherPlayers[message.playerId].rotation.set(
                                    message.rotation.x,
                                    message.rotation.y,
                                    message.rotation.z
                                );
                            }
                            
                            // Calculate and update distance to player
                            const distance = Math.sqrt(
                                Math.pow(camera.position.x - message.position.x, 2) +
                                Math.pow(camera.position.z - message.position.z, 2)
                            );
                            updateDistanceIndicator(distance);
                            
                            // Apply proximity effects (this handles player role check internally)
                            applyProximityEffects(distance);

                            // Check if monster caught the player
                            if (distance < 1.5) { // If monster is within 1.5 units of the player
                                handleMonsterWin();
                            }
                        } else {
                            console.log('Creating player representation for monster view');
                            // Create player representation for monster's view
                            const playerGeometry = new THREE.Group();
                            
                            // Main body - taller and brighter cylinder
                            const body = new THREE.Mesh(
                                new THREE.CylinderGeometry(0.4, 0.4, 2.5, 8),
                                new THREE.MeshPhongMaterial({ 
                                    color: 0x00ff00,
                                    emissive: 0x00ff00,
                                    emissiveIntensity: 0.5
                                })
                            );
                            playerGeometry.add(body);
                            
                            // Add glowing ring at the top
                            const ring = new THREE.Mesh(
                                new THREE.TorusGeometry(0.5, 0.1, 8, 16),
                                new THREE.MeshPhongMaterial({
                                    color: 0xffff00,
                                    emissive: 0xffff00,
                                    emissiveIntensity: 0.7
                                })
                            );
                            ring.position.y = 1.5;
                            ring.rotation.x = Math.PI / 2;
                            playerGeometry.add(ring);
                            
                            otherPlayers[message.playerId] = playerGeometry;
                            otherPlayers[message.playerId].position.set(
                                message.position.x,
                                message.position.y,
                                message.position.z
                            );
                            otherPlayers[message.playerId].visible = true;
                            scene.add(otherPlayers[message.playerId]);
                        }
                    }
                    break;

                case 'monster_position':
                    if (playerRole === 'guide' || playerRole === 'architect') {
                        if (!message.position || typeof message.position.x !== 'number' || typeof message.position.z !== 'number') {
                            console.error('Invalid monster position received:', message.position);
                            return;
                        }
                        
                        // Store position for this specific monster ID
                        monsterPositions[message.playerId] = {
                            x: message.position.x,
                            y: message.position.y,
                            z: message.position.z,
                            rotation: message.rotation
                        };
                        
                        // Guide and Architect: Update 2D view
                        if ((playerRole === 'guide' || playerRole === 'architect') && maze && guideCanvas && guideCtx) {
                            requestAnimationFrame(() => {
                                // Get the first (and should be only) player and monster positions
                                const playerPos = Object.values(playerPositions)[0] || null;
                                const monsterPos = Object.values(monsterPositions)[0] || null;
                                drawGuideView(maze, playerPos, monsterPos);
                            });
                        }
                        
                        // Architect: Update 3D view
                        if (playerRole === 'architect') {
                            console.log('Architect received monster position:', message);
                            if (otherPlayers[message.playerId]) {
                                // Update existing monster representation
                                otherPlayers[message.playerId].visible = true;
                                otherPlayers[message.playerId].position.set(
                                    message.position.x,
                                    message.position.y,
                                    message.position.z
                                );
                                if (message.rotation) {
                                    otherPlayers[message.playerId].rotation.set(
                                        message.rotation.x,
                                        message.rotation.y,
                                        message.rotation.z
                                    );
                                }
                            } else {
                                // Create monster representation for architect's 3D view
                                console.log('Creating monster representation for architect 3D view');
                                const monsterMesh = new THREE.Mesh(
                                    new THREE.CylinderGeometry(0.3, 0.3, 2, 8),
                                    new THREE.MeshPhongMaterial({ 
                                        color: 0xff0000,
                                        emissive: 0xff0000,
                                        emissiveIntensity: 0.5
                                    })
                                );
                                
                                otherPlayers[message.playerId] = monsterMesh;
                                otherPlayers[message.playerId].position.set(
                                    message.position.x,
                                    message.position.y,
                                    message.position.z
                                );
                                otherPlayers[message.playerId].visible = true;
                                scene.add(otherPlayers[message.playerId]);
                                console.log('Added monster representation to architect 3D scene');
                            }
                        }
                    } else if (playerRole === 'player') {
                        // Player sees monster position
                        console.log('Player received monster position:', message);
                        if (otherPlayers[message.playerId]) {
                            otherPlayers[message.playerId].position.set(
                                message.position.x,
                                message.position.y,
                                message.position.z
                            );
                            if (message.rotation) {
                                otherPlayers[message.playerId].rotation.set(
                                    message.rotation.x,
                                    message.rotation.y,
                                    message.rotation.z
                                );
                            }
                        } else if (scene) {
                            // Create monster representation if it doesn't exist yet
                            console.log('üî¥ Creating missing monster representation for player view');
                            const monsterMesh = new THREE.Mesh(
                                new THREE.CylinderGeometry(0.5, 0.5, 3, 16),
                                new THREE.MeshPhongMaterial({ 
                                    color: 0xff0000,
                                    emissive: 0xff0000,
                                    emissiveIntensity: 0.8
                                })
                            );
                            
                            otherPlayers[message.playerId] = monsterMesh;
                            otherPlayers[message.playerId].position.set(
                                message.position.x,
                                message.position.y,
                                message.position.z
                            );
                            if (message.rotation) {
                                otherPlayers[message.playerId].rotation.set(
                                    message.rotation.x,
                                    message.rotation.y,
                                    message.rotation.z
                                );
                            }
                            otherPlayers[message.playerId].visible = true;
                            scene.add(otherPlayers[message.playerId]);
                            console.log('‚úÖ Created and added monster to player scene');
                        }

                        // Check if monster caught the player (moved outside if-else blocks)
                        const distance = Math.sqrt(
                            Math.pow(camera.position.x - message.position.x, 2) +
                            Math.pow(camera.position.z - message.position.z, 2)
                        );
                        
                        // Add proximity effects when monster gets close
                        applyProximityEffects(distance);
                        
                        if (distance < 1.5) { // If monster is within 1.5 units of the player
                            handleMonsterWin();
                        }
                    }
                    break;

                case 'maze_data':
                    console.log('Received maze data:', message.maze);
                    maze = message.maze;
                    maze.wallPositions = maze.wallPositions || [];
                    
                    // Initialize the maze for all roles
                    if (playerRole === 'player' || playerRole === 'monster') {
                        generateNewMaze();
                    } else if (playerRole === 'guide' || playerRole === 'architect') {
                        drawGuideView(maze);
                    }
                    break;

                case 'waiting_for_players':
                    console.log('Waiting for players:', message);
                    const instructionsElement = document.getElementById('roomCodeInstructions');
                    if (instructionsElement) {
                        instructionsElement.textContent = message.message || 'Waiting for more players...';
                        instructionsElement.style.display = 'block';
                    }
                    break;

                case 'host_assigned':
                    console.log('Host assigned:', message);
                    if (message.isHost) {
                        this.isHost = true;
                    }
                    break;

                case 'error':
                    console.error('Server error:', message.error);
                    if (this.onError) {
                        this.onError(message.error);
                    }
                    break;

                case 'player_joined':
                    if (this.onPlayerJoined) {
                        this.onPlayerJoined(message.playerId, message.role);
                    }
                    break;

                case 'player_left':
                    if (this.onPlayerLeft) {
                        this.onPlayerLeft(message.playerId);
                    }
                    break;

                case 'game_over':
                    if (!message.winner) return;
                    
                    if (message.winner === 'player' && playerRole !== 'player') {
                        handlePlayerWin();
                    } else if (message.winner === 'monster' && playerRole !== 'monster') {
                        handleMonsterWin();
                    }
                    
                    // Cleanup and disconnect after a short delay
                    setTimeout(() => {
                        cleanupGame();
                    }, 2000);
                    break;

                case 'game_terminated':
                    console.log('üéÆ Game terminated by server, winner:', message.winner);
                    gameStarted = false;
                    
                    // Immediately disable all controls and game mechanics
                    if (controls) {
                        controls.enabled = false;
                    }
                    
                    // Stop any game timers
                    if (gameTimer) {
                        clearInterval(gameTimer);
                        gameTimer = null;
                    }
                    
                    // Stop animation loop if running
                    if (window.animationFrameId) {
                        cancelAnimationFrame(window.animationFrameId);
                        window.animationFrameId = null;
                    }
                    
                    // Immediately disconnect from multiplayer
                    if (multiplayerManager && multiplayerManager.connected) {
                        console.log('üîå Disconnecting from multiplayer due to game termination');
                        multiplayerManager.disconnecting = true;
                        multiplayerManager.disconnect();
                    }
                    
                    // Show appropriate win screen based on winner (for all roles including guide)
                    const isPlayerWin = message.winner === 'player';
                    const isMonsterWin = message.winner === 'monster';
                    const isArchitectWin = message.winner === 'architect';
                    
                    let backgroundColor = 'rgba(0, 255, 0, 0.9)'; // Default green for player win
                    if (isMonsterWin) backgroundColor = 'rgba(255, 0, 0, 0.9)'; // Red for monster win
                    if (isArchitectWin) backgroundColor = 'rgba(255, 152, 0, 0.9)'; // Orange for architect win
                    
                    const winScreen = document.createElement('div');
                    winScreen.style.cssText = `
                        position: fixed;
                        top: 50%;
                        left: 50%;
                        transform: translate(-50%, -50%);
                        background: ${backgroundColor};
                        color: white;
                        padding: 30px;
                        border-radius: 15px;
                        text-align: center;
                        font-size: 24px;
                        z-index: 10000;
                        box-shadow: 0 0 20px ${backgroundColor.replace('0.9', '0.5')};
                        user-select: none;
                    `;
                    
                    // Show different message based on player role and winner
                    let winMessage = '';
                    if (playerRole === 'guide') {
                        if (isPlayerWin) {
                            winMessage = `
                                <h2>üéâ Player and Guide Win! üéâ</h2>
                                <p>You successfully guided the player to safety!</p>
                            `;
                        } else if (isMonsterWin) {
                            winMessage = `
                                <h2>üëª Monster Wins! üëª</h2>
                                <p>The monster caught the player despite your guidance!</p>
                            `;
                        } else if (isArchitectWin) {
                            winMessage = `
                                <h2>‚è∞ Architect Wins! üèóÔ∏è</h2>
                                <p>Time ran out and the architect succeeded!</p>
                            `;
                        }
                    } else if (playerRole === 'architect') {
                        if (isPlayerWin) {
                            winMessage = `
                                <h2>üéâ Player Escaped! üòî</h2>
                                <p>The player found the exit despite your maze modifications!</p>
                            `;
                        } else if (isMonsterWin) {
                            winMessage = `
                                <h2>üëª Monster Wins! üëª</h2>
                                <p>The monster caught the player!</p>
                            `;
                        } else if (isArchitectWin) {
                            winMessage = `
                                <h2>‚è∞ Architect Wins! üèóÔ∏è</h2>
                                <p>You successfully ran out the clock!</p>
                            `;
                        }
                    } else if (playerRole === 'player') {
                        if (isPlayerWin) {
                            winMessage = `
                                <h2>üéâ You Win! üéâ</h2>
                                <p>You successfully reached the exit!</p>
                            `;
                        } else if (isMonsterWin) {
                            winMessage = `
                                <h2>üëª Monster Caught You! üëª</h2>
                                <p>The monster was too fast! Better luck next time!</p>
                            `;
                        } else if (isArchitectWin) {
                            winMessage = `
                                <h2>‚è∞ Time's Up! ‚è∞</h2>
                                <p>The architect won by running out the clock!</p>
                            `;
                        }
                    } else if (playerRole === 'monster') {
                        if (isPlayerWin) {
                            winMessage = `
                                <h2>üéâ Player Escaped! üòî</h2>
                                <p>The player reached the exit before you could catch them!</p>
                            `;
                        } else if (isMonsterWin) {
                            winMessage = `
                                <h2>üëª You Win! üëª</h2>
                                <p>You successfully caught the player!</p>
                            `;
                        } else if (isArchitectWin) {
                            winMessage = `
                                <h2>‚è∞ Architect Wins! üèóÔ∏è</h2>
                                <p>Time ran out and the architect succeeded!</p>
                            `;
                        }
                    }
                    
                    winScreen.innerHTML = winMessage + `
                        <div style="margin-top: 20px; font-size: 16px; color: rgba(255,255,255,0.8);">
                            Game ended - Returning to main menu...
                        </div>
                    `;
                    
                    document.body.appendChild(winScreen);
                    
                    // Complete cleanup and reload after delay
                    setTimeout(() => {
                        console.log(`üîÑ ${playerRole} game session ended, reloading page`);
                        
                        // Final cleanup before reload
                        try {
                            if (multiplayerManager) {
                                multiplayerManager.endSession();
                            }
                            
                            // Clear any remaining timeouts/intervals
                            for (let i = 1; i < 10000; i++) {
                                clearTimeout(i);
                                clearInterval(i);
                            }
                            
                            // Force reload the page to return to main menu
                            window.location.reload(true);
                        } catch (error) {
                            console.error('Error during final cleanup:', error);
                            window.location.reload(true);
                        }
                    }, 2000);
                    break;

                default:
                    console.log('Unhandled message type:', message.type);
                    break;
            }
        };



        function initGame(isMultiplayer = false) {
            if (isMultiplayer && !gameStarted) {
                console.log('Cannot start multiplayer game yet - waiting for players');
                return;
            }
            
            // ... rest of initGame function ...
        }

        function getRandomEmptyCell(maze) {
            const width = maze.maze[0].length;
            const height = maze.maze.length;
            let attempts = 0;
            const maxAttempts = 100;

            while (attempts < maxAttempts) {
                const x = Math.floor(Math.random() * width);
                const z = Math.floor(Math.random() * height);
                
                // Check if this cell is empty (not a wall) and not the start position
                if (!maze.maze[z][x] && 
                    (x !== Math.floor(maze.startPosition.x / maze.cellSize) || 
                     z !== Math.floor(maze.startPosition.z / maze.cellSize))) {
                    return { x: x, z: z };
                }
                attempts++;
            }

            // If no empty cell found after max attempts, return a default position
            return { x: 2, z: 2 };
        }

        function handlePlayerMove(ws, data) {
            console.log('Received player position:', data);
            const room = rooms.get(ws.roomCode);
            if (!room) {
                console.log('Room not found for player position:', ws.roomCode);
                return;
            }

            // Update player position
            room.playerPositions.set(ws.playerId, {
                position: data.position,
                rotation: data.rotation
            });

            // Send position to all guide and monster players
            room.players.forEach((playerWs, playerId) => {
                const role = room.roles.get(playerId);
                if (role === 'guide' || role === 'monster') {
                    console.log(`Sending position to ${role}:`, {
                        position: data.position,
                        playerId: playerId
                    });
                    playerWs.send(JSON.stringify({
                        type: 'player_position',
                        position: data.position,
                        rotation: data.rotation
                    }));
                }
            });
        }

        // Add proximity effects for when monster gets close to player
        let proximityShakeOffset = { x: 0, y: 0, z: 0 };
        
        function applyProximityEffects(distance) {
            if (playerRole !== 'player') return; // Only apply to player
            
            const maxEffectDistance = 30; // Start effects at 30 units (much much earlier!)
            const maxIntensity = 1.0; // Maximum effect intensity
            
            // Calculate intensity based on distance (closer = more intense)
            let intensity = 0;
            if (distance <= maxEffectDistance) {
                intensity = Math.max(0, (maxEffectDistance - distance) / maxEffectDistance);
                
                // Create multiple intensity zones for different levels of fear
                if (distance <= 3) {
                    // PANIC ZONE - extremely intense effects
                    intensity = Math.pow(intensity, 0.5) * 1.0; // Very intense
                } else if (distance <= 6) {
                    // DANGER ZONE - strong effects
                    intensity = Math.pow(intensity, 0.8) * 0.8; // Strong
                } else if (distance <= 12) {
                    // WARNING ZONE - moderate effects
                    intensity = Math.pow(intensity, 1.2) * 0.6; // Moderate
                } else if (distance <= 20) {
                    // ALERT ZONE - mild effects
                    intensity = Math.pow(intensity, 1.8) * 0.4; // Mild
                } else {
                    // AWARENESS ZONE - very subtle effects
                    intensity = Math.pow(intensity, 2.5) * 0.2; // Very subtle
                }
            }
            
            // Apply screen shake effect by modifying renderer position instead of camera
            if (intensity > 0) {
                let shakeAmount = intensity * 25; // More intense shake
                
                // Add rapid shaking for close distances
                if (distance <= 3) {
                    shakeAmount += Math.sin(Date.now() * 0.05) * 10; // Rapid vibration
                }
                
                const shakeX = (Math.random() - 0.5) * shakeAmount;
                const shakeY = (Math.random() - 0.5) * shakeAmount;
                
                // Apply shake to renderer element instead of camera position
                if (renderer && renderer.domElement) {
                    renderer.domElement.style.transform = `translate(${shakeX}px, ${shakeY}px)`;
                }
            } else {
                // No shake, reset renderer position
                if (renderer && renderer.domElement) {
                    renderer.domElement.style.transform = 'translate(0px, 0px)';
                }
            }
            
            // Apply red overlay effect with dynamic gradients
            let redOverlay = document.getElementById('proximityOverlay');
            if (!redOverlay) {
                redOverlay = document.createElement('div');
                redOverlay.id = 'proximityOverlay';
                redOverlay.style.cssText = `
                    position: fixed;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    pointer-events: none;
                    z-index: 9999;
                    transition: opacity 0.05s ease;
                `;
                document.body.appendChild(redOverlay);
            }
            
            // Dynamic red overlay based on distance zones
            if (intensity > 0) {
                let overlayStyle = '';
                let opacity = intensity;
                
                if (distance <= 3) {
                    // PANIC ZONE - pulsing red with dark edges
                    const pulse = Math.sin(Date.now() * 0.01) * 0.3 + 0.7;
                    overlayStyle = `radial-gradient(circle, rgba(255, 0, 0, ${intensity * 0.3}) 10%, rgba(139, 0, 0, ${intensity * pulse}) 70%, rgba(0, 0, 0, ${intensity * 0.9}) 100%)`;
                    opacity = Math.min(0.9, intensity + pulse * 0.3);
                } else if (distance <= 6) {
                    // DANGER ZONE - strong red vignette
                    overlayStyle = `radial-gradient(circle, transparent 20%, rgba(255, 0, 0, ${intensity * 0.7}) 80%, rgba(139, 0, 0, ${intensity * 0.8}) 100%)`;
                    opacity = intensity * 0.8;
                } else if (distance <= 10) {
                    // WARNING ZONE - moderate red edges
                    overlayStyle = `radial-gradient(circle, transparent 40%, rgba(255, 0, 0, ${intensity * 0.5}) 90%)`;
                    opacity = intensity * 0.6;
                } else {
                    // AWARENESS ZONE - subtle red tint
                    overlayStyle = `radial-gradient(circle, transparent 60%, rgba(255, 0, 0, ${intensity * 0.3}) 95%)`;
                    opacity = intensity * 0.4;
                }
                
                redOverlay.style.background = overlayStyle;
                redOverlay.style.opacity = opacity;
            } else {
                redOverlay.style.opacity = 0;
            }
        }

        // Add these new functions for monster features
        function updateDistanceIndicator(distance) {
            let indicator = document.getElementById('distanceIndicator');
            if (!indicator) {
                indicator = document.createElement('div');
                indicator.id = 'distanceIndicator';
                indicator.style.cssText = `
                    position: fixed;
                    top: 60px;
                    left: 20px;
                    color: #ff0000;
                    font-size: 16px;
                    text-shadow: 0 0 5px rgba(255, 0, 0, 0.5);
                    z-index: 1000;
                `;
                document.body.appendChild(indicator);
            }
            indicator.textContent = `Distance to player: ${Math.round(distance)} units`;
        }

        function handleMonsterCatch() {
            // Create catch notification
            const notification = document.createElement('div');
            notification.style.cssText = `
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: rgba(255, 0, 0, 0.8);
                color: white;
                padding: 20px;
                border-radius: 10px;
                font-size: 24px;
                text-align: center;
                z-index: 1000;
            `;
            notification.textContent = 'You caught the player!';
            document.body.appendChild(notification);

            // Remove notification after 3 seconds
            setTimeout(() => {
                notification.remove();
            }, 3000);

            // TODO: Add game end logic here
        }

        // Add these new functions for win conditions
        function handlePlayerWin() {
            if (!gameStarted) return;
            gameStarted = false;

            // Stop the timer if running
            stopGameTimer();

            // Disable controls immediately
            if (controls) {
                controls.enabled = false;
            }

            // Create win screen
            const winScreen = document.createElement('div');
            winScreen.style.cssText = `
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: rgba(0, 255, 0, 0.9);
                color: white;
                padding: 30px;
                border-radius: 15px;
                text-align: center;
                font-size: 24px;
                z-index: 1000;
                box-shadow: 0 0 20px rgba(0, 255, 0, 0.5);
            `;
            winScreen.innerHTML = `
                <h2>üéâ Player Wins! üéâ</h2>
                <p>The player successfully reached the exit!</p>
            `;
            document.body.appendChild(winScreen);

            // Send game over message to server
            if (multiplayerManager && multiplayerManager.connected) {
                multiplayerManager.socket.send(JSON.stringify({
                    type: 'game_over',
                    winner: 'player',
                    roomCode: multiplayerManager.roomCode
                }));
            }

            // Clean up after a short delay
            setTimeout(() => {
                document.body.removeChild(winScreen);
                window.location.reload(); // Force page reload
            }, 1500);
        }

        function handleMonsterWin() {
            if (!gameStarted) return;
            gameStarted = false;

            // Disable controls immediately
            if (controls) {
                controls.enabled = false;
            }

            // Create win screen
            const winScreen = document.createElement('div');
            winScreen.style.cssText = `
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: rgba(255, 0, 0, 0.9);
                color: white;
                padding: 30px;
                border-radius: 15px;
                text-align: center;
                font-size: 24px;
                z-index: 1000;
                box-shadow: 0 0 20px rgba(255, 0, 0, 0.5);
            `;
            winScreen.innerHTML = `
                <h2>üëª Monster Wins! üëª</h2>
                <p>The monster caught the player!</p>
            `;
            document.body.appendChild(winScreen);

            // Send game over message to server
            if (multiplayerManager && multiplayerManager.connected) {
                multiplayerManager.socket.send(JSON.stringify({
                    type: 'game_over',
                    winner: 'monster',
                    roomCode: multiplayerManager.roomCode
                }));
            }

            // Clean up after a short delay
            setTimeout(() => {
                document.body.removeChild(winScreen);
                window.location.reload(); // Force page reload
            }, 1500);
        }

        function testBroadcast() {
            console.log('üß™ Test broadcast button clicked');
            if (multiplayerManager && multiplayerManager.connected) {
                console.log('üß™ Sending test_broadcast message to server');
                multiplayerManager.socket.send(JSON.stringify({
                    type: 'test_broadcast'
                }));
            } else {
                console.log('üß™ Not connected to multiplayer server');
                alert('Not connected to multiplayer server');
            }
        }

        function cleanupGame() {
            // Disable all controls and game logic
            gameStarted = false;
            if (controls) {
                controls.enabled = false;
            }

            // Remove event listeners
            document.removeEventListener('pointerlockchange', onPointerLockChange);
            document.removeEventListener('pointerlockerror', onPointerLockError);
            document.removeEventListener('mousemove', onMouseMove);
            if (keydownListener) document.removeEventListener('keydown', keydownListener);
            if (keyupListener) document.removeEventListener('keyup', keyupListener);
            
            // Exit pointer lock if active
            if (document.pointerLockElement) {
                document.exitPointerLock();
            }

            // Disconnect from server
            if (multiplayerManager && multiplayerManager.connected) {
                multiplayerManager.disconnect();
            }

            // Clear any animation frames
            if (window.animationFrameId) {
                cancelAnimationFrame(window.animationFrameId);
            }

            // Clear the scene
            if (scene) {
                while(scene.children.length > 0) { 
                    scene.remove(scene.children[0]); 
                }
            }

            // Dispose of renderer
            if (renderer && renderer.domElement) {
                renderer.domElement.remove();
                renderer.dispose();
            }

            // Hide all game-related elements
            const elementsToHide = [
                'guideView',
                'winScreen',
                'multiplayerMenu',
                'roomCode',
                'roomCodeInstructions',
                'loadingScreen',
                'errorScreen'
            ];
            
            elementsToHide.forEach(id => {
                const element = document.getElementById(id);
                if (element) {
                    element.style.display = 'none';
                }
            });

            // Show start screen
            const startScreen = document.getElementById('startScreen');
            if (startScreen) {
                startScreen.style.display = 'block';
            }

            // Reset all game variables
            scene = null;
            camera = null;
            renderer = null;
            controls = null;
            maze = null;
            mazeGroup = null;
            otherPlayers = {};
            playerRole = null;
            gameMode = 'single';
            multiplayerManager = null;
            playerPositions = {};
            monsterPositions = {};
            allPlayersJoined = false;
            roomCode = null;
            lastPositionUpdate = 0;
            lastPlayerPos = null;
            lastMonsterPos = null;
            isInitialized = false;
            animateDebugCount = 0;
        }

        // 3D click handling for architect
        function handleArchitect3DClick(event) {
            if (playerRole !== 'architect') return;
            
            console.log('üèóÔ∏è Architect 3D left click detected');
            
            // Cast ray from camera to determine where in the maze the architect clicked
            const raycaster = new THREE.Raycaster();
            const mouse = new THREE.Vector2();
            
            // Calculate mouse position in normalized device coordinates
            const rect = renderer.domElement.getBoundingClientRect();
            mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
            
            // Cast ray from camera
            raycaster.setFromCamera(mouse, camera);
            
            // Create a ground plane at y=0 to intersect with
            const groundPlane = new THREE.Plane(new THREE.Vector3(0, 1, 0), 0);
            const intersectionPoint = new THREE.Vector3();
            raycaster.ray.intersectPlane(groundPlane, intersectionPoint);
            
            if (intersectionPoint) {
                // Convert world coordinates to grid coordinates
                const gridX = Math.round(intersectionPoint.x / maze.cellSize);
                const gridZ = Math.round(intersectionPoint.z / maze.cellSize);
                
                console.log('üèóÔ∏è Clicked at world:', intersectionPoint, 'grid:', gridX, gridZ);
                
                // Validate grid coordinates
                if (gridX >= 0 && gridX < maze.maze[0].length && gridZ >= 0 && gridZ < maze.maze.length) {
                    performArchitectAction3D(gridX, gridZ, 'add');
                } else {
                    console.log('üèóÔ∏è Click outside maze bounds');
                }
            }
        }
        
        function handleArchitect3DRightClick(event) {
            if (playerRole !== 'architect') return;
            
            console.log('üèóÔ∏è Architect 3D right click detected');
            
            // Cast ray from camera to determine where in the maze the architect clicked
            const raycaster = new THREE.Raycaster();
            const mouse = new THREE.Vector2();
            
            // Calculate mouse position in normalized device coordinates
            const rect = renderer.domElement.getBoundingClientRect();
            mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
            
            // Cast ray from camera
            raycaster.setFromCamera(mouse, camera);
            
            // Create a ground plane at y=0 to intersect with
            const groundPlane = new THREE.Plane(new THREE.Vector3(0, 1, 0), 0);
            const intersectionPoint = new THREE.Vector3();
            raycaster.ray.intersectPlane(groundPlane, intersectionPoint);
            
            if (intersectionPoint) {
                // Convert world coordinates to grid coordinates
                const gridX = Math.round(intersectionPoint.x / maze.cellSize);
                const gridZ = Math.round(intersectionPoint.z / maze.cellSize);
                
                console.log('üèóÔ∏è Right-clicked at world:', intersectionPoint, 'grid:', gridX, gridZ);
                
                // Validate grid coordinates
                if (gridX >= 0 && gridX < maze.maze[0].length && gridZ >= 0 && gridZ < maze.maze.length) {
                    performArchitectAction3D(gridX, gridZ, 'remove');
                } else {
                    console.log('üèóÔ∏è Right-click outside maze bounds');
                }
            }
        }
        
        function performArchitectAction3D(gridX, gridZ, action) {
            if (playerRole !== 'architect') {
                console.log('üèóÔ∏è Not architect, ignoring action');
                return;
            }
            
            console.log(`üèóÔ∏è Performing 3D architect action: ${action} at grid (${gridX}, ${gridZ})`);
            
            // Check current state
            const currentValue = maze.maze[gridZ][gridX];
            console.log('üèóÔ∏è Current maze value at position:', currentValue);
            
            // Determine if action is valid
            if (action === 'add' && currentValue === 1) {
                console.log('üèóÔ∏è Wall already exists at this position');
                showArchitectMessage('Wall already exists here!', false);
                return;
            }
            
            if (action === 'remove' && currentValue === 0) {
                console.log('üèóÔ∏è No wall to remove at this position');
                showArchitectMessage('No wall to remove here!', false);
                return;
            }
            
            // Calculate world coordinates
            const worldX = gridX * maze.cellSize;
            const worldZ = gridZ * maze.cellSize;
            
            console.log(`üèóÔ∏è Sending architect update: action=${action}, grid=(${gridX}, ${gridZ}), world=(${worldX}, ${worldZ})`);
            
            // Send the update to the server
            if (multiplayerManager && multiplayerManager.connected) {
                const updateData = {
                    type: 'architect_update',
                    action: action,
                    gridX: gridX,
                    gridZ: gridZ,
                    x: worldX,
                    z: worldZ
                };
                
                multiplayerManager.socket.send(JSON.stringify(updateData));
                console.log('üèóÔ∏è Architect update sent to server:', updateData);
                
                // Show feedback
                showArchitectMessage(`Wall ${action === 'add' ? 'added' : 'removed'} at (${gridX}, ${gridZ})!`, true);
            } else {
                console.error('üèóÔ∏è Cannot send architect update - not connected to server');
                showArchitectMessage('Not connected to server!', false);
            }
        }
    </script>
</body>
</html> 