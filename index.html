<!DOCTYPE html>
<html>
<head>
    <title>3D Maze Game</title>
    <!-- Load Three.js from local file -->
            <script src="js/three.min.js?v=3"></script>
        <script src="js/maze-generator.js?v=3"></script>
        <script src="js/multiplayer.js?v=3"></script>
    <script>
        // Verify Three.js loaded
        window.addEventListener('load', function() {
            if (typeof THREE === 'undefined') {
                document.body.innerHTML = '<div style="color: red; text-align: center; margin-top: 50px;">Error: Failed to load 3D library. Please try refreshing the page.</div>';
            }
        });
    </script>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: Arial, sans-serif;
            background: #000;
            color: #fff;
        }
        #startScreen {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            background: none;
            color: white;
            padding: 30px;
            z-index: 1000;
            pointer-events: auto !important;
        }
        #startScreen h1 {
            color: #4CAF50;
            text-shadow: 0 0 15px rgba(76, 175, 80, 0.7);
            margin-bottom: 30px;
            font-size: 48px;
        }
        #startScreen .instruction {
            color: rgba(255, 255, 255, 0.9);
            margin: 8px 0;
            font-size: 18px;
            text-shadow: 0 0 10px rgba(255, 255, 255, 0.5);
        }
        .gameButton {
            background: rgba(76, 175, 80, 0.8);
            border: 2px solid rgba(255, 255, 255, 0.2);
            color: white;
            padding: 15px 30px;
            font-size: 20px;
            cursor: pointer;
            border-radius: 25px;
            transition: all 0.3s;
            margin: 15px;
            width: 200px;
            backdrop-filter: blur(5px);
            text-shadow: 0 0 5px rgba(0, 0, 0, 0.3);
        }
        .gameButton:hover {
            background: rgba(76, 175, 80, 1);
            transform: scale(1.05);
            box-shadow: 0 0 20px rgba(76, 175, 80, 0.4);
        }
        #multiplayerMenu {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 30px;
            border-radius: 15px;
            z-index: 1000;
            display: none;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
        }
        #roomCodeInput {
            padding: 10px;
            font-size: 18px;
            margin: 10px;
            border-radius: 5px;
            border: none;
            text-align: center;
            width: 180px;
        }
        .backButton {
            background: #666;
            border: none;
            color: white;
            padding: 10px 20px;
            font-size: 16px;
            cursor: pointer;
            border-radius: 5px;
            transition: all 0.3s;
            margin-top: 20px;
        }
        .backButton:hover {
            background: #555;
        }
        #roomCode {
            font-size: 48px;
            margin: 20px;
            padding: 30px;
            background: rgba(0, 0, 0, 0.9);
            border-radius: 15px;
            font-family: monospace;
            letter-spacing: 8px;
            text-align: center;
            border: 3px solid #4CAF50;
            color: #4CAF50;
            cursor: pointer;
            user-select: all;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 9999;
            box-shadow: 0 0 30px rgba(76, 175, 80, 0.5);
            transition: all 0.3s ease;
            animation: pulse 2s infinite;
            display: none;
        }
        @keyframes pulse {
            0% { box-shadow: 0 0 30px rgba(76, 175, 80, 0.5); }
            50% { box-shadow: 0 0 50px rgba(76, 175, 80, 0.8); }
            100% { box-shadow: 0 0 30px rgba(76, 175, 80, 0.5); }
        }
        #roomCodeInstructions {
            color: #fff;
            font-size: 18px;
            margin-top: 20px;
            text-align: center;
            position: fixed;
            top: calc(50% + 100px);
            left: 50%;
            transform: translateX(-50%);
            z-index: 1000;
            background: rgba(0, 0, 0, 0.8);
            padding: 15px 30px;
            border-radius: 10px;
            animation: fadeIn 0.5s ease-out;
        }
        @keyframes fadeIn {
            from { opacity: 0; transform: translate(-50%, 20px); }
            to { opacity: 1; transform: translate(-50%, 0); }
        }
        #loadingScreen {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 20px;
            border-radius: 10px;
            z-index: 2000;
            display: none;
        }
        #loadingMessage {
            margin-top: 10px;
            font-size: 18px;
        }
        #errorScreen {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            background: rgba(255, 0, 0, 0.9);
            color: white;
            padding: 30px;
            border-radius: 15px;
            z-index: 3000;
            display: none;
            max-width: 80%;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
        }
        #errorMessage {
            margin: 20px 0;
            font-size: 16px;
            white-space: pre-wrap;
            text-align: left;
        }
        #debugInfo {
            margin-top: 20px;
            font-size: 14px;
            color: #ddd;
            text-align: left;
            font-family: monospace;
            background: rgba(0, 0, 0, 0.3);
            padding: 10px;
            border-radius: 5px;
            max-height: 200px;
            overflow-y: auto;
        }
        .spinner {
            border: 4px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            border-top: 4px solid white;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 10px auto;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        #winScreen {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 30px;
            border-radius: 15px;
            text-align: center;
            z-index: 2000;
            display: none;
            animation: popIn 0.5s ease-out;
        }
        @keyframes popIn {
            0% { transform: translate(-50%, -50%) scale(0.5); opacity: 0; }
            100% { transform: translate(-50%, -50%) scale(1); opacity: 1; }
        }
        #winScreen h2 {
            color: #4CAF50;
            margin-bottom: 20px;
            font-size: 32px;
            text-shadow: 0 0 10px rgba(76, 175, 80, 0.5);
        }
        #winScreen p {
            font-size: 20px;
            margin: 15px 0;
            color: #fff;
        }
        #winScreen button {
            background: #4CAF50;
            border: none;
            color: white;
            padding: 15px 30px;
            border-radius: 5px;
            cursor: pointer;
            margin: 10px;
            font-size: 20px;
            transition: all 0.3s;
        }
        #winScreen button:hover {
            background: #45a049;
            transform: scale(1.1);
        }
        /* Remove crosshair cursor */
        canvas {
            pointer-events: auto !important;
            cursor: default !important;
            outline: none;
            z-index: 1;
        }
        
        /* Update win screen styles */
        #winScreen button {
            background: #4CAF50;
            border: none;
            color: white;
            padding: 15px 30px;
            font-size: 24px;
            cursor: pointer;
            border-radius: 8px;
            transition: all 0.3s;
            margin-top: 20px;
        }
        
        #winScreen button:hover {
            background: #45a049;
            transform: scale(1.1);
        }
        * {
            pointer-events: auto !important;
            cursor: default;
        }
        #gameContainer {
            position: relative;
            width: 100%;
            height: 100%;
        }
        .no-cursor {
            cursor: none;
        }
        .game-canvas {
            outline: none;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            -khtml-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
            pointer-events: auto !important;
        }
        #guideInstructions {
            position: absolute;
            top: 20px;
            left: 20px;
            color: #4CAF50;
            font-size: 18px;
            text-shadow: 0 0 5px rgba(76, 175, 80, 0.5);
        }
        #guideView {
            display: none;
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000;
            pointer-events: auto !important;
        }
        #guideCanvas {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: #111;
            pointer-events: auto !important;
        }
    </style>
</head>
<body>
    <div id="startScreen">
        <h1>3D Maze Game</h1>
        <div class="instruction">Navigate through the maze to find the exit</div>
        <div class="instruction">Use WASD to move and mouse to look around</div>
        <button class="gameButton" id="singlePlayerButton">Single Player</button>
        <button class="gameButton" id="multiplayerButton">Multiplayer</button>
    </div>

    <div id="roomCode" class="room-code"></div>
    <div id="roomCodeInstructions" class="room-code-instructions"></div>

    <div id="multiplayerMenu">
        <h2>Multiplayer Mode</h2>
        <button class="gameButton" id="createRoomButton">Create Room</button>
        <button class="gameButton" id="joinRoomButton">Join Room</button>
        <input type="text" id="roomCodeInput" placeholder="Enter Room Code" style="display: none;">
        <button class="backButton" id="backToMainButton">Back to Main Menu</button>
    </div>

    <div id="loadingScreen">
        <div class="spinner"></div>
        <div id="loadingMessage">Loading Game...</div>
    </div>

    <!-- Add new waiting and role assignment screens -->
    <div id="waitingScreen" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); text-align: center; background: rgba(0, 0, 0, 0.9); color: white; padding: 40px; border-radius: 20px; z-index: 2000; border: 3px solid #4CAF50; box-shadow: 0 0 30px rgba(76, 175, 80, 0.5);">
        <h2 style="color: #4CAF50; font-size: 32px; margin-bottom: 20px; text-shadow: 0 0 10px rgba(76, 175, 80, 0.5);">üéÆ Waiting for Players</h2>
        <div class="spinner"></div>
        <div id="waitingMessage" style="font-size: 20px; margin: 20px 0;">Waiting for players to join...</div>
        <div id="playerCount" style="font-size: 18px; color: #4CAF50;">Players joined: 1/3</div>
        <div style="margin-top: 30px; text-align: center;">
            <div style="font-size: 18px; color: #ccc; margin-bottom: 10px;">Room Code:</div>
            <div id="waitingRoomCode" style="font-family: monospace; color: #4CAF50; cursor: pointer; padding: 15px 25px; border: 3px solid #4CAF50; border-radius: 10px; font-size: 32px; font-weight: bold; letter-spacing: 4px; background: rgba(76, 175, 80, 0.1); transition: all 0.3s; display: inline-block;" onclick="copyRoomCode(this)" title="Click to copy" onmouseover="this.style.background='rgba(76, 175, 80, 0.2)'" onmouseout="this.style.background='rgba(76, 175, 80, 0.1)'"></div>
            <div style="font-size: 14px; color: #999; margin-top: 10px;">Click to copy ‚Ä¢ Share with other players</div>
        </div>
    </div>

    <div id="roleAssignmentScreen" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); text-align: center; background: rgba(0, 0, 0, 0.9); color: white; padding: 40px; border-radius: 20px; z-index: 2000; border: 3px solid #FFD700; box-shadow: 0 0 30px rgba(255, 215, 0, 0.5);">
        <h2 style="color: #FFD700; font-size: 32px; margin-bottom: 20px; text-shadow: 0 0 10px rgba(255, 215, 0, 0.5);">üé≤ Assigning Roles</h2>
        <div class="spinner" style="border-top-color: #FFD700;"></div>
        <div style="font-size: 20px; margin: 20px 0;">All players joined! Assigning roles...</div>
        <div style="font-size: 16px; color: #ccc;">Please wait while roles are being assigned</div>
    </div>

    <div id="yourRoleScreen" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); text-align: center; background: rgba(0, 0, 0, 0.9); color: white; padding: 40px; border-radius: 20px; z-index: 2000; border: 3px solid #FF6B6B; box-shadow: 0 0 30px rgba(255, 107, 107, 0.5);">
        <h2 style="color: #FF6B6B; font-size: 32px; margin-bottom: 20px; text-shadow: 0 0 10px rgba(255, 107, 107, 0.5);">üé≠ Your Role</h2>
        <div id="assignedRole" style="font-size: 36px; font-weight: bold; margin: 20px 0; color: #4CAF50;"></div>
        <div id="roleDescription" style="font-size: 18px; margin: 20px 0; line-height: 1.5;"></div>
        <div style="font-size: 16px; color: #FFD700; margin-top: 20px;">Game starting in 3 seconds...</div>
    </div>

    <div id="errorScreen">
        <h2>Error</h2>
        <div id="errorMessage"></div>
        <div id="debugInfo"></div>
        <button onclick="location.reload()" style="margin-top: 15px; padding: 10px 20px; cursor: pointer; background: white; color: red; border: none; border-radius: 5px; font-weight: bold;">Reload Game</button>
    </div>

    <div id="winScreen">
        <h2>üéâ You Won! üéâ</h2>
        <p>Congratulations! You made it through the maze!</p>
        <p>Refresh the page to play again</p>
    </div>

    <div id="guideView" style="display: none;">
        <canvas id="guideCanvas"></canvas>
        <div id="guideInstructions">
            Guide View - Help the player reach the green exit!
            <br>
            Player position is shown as a blue square
            <br>
            Monster position is shown as a red diamond
            <br>
            Exit is shown as a green square
        </div>
    </div>

    <script>
        let scene, camera, renderer, controls;
        let maze, mazeGroup;
        const MAZE_SIZE = { width: 25, height: 25 };
        let keydownListener, keyupListener;
        let textureLoader;
        let gameMode = 'single';
        let multiplayerManager = null;
        let otherPlayers = {};
        let gameStarted = false;
        let playerRole = null;
        let guideCanvas, guideCtx;
        let playerPositions = {}; // Track positions by player ID
        let monsterPositions = {}; // Track monster positions by player ID
        let allPlayersJoined = false;
        let requiredPlayers = 3;
        let roomCode = null;
        let lastPositionUpdate = 0;
        const POSITION_UPDATE_INTERVAL = 100; // Throttle position updates for better performance
        let monsterTexture = null;
        // Add smoothing state variables at the top of the file, after other variable declarations
        let lastPlayerPos = null;
        let lastMonsterPos = null;
        const positionSmoothingFactor = 0.3;
        const rotationSmoothingFactor = 0.3;
        // Performance optimization variables
        let lastArrowUpdate = 0;
        const ARROW_UPDATE_INTERVAL = 100; // Update arrow every 100ms for better performance
        let rotationBuffer = [];
        const ROTATION_BUFFER_SIZE = 3; // Reduce buffer size for memory efficiency

        function createMonsterMesh() {
            // Create a plane geometry that always faces the camera
            const monsterGeometry = new THREE.PlaneGeometry(2, 2);
            const monsterMaterial = new THREE.MeshBasicMaterial({
                map: textureLoader.load('monster.png'),
                transparent: true,
                side: THREE.DoubleSide
            });
            const monster = new THREE.Mesh(monsterGeometry, monsterMaterial);
            
            // Create a container for the monster to handle positioning
            const monsterContainer = new THREE.Object3D();
            monsterContainer.add(monster);
            
            // Make the monster plane always face the camera
            monster.onBeforeRender = function(renderer, scene, camera) {
                monster.quaternion.copy(camera.quaternion);
            };
            
            return monsterContainer;
        }

        function createRoom() {
            if (gameStarted) {
                console.log('Game already started, ignoring createRoom');
                return;
            }
            
            showLoadingScreen('Creating Room...');
            console.log('Creating room...');
            
            // Initialize multiplayer manager
            multiplayerManager = new MultiplayerManager();
            
            // Set up callbacks
            multiplayerManager.onConnectionSuccess = () => {
                console.log('Successfully connected, creating room...');
                multiplayerManager.createRoom();
            };

            multiplayerManager.onMazeDataReceived = (mazeData) => {
                console.log('üó∫Ô∏è Maze data received and loaded!', mazeData);
                maze = mazeData;
                maze.wallPositions = maze.wallPositions || [];
                
                // Now that we have maze data, we can safely initialize the scene
                console.log('üé¨ Initializing scene after maze data received');
                init(false);
            };

            multiplayerManager.onRoomCreated = (roomCode) => {
                console.log('Room created with code:', roomCode);
                hideLoadingScreen();
                
                // Hide all menus
                hideAllMenus();
                
                // Show waiting screen
                document.getElementById('waitingScreen').style.display = 'block';
                document.getElementById('waitingRoomCode').textContent = roomCode;
                document.getElementById('playerCount').textContent = 'Players joined: 1/3';
                document.getElementById('waitingMessage').textContent = 'Waiting for 2 more players to join...';
                
                // Set the game mode but don't start yet
                gameMode = 'multiplayer';
                playerRole = 'waiting';
                allPlayersJoined = false;
                gameStarted = false;
                
                // Host should generate maze data immediately and send it to server
                console.log('üè† Room created, host generating maze data...');
                const generator = new MazeGenerator(MAZE_SIZE.width, MAZE_SIZE.height);
                maze = generator.generate();
                
                // Send maze data to server for distribution to all players
                multiplayerManager.socket.send(JSON.stringify({
                    type: 'maze_data',
                    maze: maze
                }));
                
                console.log('üó∫Ô∏è Maze generated and sent to server');
                
                // Now initialize the scene
                init(false);
            };

            multiplayerManager.onPlayerJoined = (playerId, role) => {
                console.log('Player joined:', playerId, 'as', role);
                
                // Update player count
                const currentPlayers = Object.keys(otherPlayers).length + 2; // +2 because we're counting this new player
                document.getElementById('playerCount').textContent = `Players joined: ${currentPlayers}/3`;
                
                const playersNeeded = requiredPlayers - currentPlayers;
                if (playersNeeded > 0) {
                    document.getElementById('waitingMessage').textContent = `Waiting for ${playersNeeded} more player${playersNeeded > 1 ? 's' : ''} to join...`;
                } else {
                    // All players joined - show role assignment screen
                    document.getElementById('waitingScreen').style.display = 'none';
                    document.getElementById('roleAssignmentScreen').style.display = 'block';
                    
                    document.getElementById('waitingMessage').textContent = 'All players joined! Assigning roles...';
                }
                
                if (!otherPlayers[playerId] && (playerRole === 'player' || playerRole === 'monster')) {
                    console.log('Creating representation for player:', playerId, 'with role:', role);
                    
                    // Create a more visible representation for players
                    let playerMesh;
                    if (role === 'monster') {
                        // Monster representation for player's view
                        playerMesh = new THREE.Mesh(
                            new THREE.CylinderGeometry(0.3, 0.3, 2, 8),
                            new THREE.MeshPhongMaterial({ 
                                color: 0xff0000,
                                emissive: 0xff0000,
                                emissiveIntensity: 0.5
                            })
                        );
                    } else if (role === 'player' && playerRole === 'monster') {
                        // Player representation for monster's view - bright green cylinder
                        const playerGeometry = new THREE.Group();
                        
                        // Main body - taller and brighter cylinder
                        const body = new THREE.Mesh(
                            new THREE.CylinderGeometry(0.4, 0.4, 2.5, 8),
                            new THREE.MeshPhongMaterial({ 
                                color: 0x00ff00,
                                emissive: 0x00ff00,
                                emissiveIntensity: 0.5
                            })
                        );
                        playerGeometry.add(body);
                        
                        // Add glowing ring at the top
                        const ring = new THREE.Mesh(
                            new THREE.TorusGeometry(0.5, 0.1, 8, 16),
                            new THREE.MeshPhongMaterial({
                                color: 0xffff00,
                                emissive: 0xffff00,
                                emissiveIntensity: 0.7
                            })
                        );
                        ring.position.y = 1.5;
                        ring.rotation.x = Math.PI / 2;
                        playerGeometry.add(ring);
                        
                        playerMesh = playerGeometry;
                    }
                    
                    if (playerMesh) {
                        otherPlayers[playerId] = playerMesh;
                        otherPlayers[playerId].position.set(0, 1, 0);
                        otherPlayers[playerId].visible = true;
                        scene.add(otherPlayers[playerId]);
                        console.log('Added player representation to scene:', playerId);
                    }
                }
            };

            multiplayerManager.onRoleAssigned = (role, message) => {
                console.log('üé≠ Role assigned:', role, message);
                playerRole = role;
                
                // Hide role assignment screen and show your role screen
                document.getElementById('roleAssignmentScreen').style.display = 'none';
                document.getElementById('yourRoleScreen').style.display = 'block';
                
                // Update role information
                document.getElementById('assignedRole').textContent = role.toUpperCase();
                
                // Set role descriptions
                let description = '';
                switch(role) {
                    case 'player':
                        description = 'Navigate through the maze to find the green exit. Use WASD to move and mouse to look around. Avoid the monster!';
                        break;
                    case 'guide':
                        description = 'Help the player reach the exit using your top-down 2D view. You can see the entire maze layout and all player positions.';
                        break;
                    case 'monster':
                        description = 'Hunt the player in first-person view! Use WASD to move and mouse to look around. Catch the player before they escape!';
                        break;
                    default:
                        description = message || 'Unknown role';
                }
                document.getElementById('roleDescription').textContent = description;
                
                // DON'T initialize the scene yet - wait for onGameReady
                // This prevents race conditions with maze data loading
                console.log('üé≠ Role assigned, waiting for game ready signal...');
            };

            multiplayerManager.onGameReady = () => {
                console.log('üéÆ onGameReady called - Current role:', playerRole, 'Maze exists:', !!maze);
                allPlayersJoined = true;
                gameStarted = true;
                
                // Hide all UI screens
                hideAllMenus();
                
                // Wait for maze data if not available
                if (!maze) {
                    console.log('üéÆ No maze data yet, waiting...');
                    setTimeout(() => {
                        if (maze) {
                            console.log('üéÆ Maze data now available, starting game');
                            multiplayerManager.onGameReady();
                        } else {
                            console.error('üéÆ Still no maze data after waiting');
                        }
                    }, 100);
                    return;
                }
                
                // Add a 3-second countdown before starting
                setTimeout(() => {
                    // Force game start based on role
                    console.log('üéÆ Starting game for role:', playerRole);
                    if (playerRole === 'guide') {
                        console.log('üéÆ Starting GUIDE view');
                        initGuideView(maze);
                    } else if (playerRole === 'player' || playerRole === 'monster') {
                        console.log('üéÆ Starting 3D view for:', playerRole);
                        // Always call init(true) to ensure fresh initialization
                        init(true);
                    } else {
                        console.log('üéÆ Unknown role:', playerRole);
                    }
                    

                }, 3000);
            };

            multiplayerManager.onPlayerLeft = (playerId) => {
                if (otherPlayers[playerId]) {
                    scene.remove(otherPlayers[playerId]);
                    delete otherPlayers[playerId];
                }
                
                // Clean up position tracking for disconnected player
                delete playerPositions[playerId];
                delete monsterPositions[playerId];
                
                // Update UI to show disconnection and waiting state
                const currentPlayers = Object.keys(otherPlayers).length + 1;
                if (currentPlayers < requiredPlayers) {
                    allPlayersJoined = false;
                    gameStarted = false;
                    
                    // Show waiting message
                    const instructionsElement = document.getElementById('roomCodeInstructions');
                    instructionsElement.style.display = 'block';
                    instructionsElement.textContent = `A player has disconnected ‚Ä¢ Waiting for ${requiredPlayers - currentPlayers} more player${requiredPlayers - currentPlayers > 1 ? 's' : ''}...`;
                    
                    // Show room code again
                    const roomCodeElement = document.getElementById('roomCode');
                    roomCodeElement.style.display = 'block';
                }
            };

            multiplayerManager.onError = (error) => {
                console.error('Error in multiplayer:', error);
                hideLoadingScreen();
                alert(error);
                showMultiplayerMenu();
            };

            // Start connection
            multiplayerManager.connect();
        }

        function startMultiplayerGame() {
            if (!gameStarted) {
                console.log('Starting multiplayer game...');
                gameStarted = true;
                
                // Hide all menus
                document.getElementById('startScreen').style.display = 'none';
                document.getElementById('multiplayerMenu').style.display = 'none';
                document.getElementById('winScreen').style.display = 'none';
                
                // Set up multiplayer components
                setupMultiplayer();
                
                // Start the animation loop
                animate();
            }
        }

        function startGame(mode = 'single') {
            if (mode === 'multiplayer') {
                console.log('Redirecting multiplayer start to startMultiplayerGame');
                startMultiplayerGame();
                return;
            }
            
            console.log('Starting single player game...');
            gameStarted = false; // Reset first
            playerRole = 'player'; // Set role for single player
            
            // Hide ALL menu elements
            hideAllMenus();
            
            // Remove old renderer and clean up
            cleanupRenderer();

            // Clean up old multiplayer resources
            cleanupMultiplayer();
            
            // Start fresh game
            gameStarted = true;
            gameMode = mode;
            init();
        }

        function hideAllMenus() {
            const menuElements = [
                'startScreen',
                'multiplayerMenu',
                'winScreen',
                'roomCode',
                'roomCodeInstructions',
                'loadingScreen',
                'errorScreen',
                'guideView',
                'waitingScreen',
                'roleAssignmentScreen',
                'yourRoleScreen',
                'simple-waiting'
            ];
            
            menuElements.forEach(elementId => {
                const element = document.getElementById(elementId);
                if (element) {
                    element.style.display = 'none';
                }
            });
        }

        function cleanupRenderer() {
            if (window.animationFrameId) {
                cancelAnimationFrame(window.animationFrameId);
                window.animationFrameId = null;
            }
            
            if (renderer && renderer.domElement && renderer.domElement.parentNode) {
                // Remove pointer lock event listeners
                document.removeEventListener('pointerlockchange', onPointerLockChange);
                document.removeEventListener('pointerlockerror', onPointerLockError);
                document.removeEventListener('mousemove', onMouseMove);
                
                // Exit pointer lock if active
                if (document.pointerLockElement === renderer.domElement) {
                    document.exitPointerLock();
                }
                
                renderer.domElement.parentNode.removeChild(renderer.domElement);
                renderer.dispose();
                renderer = null;
            }
            
            // Clean up event listeners
            if (keydownListener) {
                document.removeEventListener('keydown', keydownListener);
                keydownListener = null;
            }
            if (keyupListener) {
                document.removeEventListener('keyup', keyupListener);
                keyupListener = null;
            }
        }

        function cleanupMultiplayer() {
            if (multiplayerManager) {
                multiplayerManager.disconnect();
                multiplayerManager = null;
            }
        }

        function init(shouldStartAnimation = true) {
            console.log('üé¨ INIT CALLED: mode=', gameMode, 'role=', playerRole, 'shouldStartAnimation=', shouldStartAnimation, 'mazeExists=', !!maze);
            
            try {
                // Only guide gets the 2D view
                if (playerRole === 'guide') {
                    console.log('üéÆ Initializing GUIDE view...');
                    // Initialize guide view
                    document.body.style.cursor = 'default';
                    if (maze) {
                        console.log('üó∫Ô∏è Maze data available for guide, calling initGuideView');
                        initGuideView(maze);
                    } else {
                        console.error('‚ùå No maze data available for guide view');
                        document.body.innerHTML = '<div style="color: red; text-align: center; margin-top: 50px;">Error: No maze data available. Please try refreshing the page.</div>';
                    }
                    return;
                }

                console.log('üéÆ Initializing 3D view for role:', playerRole);

                // Both player and monster get the same 3D setup
                console.log('üé® Creating THREE.js scene...');
                scene = new THREE.Scene();
                scene.background = new THREE.Color(0x000000);
                
                // Create renderer
                console.log('üñ•Ô∏è Creating WebGL renderer...');
                renderer = new THREE.WebGLRenderer({ 
                    antialias: true,
                    powerPreference: "high-performance"
                });
                renderer.setSize(window.innerWidth, window.innerHeight);
                renderer.setPixelRatio(window.devicePixelRatio);
                
                // Style the renderer canvas properly
                renderer.domElement.style.position = 'fixed';
                renderer.domElement.style.top = '0';
                renderer.domElement.style.left = '0';
                renderer.domElement.style.width = '100%';
                renderer.domElement.style.height = '100%';
                renderer.domElement.style.zIndex = '1';
                renderer.domElement.style.display = 'block';
                
                document.body.appendChild(renderer.domElement);
                console.log('üñ•Ô∏è Renderer canvas added to DOM');
                
                // Create first-person camera
                camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
                
                // Load textures
                textureLoader = new THREE.TextureLoader();
                
                // Generate new maze only for single player mode
                if (gameMode === 'single' && !maze) {
                    const generator = new MazeGenerator(MAZE_SIZE.width, MAZE_SIZE.height);
                    maze = generator.generate();
                    console.log('‚úÖ Generated maze for single player mode');
                }
                
                if (!maze) {
                    console.error('‚ùå No maze data available when trying to init 3D view');
                    throw new Error('No maze data available');
                }
                console.log('‚úÖ Maze data is available for 3D view');

                // Clean up any existing role labels first
                const existingLabels = document.querySelectorAll('.role-label');
                existingLabels.forEach(label => label.remove());

                // Set starting position based on role
                if (playerRole === 'monster') {
                    // Place monster at a random position
                    const randomCell = getRandomEmptyCell(maze);
                    camera.position.set(
                        randomCell.x * maze.cellSize,
                        1.5,
                        randomCell.z * maze.cellSize
                    );
                    console.log('Monster spawned at:', camera.position);

                    // Add monster UI overlay
                    const monsterInstructions = document.createElement('div');
                    monsterInstructions.className = 'role-label';
                    monsterInstructions.style.cssText = `
                        position: fixed;
                        top: 20px;
                        left: 20px;
                        color: #ff0000;
                        font-size: 18px;
                        text-shadow: 0 0 5px rgba(255, 0, 0, 0.5);
                        z-index: 1000;
                    `;
                    monsterInstructions.innerHTML = `Monster View`;
                    document.body.appendChild(monsterInstructions);
                } else if (playerRole === 'player') {
                    // Set player starting position
                    camera.position.set(
                        maze.startPosition.x,
                        1.5,
                        maze.startPosition.z
                    );
                    console.log('Player spawned at:', camera.position);

                    // Add player UI overlay
                    const playerInstructions = document.createElement('div');
                    playerInstructions.className = 'role-label';
                    playerInstructions.style.cssText = `
                        position: fixed;
                        top: 20px;
                        left: 20px;
                        color: #4CAF50;
                        font-size: 18px;
                        text-shadow: 0 0 5px rgba(76, 175, 80, 0.5);
                        z-index: 1000;
                    `;
                    playerInstructions.innerHTML = `Player`;
                    document.body.appendChild(playerInstructions);
                }

                // Make sure guide view is hidden for both player and monster
                const guideView = document.getElementById('guideView');
                if (guideView) {
                    guideView.style.display = 'none';
                }
                
                // Generate maze geometry
                mazeGroup = new THREE.Group();
                generateNewMaze();
                
                // Set up controls
                controls = setupControls();
                
                // Only start animation and game if requested
                if (shouldStartAnimation) {
                    console.log('üé¨ Starting animation and game...');
                    gameStarted = true;
                    animate();
                    
                    // Request pointer lock for both player and monster
                    renderer.domElement.requestPointerLock();
                    console.log('üé¨ Animation started and pointer lock requested');
                } else {
                    gameStarted = false;
                    console.log('üé¨ Game initialized but not started - waiting for all players');
                }
                
                console.log('Game initialized in mode:', gameMode, 'role:', playerRole, 'with first-person view');
            } catch (error) {
                console.error('‚ùå Error initializing game:', error);
                // Show detailed error information
                const errorDiv = document.createElement('div');
                errorDiv.style.cssText = `
                    position: fixed;
                    top: 50%;
                    left: 50%;
                    transform: translate(-50%, -50%);
                    background: rgba(0, 0, 0, 0.9);
                    color: white;
                    padding: 20px;
                    border-radius: 10px;
                    text-align: center;
                    z-index: 9999;
                    max-width: 80%;
                `;
                errorDiv.innerHTML = `
                    <h3>üö® Game Initialization Error</h3>
                    <p>Role: ${playerRole || 'Unknown'}</p>
                    <p>Maze available: ${!!maze ? 'Yes' : 'No'}</p>
                    <p>Scene exists: ${!!scene ? 'Yes' : 'No'}</p>
                    <p>Error: ${error.message}</p>
                    <button onclick="location.reload()" style="margin-top: 15px; padding: 10px 20px; background: #ff4444; color: white; border: none; border-radius: 5px; cursor: pointer;">
                        Reload Game
                    </button>
                `;
                document.body.appendChild(errorDiv);
            }
        }

        function generateNewMaze() {
            if (mazeGroup) {
                // Remove all objects from the scene
                while(scene.children.length > 0){ 
                    scene.remove(scene.children[0]); 
                }
                mazeGroup = new THREE.Group();
            }

            // Initialize maze.wallPositions array
            if (!maze.wallPositions) {
                maze.wallPositions = [];
            }

            mazeGroup = new THREE.Group();
            
            // Add static lights in a sparser grid pattern
            const mazeWidth = MAZE_SIZE.width * maze.cellSize;
            const mazeHeight = MAZE_SIZE.height * maze.cellSize;
            
            // Calculate positions for a few strategic lights
            const lights = [
                // Center light
                {x: 0, z: 0, intensity: 8.0, distance: 70},
                
                // Four quadrant lights
                {x: -mazeWidth/4, z: -mazeHeight/4, intensity: 6.0, distance: 50},
                {x: mazeWidth/4, z: -mazeHeight/4, intensity: 6.0, distance: 50},
                {x: -mazeWidth/4, z: mazeHeight/4, intensity: 6.0, distance: 50},
                {x: mazeWidth/4, z: mazeHeight/4, intensity: 6.0, distance: 50},
                
                // Additional corner lights
                {x: -mazeWidth/2, z: -mazeHeight/2, intensity: 5.0, distance: 40},
                {x: mazeWidth/2, z: -mazeHeight/2, intensity: 5.0, distance: 40},
                {x: -mazeWidth/2, z: mazeHeight/2, intensity: 5.0, distance: 40},
                {x: mazeWidth/2, z: mazeHeight/2, intensity: 5.0, distance: 40}
            ];
            
            // Add brighter ambient light for better overall visibility
            const ambientLight = new THREE.AmbientLight(0xffffff, 3.0);
            scene.add(ambientLight);
            
            // Add all lights
            lights.forEach(light => {
                const pointLight = new THREE.PointLight(0xffffff, light.intensity, light.distance);
                pointLight.position.set(light.x, 3.5, light.z);
                scene.add(pointLight);
            });

            // Load textures
            const wallTexture = textureLoader.load('wall.jpg');
            wallTexture.wrapS = wallTexture.wrapT = THREE.RepeatWrapping;
            wallTexture.repeat.set(1, 1);

            // Create wall geometry and material only once for better performance
            const wallGeometry = new THREE.BoxGeometry(maze.cellSize, maze.wallHeight, maze.cellSize);
            const wallMaterial = new THREE.MeshPhongMaterial({
                map: wallTexture,
                color: 0xcccccc,
                specular: 0x222222,
                shininess: 10,
                transparent: false,
                opacity: 1.0,
                side: THREE.FrontSide,
                depthWrite: true,
                depthTest: true
            });

            // Clear existing walls array
            maze.wallPositions = [];

            function addWall(x, z) {
                const wall = new THREE.Mesh(wallGeometry, wallMaterial);
                wall.position.set(x * maze.cellSize, maze.wallHeight / 2, z * maze.cellSize);
                wall.castShadow = true;
                wall.receiveShadow = true;
                wall.matrixAutoUpdate = false; // Optimize performance
                wall.updateMatrix();
                mazeGroup.add(wall);
                
                maze.wallPositions.push({ x: x * maze.cellSize, z: z * maze.cellSize });
            }

            // Clear existing walls
            while(mazeGroup.children.length > 0) {
                const obj = mazeGroup.children[0];
                obj.geometry.dispose();
                obj.material.dispose();
                mazeGroup.remove(obj);
            }

            // Add maze walls
            for (let y = 0; y < MAZE_SIZE.height; y++) {
                for (let x = 0; x < MAZE_SIZE.width; x++) {
                    if (maze.maze[y][x] === 1) {
                        addWall(x, y);
                    }
                }
            }

            // Add boundary walls
            for (let x = -1; x <= MAZE_SIZE.width; x++) {
                addWall(x, -1);
                addWall(x, MAZE_SIZE.height);
            }

            for (let z = -1; z <= MAZE_SIZE.height; z++) {
                addWall(-1, z);
                addWall(MAZE_SIZE.width, z);
            }

            // Add floor
            const floorGeometry = new THREE.PlaneGeometry(
                (MAZE_SIZE.width + 2) * maze.cellSize,
                (MAZE_SIZE.height + 2) * maze.cellSize
            );
            const floorMaterial = new THREE.MeshPhongMaterial({
                color: 0x808080,  // Lighter floor color
                specular: 0x222222,
                shininess: 10,
                side: THREE.FrontSide,
                depthWrite: true
            });
            const floor = new THREE.Mesh(floorGeometry, floorMaterial);
            floor.rotation.x = -Math.PI / 2;
            floor.position.set(
                (MAZE_SIZE.width * maze.cellSize) / 2,
                0,
                (MAZE_SIZE.height * maze.cellSize) / 2
            );
            mazeGroup.add(floor);

            // Add end marker with improved material
            const endMarkerGeometry = new THREE.CylinderGeometry(0.4, 0.4, 0.1, 32);
            const endMarkerMaterial = new THREE.MeshPhongMaterial({ 
                color: 0x00ff00,
                emissive: 0x00ff00,
                emissiveIntensity: 0.5,
                transparent: false,
                opacity: 1.0,
                depthWrite: true
            });
            const endMarker = new THREE.Mesh(endMarkerGeometry, endMarkerMaterial);
            
            // Place end marker at the correct world position (don't multiply by cellSize again)
            endMarker.position.set(
                maze.endPosition.x,
                0.05,
                maze.endPosition.z
            );
            
            // Add point light to end marker for glow
            const endLight = new THREE.PointLight(0x00ff00, 1, 5);
            endLight.position.copy(endMarker.position);
            endLight.position.y = 1;
            
            mazeGroup.add(endMarker);
            mazeGroup.add(endLight);

            // Add the entire maze group to the scene
            scene.add(mazeGroup);
        }

        function checkCollision(position) {
            if (!maze || !maze.wallPositions || !Array.isArray(maze.wallPositions)) {
                console.log('Maze or wall positions not properly initialized');
                return { x: false, z: false };
            }

            const playerRadius = 0.5;
            const wallBuffer = 0.3;
            let collisionX = false;
            let collisionZ = false;
            let nearestWallDist = Infinity;
            let slideX = 0;
            let slideZ = 0;
            
            // Check collision with each wall
            for (const wall of maze.wallPositions) {
                // Calculate distances for each axis
                const dx = position.x - wall.x;
                const dz = position.z - wall.z;
                const distance = Math.sqrt(dx * dx + dz * dz);
                
                // Calculate the minimum distance needed to avoid collision
                const minDistance = maze.cellSize / 2 + playerRadius + wallBuffer;
                
                // If we're within collision range
                if (distance < minDistance) {
                    // Update nearest wall distance
                    if (distance < nearestWallDist) {
                        nearestWallDist = distance;
                        
                        // Calculate normalized direction from wall to player
                        const nx = dx / distance;
                        const nz = dz / distance;
                        
                        // Calculate slide vector
                        const penetration = minDistance - distance;
                        slideX = nx * penetration;
                        slideZ = nz * penetration;
                    }
                    
                    // Set collision flags based on approach angle
                    const dotX = Math.abs(dx / distance);
                    const dotZ = Math.abs(dz / distance);
                    
                    if (dotX > 0.7) collisionX = true;
                    if (dotZ > 0.7) collisionZ = true;
                }
            }
            
            return {
                x: collisionX,
                z: collisionZ,
                slideX: slideX,
                slideZ: slideZ
            };
        }

        function setupControls() {
            const moveSpeed = playerRole === 'monster' ? 0.1 : 0.15;
            const turnSpeed = 0.06;
            let isPointerLocked = false;
            
            const controls = {
                enabled: true,
                update: null
            };
            
            const keys = {
                forward: false,
                backward: false,
                left: false,
                right: false
            };

            // Remove any existing listeners
            if (keydownListener) document.removeEventListener('keydown', keydownListener);
            if (keyupListener) document.removeEventListener('keyup', keyupListener);

            function onMouseMove(event) {
                if (isPointerLocked && gameStarted && (playerRole === 'player' || playerRole === 'monster')) {
                    camera.rotation.y -= event.movementX * 0.002;
                }
            }

            function onPointerLockChange() {
                isPointerLocked = document.pointerLockElement === renderer.domElement;
            }

            function onPointerLockError() {
                console.error('Pointer lock error');
            }

            document.addEventListener('pointerlockchange', onPointerLockChange);
            document.addEventListener('pointerlockerror', onPointerLockError);
            document.addEventListener('mousemove', onMouseMove);

            if (renderer && renderer.domElement) {
                renderer.domElement.addEventListener('click', () => {
                    if (!isPointerLocked) {
                        renderer.domElement.requestPointerLock();
                    }
                });
            }

            document.addEventListener('keydown', (e) => {
                if (e.key === 'Escape' && isPointerLocked) {
                    document.exitPointerLock();
                }
            });

            keydownListener = (e) => {
                switch(e.key.toLowerCase()) {
                    case 'w':
                    case 'arrowup':
                        keys.forward = true;
                        break;
                    case 's':
                    case 'arrowdown':
                        keys.backward = true;
                        break;
                    case 'a':
                    case 'arrowleft':
                        keys.left = true;
                        break;
                    case 'd':
                    case 'arrowright':
                        keys.right = true;
                        break;
                }
            };

            keyupListener = (e) => {
                switch(e.key.toLowerCase()) {
                    case 'w':
                    case 'arrowup':
                        keys.forward = false;
                        break;
                    case 's':
                    case 'arrowdown':
                        keys.backward = false;
                        break;
                    case 'a':
                    case 'arrowleft':
                        keys.left = false;
                        break;
                    case 'd':
                    case 'arrowright':
                        keys.right = false;
                        break;
                }
            };

            document.addEventListener('keydown', keydownListener);
            document.addEventListener('keyup', keyupListener);

            controls.update = function updateControls() {
                if (!controls.enabled || !camera || !maze) return;

                const moveSpeed = playerRole === 'monster' ? 0.1 : 0.15;
                const turnSpeed = 0.06;
                const newPosition = camera.position.clone();
                const oldPosition = camera.position.clone();

                // Calculate movement vector
                let moveVector = new THREE.Vector3(0, 0, 0);
                if (keys.forward) {
                    moveVector.x -= Math.sin(camera.rotation.y) * moveSpeed;
                    moveVector.z -= Math.cos(camera.rotation.y) * moveSpeed;
                }
                if (keys.backward) {
                    moveVector.x += Math.sin(camera.rotation.y) * moveSpeed;
                    moveVector.z += Math.cos(camera.rotation.y) * moveSpeed;
                }
                if (keys.left) {
                    camera.rotation.y += turnSpeed;
                }
                if (keys.right) {
                    camera.rotation.y -= turnSpeed;
                }

                // Apply movement and check collision
                if (moveVector.length() > 0) {
                    // Try to move to new position
                    const targetPos = {
                        x: newPosition.x + moveVector.x,
                        z: newPosition.z + moveVector.z
                    };
                    
                    // Check collision at target position
                    const collision = checkCollision(targetPos);
                    
                    // If there's a collision, try to slide along walls
                    if (collision.x || collision.z) {
                        if (!collision.x) newPosition.x = targetPos.x;
                        if (!collision.z) newPosition.z = targetPos.z;
                        
                        // Apply sliding motion if available
                        if (collision.slideX || collision.slideZ) {
                            newPosition.x += collision.slideX * 0.5;
                            newPosition.z += collision.slideZ * 0.5;
                        }
                    } else {
                        // No collision, move freely
                        newPosition.x = targetPos.x;
                        newPosition.z = targetPos.z;
                    }
                }

                // Update position and send update if changed
                camera.position.copy(newPosition);
                
                if (camera.position.x !== oldPosition.x || camera.position.z !== oldPosition.z) {
                    if (multiplayerManager && multiplayerManager.connected) {
                        multiplayerManager.sendPosition(camera.position, camera.rotation);
                    }
                }
            };

            return controls;
        }

        function showWinScreen() {
            document.getElementById('winScreen').style.display = 'block';
            // Reset game state
            gameStarted = false;
        }

        // Show the multiplayer menu
        function showMultiplayerMenu() {
            console.log('Showing multiplayer menu');
            if (gameStarted) {
                console.log('Game in progress, cleaning up first');
                cleanupRenderer();
                cleanupMultiplayer();
            }
            
            gameStarted = false;
            gameMode = 'single'; // Reset game mode
            hideAllMenus();
            document.getElementById('multiplayerMenu').style.display = 'block';
            document.getElementById('createRoomButton').style.display = 'block';
            document.getElementById('joinRoomButton').style.display = 'block';
        }

        // Show join room input
        function showJoinRoom() {
            document.getElementById('createRoomButton').style.display = 'none';
            document.getElementById('joinRoomButton').style.display = 'none';
            document.getElementById('roomCodeInput').style.display = 'block';
            document.getElementById('roomCodeInput').value = '';
        }

        function joinRoom() {
            const roomCode = document.getElementById('roomCodeInput').value.trim().toUpperCase();
            if (!roomCode) {
                alert('Please enter a room code');
                return;
            }

            showLoadingScreen('Joining Room...');
            console.log('Attempting to join room:', roomCode);
            
            // Initialize multiplayer manager
            multiplayerManager = new MultiplayerManager();
            
            // Set up callbacks
            multiplayerManager.onConnectionSuccess = () => {
                console.log('Successfully connected to server, attempting to join room:', roomCode);
                multiplayerManager.joinRoom(roomCode);
            };

            multiplayerManager.onMazeDataReceived = (mazeData) => {
                console.log('üó∫Ô∏è Maze data received and loaded!', mazeData);
                maze = mazeData;
                maze.wallPositions = maze.wallPositions || [];
                
                // Now that we have maze data, we can safely initialize the scene
                console.log('üé¨ Initializing scene after maze data received');
                init(false);
            };

            multiplayerManager.onRoomJoined = () => {
                console.log('Successfully joined room:', roomCode);
                hideLoadingScreen();
                
                // Hide all menus
                hideAllMenus();
                
                // Show simple waiting message
                const waitingDiv = document.createElement('div');
                waitingDiv.id = 'simple-waiting';
                waitingDiv.style.cssText = `
                    position: fixed;
                    top: 50%;
                    left: 50%;
                    transform: translate(-50%, -50%);
                    color: white;
                    font-size: 24px;
                    text-align: center;
                    z-index: 1000;
                `;
                waitingDiv.innerHTML = 'Waiting for players...';
                document.body.appendChild(waitingDiv);
                
                // Set the game mode but don't start yet
                gameMode = 'multiplayer';
                playerRole = 'waiting';
                allPlayersJoined = false;
                gameStarted = false;
                
                console.log('üè† Room joined, showing simple waiting message...');
            };

            // Add the same event handlers as createRoom
            multiplayerManager.onPlayerJoined = (playerId, role) => {
                console.log('Player joined:', playerId, 'as', role);
                
                // For joinRoom, just wait silently - no UI updates needed
                const currentPlayers = Object.keys(otherPlayers).length + 2;
                const playersNeeded = requiredPlayers - currentPlayers;
                
                if (playersNeeded > 0) {
                    console.log(`Waiting for ${playersNeeded} more player${playersNeeded > 1 ? 's' : ''} to join...`);
                } else {
                    console.log('All players joined! Waiting for role assignment...');
                }
            };

            multiplayerManager.onRoleAssigned = (role, message) => {
                console.log('üé≠ Role assigned:', role, message);
                playerRole = role;
                
                // Remove simple waiting message if it exists
                const simpleWaiting = document.getElementById('simple-waiting');
                if (simpleWaiting) {
                    simpleWaiting.remove();
                }
                
                // Hide role assignment screen and show your role screen
                document.getElementById('roleAssignmentScreen').style.display = 'none';
                document.getElementById('yourRoleScreen').style.display = 'block';
                
                // Update role information
                document.getElementById('assignedRole').textContent = role.toUpperCase();
                
                // Set role descriptions
                let description = '';
                switch(role) {
                    case 'player':
                        description = 'Navigate through the maze to find the green exit. Use WASD to move and mouse to look around. Avoid the monster!';
                        break;
                    case 'guide':
                        description = 'Help the player reach the exit using your top-down 2D view. You can see the entire maze layout and all player positions.';
                        break;
                    case 'monster':
                        description = 'Hunt the player in first-person view! Use WASD to move and mouse to look around. Catch the player before they escape!';
                        break;
                    default:
                        description = message || 'Unknown role';
                }
                document.getElementById('roleDescription').textContent = description;
                
                // DON'T initialize the scene yet - wait for onGameReady
                console.log('üé≠ Role assigned, waiting for game ready signal...');
            };

            multiplayerManager.onGameReady = () => {
                console.log('üéÆ onGameReady called - Current role:', playerRole, 'Maze exists:', !!maze);
                allPlayersJoined = true;
                gameStarted = true;
                
                // Hide all UI screens
                hideAllMenus();
                
                // Wait for maze data if not available
                if (!maze) {
                    console.log('üéÆ No maze data yet, waiting...');
                    setTimeout(() => {
                        if (maze) {
                            console.log('üéÆ Maze data now available, starting game');
                            multiplayerManager.onGameReady();
                        } else {
                            console.error('üéÆ Still no maze data after waiting');
                        }
                    }, 100);
                    return;
                }
                
                // Add a 3-second countdown before starting
                setTimeout(() => {
                    // Force game start based on role
                    console.log('üéÆ Starting game for role:', playerRole);
                    if (playerRole === 'guide') {
                        console.log('üéÆ Starting GUIDE view');
                        initGuideView(maze);
                    } else if (playerRole === 'player' || playerRole === 'monster') {
                        console.log('üéÆ Starting 3D view for:', playerRole);
                        // Always call init(true) to ensure fresh initialization
                        init(true);
                    } else {
                        console.log('üéÆ Unknown role:', playerRole);
                    }
                }, 3000);
            };

            multiplayerManager.onError = (error) => {
                console.error('Error joining room:', error);
                hideLoadingScreen();
                alert('Error joining room: ' + error);
                showMultiplayerMenu();
            };

            // Start connection
            multiplayerManager.connect();
        }

        function showLoadingScreen(message = 'Loading Game...') {
            document.getElementById('loadingMessage').textContent = message;
            document.getElementById('loadingScreen').style.display = 'block';
        }

        function hideLoadingScreen() {
            document.getElementById('loadingScreen').style.display = 'none';
        }

        function setupMultiplayer() {
            console.log('Setting up multiplayer components with role:', playerRole);
            
            // Create other player representation based on role
            if (playerRole === 'player' || playerRole === 'monster') {
                let otherPlayerMesh;
                if (playerRole === 'monster') {
                    // Create player representation for monster's view
                    const playerGeometry = new THREE.Group();
                    
                    // Main body - taller and brighter cylinder
                    const body = new THREE.Mesh(
                        new THREE.CylinderGeometry(0.4, 0.4, 2.5, 8),
                        new THREE.MeshPhongMaterial({ 
                            color: 0x00ff00,
                            emissive: 0x00ff00,
                            emissiveIntensity: 0.5
                        })
                    );
                    playerGeometry.add(body);
                    
                    // Add glowing ring at the top
                    const ring = new THREE.Mesh(
                        new THREE.TorusGeometry(0.5, 0.1, 8, 16),
                        new THREE.MeshPhongMaterial({
                            color: 0xffff00,
                            emissive: 0xffff00,
                            emissiveIntensity: 0.7
                        })
                    );
                    ring.position.y = 1.5;
                    ring.rotation.x = Math.PI / 2;
                    playerGeometry.add(ring);
                    
                    otherPlayerMesh = playerGeometry;
                } else {
                    // Monster representation for player's view
                    otherPlayerMesh = new THREE.Mesh(
                        new THREE.CylinderGeometry(0.3, 0.3, 2, 8),
                        new THREE.MeshPhongMaterial({ 
                            color: 0xff0000,
                            emissive: 0xff0000,
                            emissiveIntensity: 0.5
                        })
                    );
                }
                
                otherPlayers[multiplayerManager.playerId] = otherPlayerMesh;
                otherPlayers[multiplayerManager.playerId].position.set(0, 1, 0);
                otherPlayers[multiplayerManager.playerId].visible = true;
                scene.add(otherPlayers[multiplayerManager.playerId]);
            }

            // Set up multiplayer event handlers
            multiplayerManager.onPlayerJoined = (playerId, role) => {
                console.log('Player joined:', playerId, 'as', role);
                if (!otherPlayers[playerId] && (playerRole === 'player' || playerRole === 'monster')) {
                    console.log('Creating representation for player:', playerId, 'with role:', role);
                    
                    // Create a more visible representation for players
                    let playerMesh;
                    if (role === 'monster') {
                        // Monster representation
                        playerMesh = new THREE.Mesh(
                            new THREE.CylinderGeometry(0.3, 0.3, 2, 8),
                            new THREE.MeshPhongMaterial({ 
                                color: 0xff0000,
                                emissive: 0xff0000,
                                emissiveIntensity: 0.5
                            })
                        );
                    } else {
                        // Player representation - more visible for monster
                        const playerGeometry = new THREE.Group();
                        
                        // Main body - taller and brighter cylinder
                        const body = new THREE.Mesh(
                            new THREE.CylinderGeometry(0.4, 0.4, 2.5, 8),
                            new THREE.MeshPhongMaterial({ 
                                color: 0x00ff00,
                                emissive: 0x00ff00,
                                emissiveIntensity: 0.5
                            })
                        );
                        playerGeometry.add(body);
                        
                        // Add glowing ring at the top
                        const ring = new THREE.Mesh(
                            new THREE.TorusGeometry(0.5, 0.1, 8, 16),
                            new THREE.MeshPhongMaterial({
                                color: 0xffff00,
                                emissive: 0xffff00,
                                emissiveIntensity: 0.7
                            })
                        );
                        ring.position.y = 1.5;
                        ring.rotation.x = Math.PI / 2;
                        playerGeometry.add(ring);
                        
                        playerMesh = playerGeometry;
                    }
                    
                    otherPlayers[playerId] = playerMesh;
                    otherPlayers[playerId].position.set(0, 1, 0);
                    otherPlayers[playerId].visible = true;
                    scene.add(otherPlayers[playerId]);
                    
                    console.log('Added player representation to scene:', playerId);
                }
            };

            multiplayerManager.onPlayerLeft = (playerId) => {
                console.log('Player left:', playerId);
                if (otherPlayers[playerId]) {
                    scene.remove(otherPlayers[playerId]);
                    delete otherPlayers[playerId];
                }
            };

            multiplayerManager.onPlayerMove = (playerId, position, rotation) => {
                console.log('Received player move:', playerId, position, rotation);
                if (otherPlayers[playerId]) {
                    otherPlayers[playerId].visible = true;
                    otherPlayers[playerId].position.set(position.x, position.y, position.z);
                    otherPlayers[playerId].rotation.set(rotation.x, rotation.y, rotation.z);
                }
            };
        }

        function copyRoomCode(element) {
            const code = element.textContent;
            navigator.clipboard.writeText(code).then(() => {
                element.classList.add('copied');
                setTimeout(() => element.classList.remove('copied'), 500);
            });
        }

        function initGuideView(mazeData) {
            try {
                if (!mazeData) throw new Error('No maze data provided');
                console.log('üó∫Ô∏è Initializing guide view with maze data:', mazeData);

                // Clean up
                if (renderer?.domElement?.parentNode) {
                    renderer.domElement.parentNode.removeChild(renderer.domElement);
                    renderer.dispose();
                }

                // Hide other screens
                ['startScreen', 'multiplayerMenu', 'winScreen', 'loadingScreen'].forEach(id => {
                    const element = document.getElementById(id);
                    if (element) element.style.display = 'none';
                });

                // Setup guide container
                const guideView = document.getElementById('guideView');
                guideView.style.cssText = `
                    position: fixed;
                    top: 0;
                    left: 0;
                    width: 100vw;
                    height: 100vh;
                    display: flex;
                    justify-content: center;
                    align-items: center;
                    background-color: #000000;
                `;
                guideView.style.display = 'block';

                // Setup canvas
                guideCanvas = document.getElementById('guideCanvas');
                guideCtx = guideCanvas.getContext('2d', { alpha: false });

                // Calculate optimal size
                const margin = 80;
                const maxWidth = window.innerWidth - margin * 2;
                const maxHeight = window.innerHeight - margin * 2;
                
                // Calculate cell size to maintain aspect ratio
                const mazeWidth = mazeData.maze[0].length;
                const mazeHeight = mazeData.maze.length;
                const cellSizeX = Math.floor(maxWidth / mazeWidth);
                const cellSizeY = Math.floor(maxHeight / mazeHeight);
                const cellSize = Math.min(cellSizeX, cellSizeY);

                // Set canvas size
                guideCanvas.width = mazeWidth * cellSize + margin * 2;
                guideCanvas.height = mazeHeight * cellSize + margin * 2;

                // Store settings globally
                window.guideViewConfig = {
                    cellSize,
                    margin,
                    mazeWidth,
                    mazeHeight,
                    worldCellSize: mazeData.cellSize
                };

                // Initial draw
                drawGuideView(mazeData, null, null);
                gameStarted = true;

            } catch (error) {
                console.error('Guide view error:', error);
                const msg = document.createElement('div');
                msg.style.cssText = 'position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);background:rgba(0,0,0,0.8);color:red;padding:20px;border-radius:10px;text-align:center;';
                msg.innerHTML = `Error: ${error.message}<br><button onclick="location.reload()" style="margin-top:15px;padding:10px;background:white;color:red;border:none;border-radius:5px;cursor:pointer;">Reload</button>`;
                document.body.appendChild(msg);
            }
        }

        function smoothPosition(current, last) {
            if (!last) return current;
            return {
                x: last.x + (current.x - last.x) * positionSmoothingFactor,
                y: last.y + (current.y - last.y) * positionSmoothingFactor,
                z: last.z + (current.z - last.z) * positionSmoothingFactor,
                rotation: {
                    x: last.rotation?.x + (current.rotation?.x - last.rotation?.x) * rotationSmoothingFactor || current.rotation?.x,
                    y: last.rotation?.y + (current.rotation?.y - last.rotation?.y) * rotationSmoothingFactor || current.rotation?.y,
                    z: last.rotation?.z + (current.rotation?.z - last.rotation?.z) * rotationSmoothingFactor || current.rotation?.z
                }
            };
        }

        function drawGuideView(mazeData, playerPos, monsterPos) {
            if (!mazeData || !mazeData.maze) return;
            
            const config = window.guideViewConfig;
            if (!config) return;

            // Apply position smoothing
            if (playerPos) {
                if (!lastPlayerPos) {
                    lastPlayerPos = { ...playerPos };
                } else {
                    playerPos = smoothPosition(playerPos, lastPlayerPos);
                    lastPlayerPos = { ...playerPos };
                }
            }
            
            if (monsterPos) {
                if (!lastMonsterPos) {
                    lastMonsterPos = { ...monsterPos };
                } else {
                    monsterPos = smoothPosition(monsterPos, lastMonsterPos);
                    lastMonsterPos = { ...monsterPos };
                }
            }

            const { cellSize, margin, worldCellSize } = config;

            // Create an off-screen canvas for double buffering
            const offscreenCanvas = document.createElement('canvas');
            offscreenCanvas.width = guideCanvas.width;
            offscreenCanvas.height = guideCanvas.height;
            const offscreenCtx = offscreenCanvas.getContext('2d', { alpha: false });
            
            // Enable image smoothing for smoother rendering
            offscreenCtx.imageSmoothing = true;
            offscreenCtx.imageSmoothingQuality = 'high';

            // Clear offscreen canvas with a solid color
            offscreenCtx.fillStyle = '#000000';
            offscreenCtx.fillRect(0, 0, offscreenCanvas.width, offscreenCanvas.height);

            // Draw floor with anti-aliasing
            offscreenCtx.fillStyle = '#e0e0e0';
            offscreenCtx.fillRect(
                Math.round(margin),
                Math.round(margin),
                Math.round(mazeData.maze[0].length * cellSize),
                Math.round(mazeData.maze.length * cellSize)
            );

            // Draw walls with darker color - flip the z-axis by using (mazeData.maze.length - 1 - z)
            for (let z = 0; z < mazeData.maze.length; z++) {
                for (let x = 0; x < mazeData.maze[z].length; x++) {
                    if (mazeData.maze[z][x] === 1) {
                        offscreenCtx.fillStyle = '#1a1a1a'; // Very dark gray
                        offscreenCtx.fillRect(
                            (mazeData.maze[z].length - 1 - x) * cellSize + margin,
                            (mazeData.maze.length - 1 - z) * cellSize + margin,
                            cellSize,
                            cellSize
                        );
                    }
                }
            }

            // Draw exit - flip both x and z coordinates
            const exitX = Math.floor((mazeData.maze[0].length - 1 - (mazeData.endPosition.x / worldCellSize))) * cellSize + margin;
            const exitZ = Math.floor(mazeData.maze.length - 1 - (mazeData.endPosition.z / worldCellSize)) * cellSize + margin;
            
            // Draw exit marker with glow effect
            offscreenCtx.shadowColor = '#4CAF50';
            offscreenCtx.shadowBlur = 15;
            offscreenCtx.fillStyle = '#4CAF50';
            offscreenCtx.fillRect(exitX - cellSize/4, exitZ - cellSize/4, cellSize/2, cellSize/2);

            // Draw player position if available
            if (playerPos && typeof playerPos.x === 'number' && typeof playerPos.z === 'number') {
                const squareSize = cellSize * 0.6;
                
                // Calculate canvas coordinates for player
                const canvasX = ((mazeData.maze[0].length - 1) - (playerPos.x / worldCellSize)) * cellSize + margin + cellSize/2;
                const canvasZ = ((mazeData.maze.length - 1) - (playerPos.z / worldCellSize)) * cellSize + margin + cellSize/2;
                
                // Draw player marker
                offscreenCtx.shadowColor = '#2196F3';
                offscreenCtx.shadowBlur = 10;
                offscreenCtx.strokeStyle = '#2196F3';
                offscreenCtx.lineWidth = 3;
                
                // Draw player square
                offscreenCtx.strokeRect(
                    canvasX - squareSize/2,
                    canvasZ - squareSize/2,
                    squareSize,
                    squareSize
                );

                // Direction indicator removed - was causing flickering
            }

            // Draw monster position if available
            if (monsterPos && typeof monsterPos.x === 'number' && typeof monsterPos.z === 'number') {
                const diamondSize = cellSize * 0.6;
                
                // Calculate canvas coordinates for monster
                const canvasX = ((mazeData.maze[0].length - 1) - (monsterPos.x / worldCellSize)) * cellSize + margin + cellSize/2;
                const canvasZ = ((mazeData.maze.length - 1) - (monsterPos.z / worldCellSize)) * cellSize + margin + cellSize/2;
                
                // Draw monster marker
                offscreenCtx.shadowColor = '#ff0000';
                offscreenCtx.shadowBlur = 10;
                offscreenCtx.strokeStyle = '#ff0000';
                offscreenCtx.lineWidth = 3;
                
                // Draw diamond shape
                offscreenCtx.beginPath();
                offscreenCtx.moveTo(canvasX, canvasZ - diamondSize/2);
                offscreenCtx.lineTo(canvasX + diamondSize/2, canvasZ);
                offscreenCtx.lineTo(canvasX, canvasZ + diamondSize/2);
                offscreenCtx.lineTo(canvasX - diamondSize/2, canvasZ);
                offscreenCtx.closePath();
                offscreenCtx.stroke();
            }

            // Reset shadow
            offscreenCtx.shadowBlur = 0;

            // Copy the offscreen canvas to the visible canvas
            guideCtx.clearRect(0, 0, guideCanvas.width, guideCanvas.height);
            guideCtx.drawImage(offscreenCanvas, 0, 0);
        }

        function animate() {
            requestAnimationFrame(animate);
            
            if (gameStarted && controls && controls.update) {
                controls.update(); // Call the controls update function
                
                // Check if player has reached the end marker
                if (playerRole === 'player' && maze && maze.endPosition) {
                    const distanceToEnd = Math.sqrt(
                        Math.pow(camera.position.x - maze.endPosition.x, 2) +
                        Math.pow(camera.position.z - maze.endPosition.z, 2)
                    );
                    if (distanceToEnd < 1.0) { // If player is within 1 unit of the end marker
                        handlePlayerWin();
                    }
                }
                
                if ((playerRole === 'player' || playerRole === 'monster') && multiplayerManager && multiplayerManager.connected) {
                    const now = Date.now();
                    // Only send position updates at most every 50ms
                    if (now - lastPositionUpdate >= POSITION_UPDATE_INTERVAL) {
                        lastPositionUpdate = now;
                        
                        // Send position update to server
                        const position = {
                            x: camera.position.x,
                            y: camera.position.y,
                            z: camera.position.z
                        };
                        const rotation = {
                            x: camera.rotation.x,
                            y: camera.rotation.y,
                            z: camera.rotation.z
                        };
                        
                        // Send position and rotation update to server with correct type
                        if (multiplayerManager.socket && multiplayerManager.socket.readyState === WebSocket.OPEN) {
                            multiplayerManager.socket.send(JSON.stringify({
                                type: playerRole === 'monster' ? 'monster_position' : 'player_position',
                                position: position,
                                rotation: rotation,
                                roomCode: multiplayerManager.roomCode,
                                sessionId: multiplayerManager.gameState.sessionId
                            }));
                        }
                    }
                }
            }
            
            if (renderer && scene && camera) {
                renderer.render(scene, camera);
            }
        }

        // Event Listeners
        document.getElementById('singlePlayerButton').addEventListener('click', () => {
            console.log('Single player button clicked');
            startGame('single');
        });
        document.getElementById('multiplayerButton').addEventListener('click', () => {
            console.log('Multiplayer button clicked');
            showMultiplayerMenu();
        });
        document.getElementById('createRoomButton').addEventListener('click', () => {
            console.log('Create room button clicked');
            createRoom();
        });
        document.getElementById('joinRoomButton').addEventListener('click', () => {
            console.log('Join room button clicked');
            showJoinRoom();
        });
        document.getElementById('backToMainButton').addEventListener('click', () => {
            document.getElementById('multiplayerMenu').style.display = 'none';
            document.getElementById('startScreen').style.display = 'block';
        });
        document.getElementById('roomCodeInput').addEventListener('keyup', (e) => {
            if (e.key === 'Enter') {
                joinRoom();
            }
        });

        // Add click handler for room code copying
        document.getElementById('roomCode').addEventListener('click', function() {
            copyRoomCode(this);
        });

        // Handle window resizing
        window.addEventListener('resize', () => {
            if (camera && renderer) {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            }
        });

        // Clean up when leaving the game
        window.addEventListener('beforeunload', () => {
            if (multiplayerManager) {
                multiplayerManager.disconnect();
            }
            gameStarted = false;
        });

        // Handle visibility change to prevent reconnection loops
        document.addEventListener('visibilitychange', () => {
            if (document.hidden) {
                console.log('Page hidden, handling cleanup...');
                // Store current game state before going hidden
                if (multiplayerManager && multiplayerManager.gameState.active) {
                    multiplayerManager.gameState.lastKnownState = {
                        roomCode: multiplayerManager.roomCode,
                        role: multiplayerManager.role,
                        isHost: multiplayerManager.isHost,
                        position: camera ? { x: camera.position.x, y: camera.position.y, z: camera.position.z } : null
                    };
                }
            } else {
                console.log('Page visible, checking game state...');
                if (multiplayerManager && multiplayerManager.gameState.active) {
                    // Verify connection and game state when becoming visible
                    if (!multiplayerManager.connected || multiplayerManager.gameState.reconnecting) {
                        console.log('Connection lost while hidden, attempting to restore...');
                        multiplayerManager.connect();
                    } else {
                        // Send a ping to verify connection is still alive
                        multiplayerManager.socket.send(JSON.stringify({
                            type: 'ping',
                            timestamp: Date.now()
                        }));
                    }
                }
            }
        });

        // Update the MultiplayerManager to handle disconnections better
        MultiplayerManager.prototype.handleDisconnect = function() {
            console.log('Handling disconnection...');
            this.connected = false;
            
            if (gameStarted && !this.disconnecting) {
                // Show a reconnection message
                let reconnectMessage = document.getElementById('reconnectMessage');
                if (!reconnectMessage) {
                    reconnectMessage = document.createElement('div');
                    reconnectMessage.id = 'reconnectMessage';
                    reconnectMessage.style.cssText = `
                        position: fixed;
                        top: 50%;
                        left: 50%;
                        transform: translate(-50%, -50%);
                        background: rgba(0, 0, 0, 0.8);
                        color: white;
                        padding: 20px;
                        border-radius: 10px;
                        z-index: 1000;
                        text-align: center;
                    `;
                    document.body.appendChild(reconnectMessage);
                }
                
                reconnectMessage.innerHTML = `
                    <h3>Connection Lost</h3>
                    <p>Attempting to reconnect...</p>
                    <button onclick="location.reload()" style="margin-top: 10px; padding: 5px 10px;">Restart Game</button>
                `;
                
                // Try to reconnect
                this.reconnect();
                
                // Set a timeout to show the menu if reconnection fails
                setTimeout(() => {
                    if (!this.connected && gameStarted) {
                        console.log('Reconnection failed, showing start screen');
                        hideAllMenus();
                        
                        // Only show start screen if we're completely disconnected
                        if (!this.socket || this.socket.readyState !== WebSocket.CONNECTING) {
                            document.getElementById('startScreen').style.display = 'block';
                            gameStarted = false;
                            
                            // Remove reconnect message
                            if (reconnectMessage) {
                                reconnectMessage.remove();
                            }
                            
                            // Show an error message to the user
                            alert('Lost connection to the game. Please try again.');
                        }
                    }
                }, 15000); // Give even more time for reconnection attempts
            }
        };

        // Override MultiplayerManager message handling completely
        MultiplayerManager.prototype.handleMessage = function(message) {
            console.log('üîî CLIENT: Received message:', message.type, message);
            
            switch (message.type) {
                case 'room_created':
                    console.log('üè† Room created, setting up...');
                    this.roomCode = message.roomCode;
                    this.isHost = true;
                    this.role = message.role;
                    playerRole = message.role; // This will be 'waiting' initially
                    this.gameState.players.add('host');
                    this.gameState.playerCount = 1;
                    this.gameState.canStart = false;
                    this.gameState.allPlayersJoined = false;
                    if (this.onRoomCreated) {
                        this.onRoomCreated(message.roomCode);
                    }
                    break;

                case 'room_joined':
                    console.log('üö™ Room joined, setting up...');
                    this.roomCode = message.roomCode;
                    this.role = message.role;
                    playerRole = message.role; // This will be 'waiting' initially
                    this.gameState.canStart = false;
                    this.gameState.allPlayersJoined = false;
                    if (this.onRoomJoined) {
                        this.onRoomJoined();
                    }
                    break;

                case 'player_joined':
                    console.log('üë• Player joined');
                    this.gameState.players.add(message.playerId);
                    this.gameState.playerCount++;
                    if (this.onPlayerJoined) {
                        this.onPlayerJoined(message.playerId, message.role);
                    }
                    break;

                case 'role_assigned':
                    console.log('üé≠ ROLE ASSIGNED:', message.role);
                    this.role = message.role;
                    playerRole = message.role; // This is the actual game role
                    if (this.onRoleAssigned) {
                        console.log('üé≠ Calling onRoleAssigned callback');
                        this.onRoleAssigned(message.role, message.message);
                    }
                    break;

                case 'game_ready':
                    console.log('üéÆ GAME READY - Starting game');
                    this.gameState.allPlayersJoined = true;
                    this.gameState.canStart = true;
                    if (this.onGameReady) {
                        console.log('üéÆ Calling onGameReady callback');
                        this.onGameReady();
                    }
                    break;

                case 'waiting_for_players':
                    console.log('‚è≥ Waiting for players...');
                    this.gameState.allPlayersJoined = false;
                    this.gameState.canStart = false;
                    break;

                case 'player_left':
                    console.log('üëã Player left');
                    this.gameState.players.delete(message.playerId);
                    this.gameState.playerCount--;
                    this.gameState.canStart = false;
                    this.gameState.allPlayersJoined = false;
                    if (this.onPlayerLeft) {
                        this.onPlayerLeft(message.playerId);
                    }
                    break;

                case 'maze_data':
                    console.log('üó∫Ô∏è Received maze data');
                    maze = message.maze;
                    maze.wallPositions = maze.wallPositions || [];
                    break;

                case 'error':
                    console.error('‚ùå Server error:', message.error);
                    if (this.onError) {
                        this.onError(message.error);
                    }
                    break;

                case 'player_position':
                case 'monster_position':
                    // Handle position updates separately
                    handleMultiplayerMessage(message);
                    break;

                default:
                    console.log('‚ùì Unknown message type:', message.type);
                    break;
            }
        };

        function handleMultiplayerMessage(message) {
            console.log('Handling message:', message);
            
            switch (message.type) {
                case 'player_position':
                    if (!message.position || typeof message.position.x !== 'number' || typeof message.position.z !== 'number') {
                        console.error('Invalid player position received:', message.position);
                        return;
                    }

                    if (playerRole === 'guide') {
                        // Store position for this specific player ID
                        playerPositions[message.playerId] = {
                            x: message.position.x,
                            y: message.position.y,
                            z: message.position.z,
                            rotation: message.rotation
                        };
                        
                        if (maze && guideCanvas && guideCtx) {
                            requestAnimationFrame(() => {
                                // Get the first (and should be only) player position
                                const playerPos = Object.values(playerPositions)[0] || null;
                                const monsterPos = Object.values(monsterPositions)[0] || null;
                                drawGuideView(maze, playerPos, monsterPos);
                            });
                        }

                        // Check if player reached the end
                        if (maze && maze.endPosition) {
                            const distanceToEnd = Math.sqrt(
                                Math.pow(message.position.x - maze.endPosition.x, 2) +
                                Math.pow(message.position.z - maze.endPosition.z, 2)
                            );
                            if (distanceToEnd < 1.0) { // If player is within 1 unit of the end marker
                                handlePlayerWin();
                            }
                        }
                    } else if (playerRole === 'monster') {
                        console.log('Monster received player position:', message);
                        if (otherPlayers[message.playerId]) {
                            // Update player position for monster view
                            otherPlayers[message.playerId].visible = true;
                            otherPlayers[message.playerId].position.set(
                                message.position.x,
                                message.position.y,
                                message.position.z
                            );
                            if (message.rotation) {
                                otherPlayers[message.playerId].rotation.set(
                                    message.rotation.x,
                                    message.rotation.y,
                                    message.rotation.z
                                );
                            }
                            
                            // Calculate and update distance to player
                            const distance = Math.sqrt(
                                Math.pow(camera.position.x - message.position.x, 2) +
                                Math.pow(camera.position.z - message.position.z, 2)
                            );
                            updateDistanceIndicator(distance);

                            // Check if monster caught the player
                            if (distance < 1.5) { // If monster is within 1.5 units of the player
                                handleMonsterWin();
                            }
                        } else {
                            console.log('Creating player representation for monster view');
                            // Create player representation for monster's view
                            const playerGeometry = new THREE.Group();
                            
                            // Main body - taller and brighter cylinder
                            const body = new THREE.Mesh(
                                new THREE.CylinderGeometry(0.4, 0.4, 2.5, 8),
                                new THREE.MeshPhongMaterial({ 
                                    color: 0x00ff00,
                                    emissive: 0x00ff00,
                                    emissiveIntensity: 0.5
                                })
                            );
                            playerGeometry.add(body);
                            
                            // Add glowing ring at the top
                            const ring = new THREE.Mesh(
                                new THREE.TorusGeometry(0.5, 0.1, 8, 16),
                                new THREE.MeshPhongMaterial({
                                    color: 0xffff00,
                                    emissive: 0xffff00,
                                    emissiveIntensity: 0.7
                                })
                            );
                            ring.position.y = 1.5;
                            ring.rotation.x = Math.PI / 2;
                            playerGeometry.add(ring);
                            
                            otherPlayers[message.playerId] = playerGeometry;
                            otherPlayers[message.playerId].position.set(
                                message.position.x,
                                message.position.y,
                                message.position.z
                            );
                            otherPlayers[message.playerId].visible = true;
                            scene.add(otherPlayers[message.playerId]);
                        }
                    }
                    break;

                case 'monster_position':
                    if (playerRole === 'guide') {
                        if (!message.position || typeof message.position.x !== 'number' || typeof message.position.z !== 'number') {
                            console.error('Invalid monster position received:', message.position);
                            return;
                        }
                        
                        // Store position for this specific monster ID
                        monsterPositions[message.playerId] = {
                            x: message.position.x,
                            y: message.position.y,
                            z: message.position.z,
                            rotation: message.rotation
                        };
                        
                        if (maze && guideCanvas && guideCtx) {
                            requestAnimationFrame(() => {
                                // Get the first (and should be only) player and monster positions
                                const playerPos = Object.values(playerPositions)[0] || null;
                                const monsterPos = Object.values(monsterPositions)[0] || null;
                                drawGuideView(maze, playerPos, monsterPos);
                            });
                        }
                    } else if (playerRole === 'player') {
                        // Player sees monster position
                        console.log('Player received monster position:', message);
                        if (otherPlayers[message.playerId]) {
                            otherPlayers[message.playerId].position.set(
                                message.position.x,
                                message.position.y,
                                message.position.z
                            );
                            if (message.rotation) {
                                otherPlayers[message.playerId].rotation.set(
                                    message.rotation.x,
                                    message.rotation.y,
                                    message.rotation.z
                                );
                            }

                            // Check if monster caught the player
                            const distance = Math.sqrt(
                                Math.pow(camera.position.x - message.position.x, 2) +
                                Math.pow(camera.position.z - message.position.z, 2)
                            );
                            if (distance < 1.5) { // If monster is within 1.5 units of the player
                                handleMonsterWin();
                            }
                        }
                    }
                    break;

                case 'maze_data':
                    console.log('Received maze data:', message.maze);
                    maze = message.maze;
                    maze.wallPositions = maze.wallPositions || [];
                    
                    // Initialize the maze for all roles
                    if (playerRole === 'player' || playerRole === 'monster') {
                        generateNewMaze();
                    } else if (playerRole === 'guide') {
                        drawGuideView(maze);
                    }
                    break;

                case 'waiting_for_players':
                    console.log('Waiting for players:', message);
                    const instructionsElement = document.getElementById('roomCodeInstructions');
                    if (instructionsElement) {
                        instructionsElement.textContent = message.message || 'Waiting for more players...';
                        instructionsElement.style.display = 'block';
                    }
                    break;

                case 'host_assigned':
                    console.log('Host assigned:', message);
                    if (message.isHost) {
                        this.isHost = true;
                    }
                    break;

                case 'error':
                    console.error('Server error:', message.error);
                    if (this.onError) {
                        this.onError(message.error);
                    }
                    break;

                case 'player_joined':
                    if (this.onPlayerJoined) {
                        this.onPlayerJoined(message.playerId, message.role);
                    }
                    break;

                case 'player_left':
                    if (this.onPlayerLeft) {
                        this.onPlayerLeft(message.playerId);
                    }
                    break;

                case 'game_over':
                    if (!message.winner) return;
                    
                    if (message.winner === 'player' && playerRole !== 'player') {
                        handlePlayerWin();
                    } else if (message.winner === 'monster' && playerRole !== 'monster') {
                        handleMonsterWin();
                    }
                    
                    // Cleanup and disconnect after a short delay
                    setTimeout(() => {
                        cleanupGame();
                    }, 2000);
                    break;

                case 'game_terminated':
                    console.log('Game terminated by server, winner:', message.winner);
                    gameStarted = false;
                    
                    // Disable all controls
                    if (controls) {
                        controls.enabled = false;
                    }
                    
                    // Show appropriate win screen based on winner (for all roles including guide)
                    const isPlayerWin = message.winner === 'player';
                    const winScreen = document.createElement('div');
                    winScreen.style.cssText = `
                        position: fixed;
                        top: 50%;
                        left: 50%;
                        transform: translate(-50%, -50%);
                        background: ${isPlayerWin ? 'rgba(0, 255, 0, 0.9)' : 'rgba(255, 0, 0, 0.9)'};
                        color: white;
                        padding: 30px;
                        border-radius: 15px;
                        text-align: center;
                        font-size: 24px;
                        z-index: 1000;
                        box-shadow: 0 0 20px ${isPlayerWin ? 'rgba(0, 255, 0, 0.5)' : 'rgba(255, 0, 0, 0.5)'};
                    `;
                    
                    // Show different message based on player role
                    if (playerRole === 'guide') {
                        winScreen.innerHTML = isPlayerWin ? `
                            <h2>üéâ Player and Guide Win! üéâ</h2>
                            <p>You successfully guided the player to safety!</p>
                        ` : `
                            <h2>üëª Monster Wins! üëª</h2>
                            <p>The monster caught the player despite your guidance!</p>
                        `;
                    } else {
                        winScreen.innerHTML = isPlayerWin ? `
                            <h2>üéâ Player and Guide Win! üéâ</h2>
                            <p>The player successfully reached the exit!</p>
                        ` : `
                            <h2>üëª Monster Wins! üëª</h2>
                            <p>The monster caught the player!</p>
                        `;
                    }
                    
                    document.body.appendChild(winScreen);
                    
                    // Force page reload after delay (applies to all players including guide)
                    setTimeout(() => {
                        console.log(`${playerRole} being disconnected and reloaded`);
                        window.location.reload();
                    }, 1500);
                    break;

                default:
                    console.log('Unhandled message type:', message.type);
                    break;
            }
        };



        function initGame(isMultiplayer = false) {
            if (isMultiplayer && !gameStarted) {
                console.log('Cannot start multiplayer game yet - waiting for players');
                return;
            }
            
            // ... rest of initGame function ...
        }

        function getRandomEmptyCell(maze) {
            const width = maze.maze[0].length;
            const height = maze.maze.length;
            let attempts = 0;
            const maxAttempts = 100;

            while (attempts < maxAttempts) {
                const x = Math.floor(Math.random() * width);
                const z = Math.floor(Math.random() * height);
                
                // Check if this cell is empty (not a wall) and not the start position
                if (!maze.maze[z][x] && 
                    (x !== Math.floor(maze.startPosition.x / maze.cellSize) || 
                     z !== Math.floor(maze.startPosition.z / maze.cellSize))) {
                    return { x: x, z: z };
                }
                attempts++;
            }

            // If no empty cell found after max attempts, return a default position
            return { x: 2, z: 2 };
        }

        function handlePlayerMove(ws, data) {
            console.log('Received player position:', data);
            const room = rooms.get(ws.roomCode);
            if (!room) {
                console.log('Room not found for player position:', ws.roomCode);
                return;
            }

            // Update player position
            room.playerPositions.set(ws.playerId, {
                position: data.position,
                rotation: data.rotation
            });

            // Send position to all guide and monster players
            room.players.forEach((playerWs, playerId) => {
                const role = room.roles.get(playerId);
                if (role === 'guide' || role === 'monster') {
                    console.log(`Sending position to ${role}:`, {
                        position: data.position,
                        playerId: playerId
                    });
                    playerWs.send(JSON.stringify({
                        type: 'player_position',
                        position: data.position,
                        rotation: data.rotation
                    }));
                }
            });
        }

        // Add these new functions for monster features
        function updateDistanceIndicator(distance) {
            let indicator = document.getElementById('distanceIndicator');
            if (!indicator) {
                indicator = document.createElement('div');
                indicator.id = 'distanceIndicator';
                indicator.style.cssText = `
                    position: fixed;
                    top: 60px;
                    left: 20px;
                    color: #ff0000;
                    font-size: 16px;
                    text-shadow: 0 0 5px rgba(255, 0, 0, 0.5);
                    z-index: 1000;
                `;
                document.body.appendChild(indicator);
            }
            indicator.textContent = `Distance to player: ${Math.round(distance)} units`;
        }

        function handleMonsterCatch() {
            // Create catch notification
            const notification = document.createElement('div');
            notification.style.cssText = `
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: rgba(255, 0, 0, 0.8);
                color: white;
                padding: 20px;
                border-radius: 10px;
                font-size: 24px;
                text-align: center;
                z-index: 1000;
            `;
            notification.textContent = 'You caught the player!';
            document.body.appendChild(notification);

            // Remove notification after 3 seconds
            setTimeout(() => {
                notification.remove();
            }, 3000);

            // TODO: Add game end logic here
        }

        // Add these new functions for win conditions
        function handlePlayerWin() {
            if (!gameStarted) return;
            gameStarted = false;

            // Disable controls immediately
            if (controls) {
                controls.enabled = false;
            }

            // Create win screen
            const winScreen = document.createElement('div');
            winScreen.style.cssText = `
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: rgba(0, 255, 0, 0.9);
                color: white;
                padding: 30px;
                border-radius: 15px;
                text-align: center;
                font-size: 24px;
                z-index: 1000;
                box-shadow: 0 0 20px rgba(0, 255, 0, 0.5);
            `;
            winScreen.innerHTML = `
                <h2>üéâ Player and Guide Win! üéâ</h2>
                <p>The player successfully reached the exit!</p>
            `;
            document.body.appendChild(winScreen);

            // Send game over message to server
            if (multiplayerManager && multiplayerManager.connected) {
                multiplayerManager.socket.send(JSON.stringify({
                    type: 'game_over',
                    winner: 'player',
                    roomCode: multiplayerManager.roomCode
                }));
            }

            // Clean up after a short delay
            setTimeout(() => {
                document.body.removeChild(winScreen);
                window.location.reload(); // Force page reload
            }, 1500);
        }

        function handleMonsterWin() {
            if (!gameStarted) return;
            gameStarted = false;

            // Disable controls immediately
            if (controls) {
                controls.enabled = false;
            }

            // Create win screen
            const winScreen = document.createElement('div');
            winScreen.style.cssText = `
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: rgba(255, 0, 0, 0.9);
                color: white;
                padding: 30px;
                border-radius: 15px;
                text-align: center;
                font-size: 24px;
                z-index: 1000;
                box-shadow: 0 0 20px rgba(255, 0, 0, 0.5);
            `;
            winScreen.innerHTML = `
                <h2>üëª Monster Wins! üëª</h2>
                <p>The monster caught the player!</p>
            `;
            document.body.appendChild(winScreen);

            // Send game over message to server
            if (multiplayerManager && multiplayerManager.connected) {
                multiplayerManager.socket.send(JSON.stringify({
                    type: 'game_over',
                    winner: 'monster',
                    roomCode: multiplayerManager.roomCode
                }));
            }

            // Clean up after a short delay
            setTimeout(() => {
                document.body.removeChild(winScreen);
                window.location.reload(); // Force page reload
            }, 1500);
        }

        function cleanupGame() {
            // Disable all controls and game logic
            gameStarted = false;
            if (controls) {
                controls.enabled = false;
            }

            // Remove event listeners
            document.removeEventListener('pointerlockchange', onPointerLockChange);
            document.removeEventListener('pointerlockerror', onPointerLockError);
            document.removeEventListener('mousemove', onMouseMove);
            if (keydownListener) document.removeEventListener('keydown', keydownListener);
            if (keyupListener) document.removeEventListener('keyup', keyupListener);
            
            // Exit pointer lock if active
            if (document.pointerLockElement) {
                document.exitPointerLock();
            }

            // Disconnect from server
            if (multiplayerManager && multiplayerManager.connected) {
                multiplayerManager.disconnect();
            }

            // Clear any animation frames
            if (window.animationFrameId) {
                cancelAnimationFrame(window.animationFrameId);
            }

            // Clear the scene
            if (scene) {
                while(scene.children.length > 0) { 
                    scene.remove(scene.children[0]); 
                }
            }

            // Dispose of renderer
            if (renderer && renderer.domElement) {
                renderer.domElement.remove();
                renderer.dispose();
            }

            // Hide all game-related elements
            const elementsToHide = [
                'guideView',
                'winScreen',
                'multiplayerMenu',
                'roomCode',
                'roomCodeInstructions',
                'loadingScreen',
                'errorScreen'
            ];
            
            elementsToHide.forEach(id => {
                const element = document.getElementById(id);
                if (element) {
                    element.style.display = 'none';
                }
            });

            // Show start screen
            const startScreen = document.getElementById('startScreen');
            if (startScreen) {
                startScreen.style.display = 'block';
            }

            // Reset all game variables
            scene = null;
            camera = null;
            renderer = null;
            controls = null;
            maze = null;
            mazeGroup = null;
            otherPlayers = {};
            playerRole = null;
            gameMode = 'single';
            multiplayerManager = null;
            playerPositions = {};
            monsterPositions = {};
            allPlayersJoined = false;
            roomCode = null;
            lastPositionUpdate = 0;
            lastPlayerPos = null;
            lastMonsterPos = null;
        }
    </script>
</body>
</html> 