<!DOCTYPE html>
<html>
<head>
    <title>3D Maze Game</title>
    <!-- Load Three.js from local file -->
    <script src="js/three.min.js"></script>
    <script src="js/maze-generator.js"></script>
    <script src="js/multiplayer.js"></script>
    <script>
        // Verify Three.js loaded
        window.addEventListener('load', function() {
            if (typeof THREE === 'undefined') {
                document.body.innerHTML = '<div style="color: red; text-align: center; margin-top: 50px;">Error: Failed to load 3D library. Please try refreshing the page.</div>';
            }
        });
    </script>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: Arial, sans-serif;
            background: #000;
            color: #fff;
        }
        #startScreen {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            background: none;
            color: white;
            padding: 30px;
            z-index: 1000;
            pointer-events: auto !important;
        }
        #startScreen h1 {
            color: #4CAF50;
            text-shadow: 0 0 15px rgba(76, 175, 80, 0.7);
            margin-bottom: 30px;
            font-size: 48px;
        }
        #startScreen .instruction {
            color: rgba(255, 255, 255, 0.9);
            margin: 8px 0;
            font-size: 18px;
            text-shadow: 0 0 10px rgba(255, 255, 255, 0.5);
        }
        .gameButton {
            background: rgba(76, 175, 80, 0.8);
            border: 2px solid rgba(255, 255, 255, 0.2);
            color: white;
            padding: 15px 30px;
            font-size: 20px;
            cursor: pointer;
            border-radius: 25px;
            transition: all 0.3s;
            margin: 15px;
            width: 200px;
            backdrop-filter: blur(5px);
            text-shadow: 0 0 5px rgba(0, 0, 0, 0.3);
        }
        .gameButton:hover {
            background: rgba(76, 175, 80, 1);
            transform: scale(1.05);
            box-shadow: 0 0 20px rgba(76, 175, 80, 0.4);
        }
        #multiplayerMenu {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 30px;
            border-radius: 15px;
            z-index: 1000;
            display: none;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
        }
        #roomCodeInput {
            padding: 10px;
            font-size: 18px;
            margin: 10px;
            border-radius: 5px;
            border: none;
            text-align: center;
            width: 180px;
        }
        .backButton {
            background: #666;
            border: none;
            color: white;
            padding: 10px 20px;
            font-size: 16px;
            cursor: pointer;
            border-radius: 5px;
            transition: all 0.3s;
            margin-top: 20px;
        }
        .backButton:hover {
            background: #555;
        }
        #roomCode {
            font-size: 48px;
            margin: 20px;
            padding: 30px;
            background: rgba(0, 0, 0, 0.9);
            border-radius: 15px;
            font-family: monospace;
            letter-spacing: 8px;
            text-align: center;
            border: 3px solid #4CAF50;
            color: #4CAF50;
            cursor: pointer;
            user-select: all;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 9999;
            box-shadow: 0 0 30px rgba(76, 175, 80, 0.5);
            transition: all 0.3s ease;
            animation: pulse 2s infinite;
            display: none;
        }
        @keyframes pulse {
            0% { box-shadow: 0 0 30px rgba(76, 175, 80, 0.5); }
            50% { box-shadow: 0 0 50px rgba(76, 175, 80, 0.8); }
            100% { box-shadow: 0 0 30px rgba(76, 175, 80, 0.5); }
        }
        #roomCodeInstructions {
            color: #fff;
            font-size: 18px;
            margin-top: 20px;
            text-align: center;
            position: fixed;
            top: calc(50% + 100px);
            left: 50%;
            transform: translateX(-50%);
            z-index: 1000;
            background: rgba(0, 0, 0, 0.8);
            padding: 15px 30px;
            border-radius: 10px;
            animation: fadeIn 0.5s ease-out;
        }
        @keyframes fadeIn {
            from { opacity: 0; transform: translate(-50%, 20px); }
            to { opacity: 1; transform: translate(-50%, 0); }
        }
        #loadingScreen {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 20px;
            border-radius: 10px;
            z-index: 2000;
            display: none;
        }
        #loadingMessage {
            margin-top: 10px;
            font-size: 18px;
        }
        #errorScreen {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            background: rgba(255, 0, 0, 0.9);
            color: white;
            padding: 30px;
            border-radius: 15px;
            z-index: 3000;
            display: none;
            max-width: 80%;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
        }
        #errorMessage {
            margin: 20px 0;
            font-size: 16px;
            white-space: pre-wrap;
            text-align: left;
        }
        #debugInfo {
            margin-top: 20px;
            font-size: 14px;
            color: #ddd;
            text-align: left;
            font-family: monospace;
            background: rgba(0, 0, 0, 0.3);
            padding: 10px;
            border-radius: 5px;
            max-height: 200px;
            overflow-y: auto;
        }
        .spinner {
            border: 4px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            border-top: 4px solid white;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 10px auto;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        #winScreen {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 30px;
            border-radius: 15px;
            text-align: center;
            z-index: 2000;
            display: none;
            animation: popIn 0.5s ease-out;
        }
        @keyframes popIn {
            0% { transform: translate(-50%, -50%) scale(0.5); opacity: 0; }
            100% { transform: translate(-50%, -50%) scale(1); opacity: 1; }
        }
        #winScreen h2 {
            color: #4CAF50;
            margin-bottom: 20px;
            font-size: 32px;
            text-shadow: 0 0 10px rgba(76, 175, 80, 0.5);
        }
        #winScreen p {
            font-size: 20px;
            margin: 15px 0;
            color: #fff;
        }
        #winScreen button {
            background: #4CAF50;
            border: none;
            color: white;
            padding: 15px 30px;
            border-radius: 5px;
            cursor: pointer;
            margin: 10px;
            font-size: 20px;
            transition: all 0.3s;
        }
        #winScreen button:hover {
            background: #45a049;
            transform: scale(1.1);
        }
        /* Remove crosshair cursor */
        canvas {
            pointer-events: auto !important;
            cursor: default !important;
            outline: none;
            z-index: 1;
        }
        
        /* Update win screen styles */
        #winScreen button {
            background: #4CAF50;
            border: none;
            color: white;
            padding: 15px 30px;
            font-size: 24px;
            cursor: pointer;
            border-radius: 8px;
            transition: all 0.3s;
            margin-top: 20px;
        }
        
        #winScreen button:hover {
            background: #45a049;
            transform: scale(1.1);
        }
        * {
            pointer-events: auto !important;
            cursor: default;
        }
        #gameContainer {
            position: relative;
            width: 100%;
            height: 100%;
        }
        .no-cursor {
            cursor: none;
        }
        .game-canvas {
            outline: none;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            -khtml-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
            pointer-events: auto !important;
        }
        #guideInstructions {
            position: absolute;
            top: 20px;
            left: 20px;
            color: #4CAF50;
            font-size: 18px;
            text-shadow: 0 0 5px rgba(76, 175, 80, 0.5);
        }
        #guideView {
            display: none;
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000;
            pointer-events: auto !important;
        }
        #guideCanvas {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: #111;
            pointer-events: auto !important;
        }
    </style>
</head>
<body>
    <div id="startScreen">
        <h1>3D Maze Game</h1>
        <div class="instruction">Navigate through the maze to find the exit</div>
        <div class="instruction">Use WASD to move and mouse to look around</div>
        <button class="gameButton" id="singlePlayerButton">Single Player</button>
        <button class="gameButton" id="multiplayerButton">Multiplayer</button>
    </div>

    <div id="roomCode" class="room-code"></div>
    <div id="roomCodeInstructions" class="room-code-instructions"></div>

    <div id="multiplayerMenu">
        <h2>Multiplayer Mode</h2>
        <button class="gameButton" id="createRoomButton">Create Room</button>
        <button class="gameButton" id="joinRoomButton">Join Room</button>
        <input type="text" id="roomCodeInput" placeholder="Enter Room Code" style="display: none;">
        <button class="backButton" id="backToMainButton">Back to Main Menu</button>
    </div>

    <div id="loadingScreen">
        <div class="spinner"></div>
        <div id="loadingMessage">Loading Game...</div>
    </div>

    <div id="errorScreen">
        <h2>Error</h2>
        <div id="errorMessage"></div>
        <div id="debugInfo"></div>
        <button onclick="location.reload()" style="margin-top: 15px; padding: 10px 20px; cursor: pointer; background: white; color: red; border: none; border-radius: 5px; font-weight: bold;">Reload Game</button>
    </div>

    <div id="winScreen">
        <h2>🎉 You Won! 🎉</h2>
        <p>Congratulations! You made it through the maze!</p>
        <p>Refresh the page to play again</p>
    </div>

    <div id="guideView" style="display: none;">
        <canvas id="guideCanvas"></canvas>
        <div id="guideInstructions">
            Guide View - Help the player reach the green exit!
            <br>
            Player position is shown as a blue square
            <br>
            Monster position is shown as a red diamond
            <br>
            Exit is shown as a green square
        </div>
    </div>

    <script>
        let scene, camera, renderer, controls;
        let maze, mazeGroup;
        const MAZE_SIZE = { width: 25, height: 25 };
        let keydownListener, keyupListener;
        let textureLoader;
        let gameMode = 'single';
        let multiplayerManager = null;
        let otherPlayers = {};
        let gameStarted = false;
        let playerRole = null;
        let guideCanvas, guideCtx;
        let playerPosition = null;
        let monsterPosition = null;  // Add this line to store monster position
        let allPlayersJoined = false;
        let requiredPlayers = 3;
        let roomCode = null;
        let lastPositionUpdate = 0;
        const POSITION_UPDATE_INTERVAL = 50; // Changed from 100ms to 50ms for more frequent updates
        let monsterTexture = null;

        function createMonsterMesh() {
            // Create a plane geometry that always faces the camera
            const monsterGeometry = new THREE.PlaneGeometry(2, 2);
            const monsterMaterial = new THREE.MeshBasicMaterial({
                map: textureLoader.load('monster.png'),
                transparent: true,
                side: THREE.DoubleSide
            });
            const monster = new THREE.Mesh(monsterGeometry, monsterMaterial);
            
            // Create a container for the monster to handle positioning
            const monsterContainer = new THREE.Object3D();
            monsterContainer.add(monster);
            
            // Make the monster plane always face the camera
            monster.onBeforeRender = function(renderer, scene, camera) {
                monster.quaternion.copy(camera.quaternion);
            };
            
            return monsterContainer;
        }

        function createRoom() {
            if (gameStarted) {
                console.log('Game already started, ignoring createRoom');
                return;
            }
            
            showLoadingScreen('Creating Room...');
            console.log('Creating room...');
            
            // Initialize multiplayer manager
            multiplayerManager = new MultiplayerManager();
            
            // Set up callbacks
            multiplayerManager.onConnectionSuccess = () => {
                console.log('Successfully connected, creating room...');
                multiplayerManager.createRoom();
            };

            multiplayerManager.onRoomCreated = (roomCode) => {
                console.log('Room created with code:', roomCode);
                hideLoadingScreen();
                
                // Hide all menus
                hideAllMenus();
                
                // Show the room code prominently
                const roomCodeElement = document.getElementById('roomCode');
                roomCodeElement.style.display = 'block';
                roomCodeElement.textContent = roomCode;
                
                // Show instructions
                const instructionsElement = document.getElementById('roomCodeInstructions');
                instructionsElement.textContent = `Share this code with other players • Click to copy • Waiting for ${requiredPlayers - 1} more players...`;
                instructionsElement.style.display = 'block';
                
                // Set the game mode but don't start yet
                gameMode = 'multiplayer';
                playerRole = 'player';
                allPlayersJoined = false;
                gameStarted = false;
                
                // Initialize scene but don't start animation
                init(false);
            };

            multiplayerManager.onPlayerJoined = (playerId, role) => {
                console.log('Player joined:', playerId, 'as', role);
                if (!otherPlayers[playerId] && (playerRole === 'player' || playerRole === 'monster')) {
                    console.log('Creating representation for player:', playerId, 'with role:', role);
                    
                    // Create a more visible representation for players
                    let playerMesh;
                    if (role === 'monster') {
                        // Monster representation
                        playerMesh = new THREE.Mesh(
                            new THREE.CylinderGeometry(0.3, 0.3, 2, 8),
                            new THREE.MeshPhongMaterial({ 
                                color: 0xff0000,
                                emissive: 0xff0000,
                                emissiveIntensity: 0.5
                            })
                        );
                    } else {
                        // Player representation - more visible for monster
                        const playerGeometry = new THREE.Group();
                        
                        // Main body - taller and brighter cylinder
                        const body = new THREE.Mesh(
                            new THREE.CylinderGeometry(0.4, 0.4, 2.5, 8),
                            new THREE.MeshPhongMaterial({ 
                                color: 0x00ff00,
                                emissive: 0x00ff00,
                                emissiveIntensity: 0.5
                            })
                        );
                        playerGeometry.add(body);
                        
                        // Add glowing ring at the top
                        const ring = new THREE.Mesh(
                            new THREE.TorusGeometry(0.5, 0.1, 8, 16),
                            new THREE.MeshPhongMaterial({
                                color: 0xffff00,
                                emissive: 0xffff00,
                                emissiveIntensity: 0.7
                            })
                        );
                        ring.position.y = 1.5;
                        ring.rotation.x = Math.PI / 2;
                        playerGeometry.add(ring);
                        
                        playerMesh = playerGeometry;
                    }
                    
                    otherPlayers[playerId] = playerMesh;
                    otherPlayers[playerId].position.set(0, 1, 0);
                    otherPlayers[playerId].visible = true;
                    scene.add(otherPlayers[playerId]);
                    
                    console.log('Added player representation to scene:', playerId);
                }
                
                // Update waiting message
                const instructionsElement = document.getElementById('roomCodeInstructions');
                const currentPlayers = Object.keys(otherPlayers).length + 1;
                const playersNeeded = requiredPlayers - currentPlayers;
                
                if (playersNeeded > 0) {
                    instructionsElement.textContent = `Share this code with other players • Click to copy • Waiting for ${playersNeeded} more player${playersNeeded > 1 ? 's' : ''}...`;
                }
            };

            multiplayerManager.onGameReady = () => {
                console.log('All players have joined, starting game...');
                allPlayersJoined = true;
                gameStarted = true;
                
                // Hide the room code and instructions
                document.getElementById('roomCode').style.display = 'none';
                document.getElementById('roomCodeInstructions').style.display = 'none';
                document.getElementById('waitingMessage').style.display = 'none';
                
                // Start the game animation
                animate();
            };

            multiplayerManager.onPlayerLeft = (playerId) => {
                console.log('Player left:', playerId);
                if (otherPlayers[playerId]) {
                    scene.remove(otherPlayers[playerId]);
                    delete otherPlayers[playerId];
                }
                
                // Update UI to show disconnection and waiting state
                const currentPlayers = Object.keys(otherPlayers).length + 1;
                if (currentPlayers < requiredPlayers) {
                    allPlayersJoined = false;
                    gameStarted = false;
                    
                    // Show waiting message
                    const instructionsElement = document.getElementById('roomCodeInstructions');
                    instructionsElement.style.display = 'block';
                    instructionsElement.textContent = `A player has disconnected • Waiting for ${requiredPlayers - currentPlayers} more player${requiredPlayers - currentPlayers > 1 ? 's' : ''}...`;
                    
                    // Show room code again
                    const roomCodeElement = document.getElementById('roomCode');
                    roomCodeElement.style.display = 'block';
                }
            };

            multiplayerManager.onError = (error) => {
                console.error('Error in multiplayer:', error);
                hideLoadingScreen();
                alert(error);
                showMultiplayerMenu();
            };

            // Start connection
            multiplayerManager.connect();
        }

        function startMultiplayerGame() {
            if (!gameStarted) {
                console.log('Starting multiplayer game...');
                gameStarted = true;
                
                // Hide all menus
                document.getElementById('startScreen').style.display = 'none';
                document.getElementById('multiplayerMenu').style.display = 'none';
                document.getElementById('winScreen').style.display = 'none';
                
                // Set up multiplayer components
                setupMultiplayer();
                
                // Start the animation loop
                animate();
            }
        }

        function startGame(mode = 'single') {
            if (mode === 'multiplayer') {
                console.log('Redirecting multiplayer start to startMultiplayerGame');
                startMultiplayerGame();
                return;
            }
            
            console.log('Starting single player game...');
            gameStarted = false; // Reset first
            playerRole = 'player'; // Set role for single player
            
            // Hide ALL menu elements
            hideAllMenus();
            
            // Remove old renderer and clean up
            cleanupRenderer();

            // Clean up old multiplayer resources
            cleanupMultiplayer();
            
            // Start fresh game
            gameStarted = true;
            gameMode = mode;
            init();
        }

        function hideAllMenus() {
            const menuElements = [
                'startScreen',
                'multiplayerMenu',
                'winScreen',
                'roomCode',
                'roomCodeInstructions',
                'loadingScreen',
                'errorScreen',
                'guideView'
            ];
            
            menuElements.forEach(elementId => {
                const element = document.getElementById(elementId);
                if (element) {
                    element.style.display = 'none';
                }
            });
        }

        function cleanupRenderer() {
            if (renderer && renderer.domElement && renderer.domElement.parentNode) {
                cancelAnimationFrame(window.animationFrameId);
                
                // Remove pointer lock event listeners
                document.removeEventListener('pointerlockchange', onPointerLockChange);
                document.removeEventListener('pointerlockerror', onPointerLockError);
                document.removeEventListener('mousemove', onMouseMove);
                
                // Exit pointer lock if active
                if (document.pointerLockElement === renderer.domElement) {
                    document.exitPointerLock();
                }
                
                renderer.domElement.parentNode.removeChild(renderer.domElement);
                renderer.dispose();
            }
        }

        function cleanupMultiplayer() {
            if (multiplayerManager) {
                multiplayerManager.disconnect();
                multiplayerManager = null;
            }
        }

        function init() {
            console.log('Initializing game in mode:', gameMode, 'role:', playerRole);
            
            try {
                // Only guide gets the 2D view
                if (playerRole === 'guide') {
                    // Initialize guide view
                    document.body.style.cursor = 'default';
                    if (maze) {
                        initGuideView(maze);
                    } else {
                        console.error('No maze data available for guide view');
                        document.body.innerHTML = '<div style="color: red; text-align: center; margin-top: 50px;">Error: No maze data available. Please try refreshing the page.</div>';
                    }
                    return;
                }

                // Both player and monster get the same 3D setup
                scene = new THREE.Scene();
                scene.background = new THREE.Color(0x000000);
                
                // Create renderer
                renderer = new THREE.WebGLRenderer({ 
                    antialias: true,
                    powerPreference: "high-performance"
                });
                renderer.setSize(window.innerWidth, window.innerHeight);
                renderer.setPixelRatio(window.devicePixelRatio);
                document.body.appendChild(renderer.domElement);
                
                // Create first-person camera
                camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
                
                // Load textures
                textureLoader = new THREE.TextureLoader();
                
                // Generate new maze for single player or host
                if (gameMode === 'single' || (multiplayerManager && multiplayerManager.isHost && !maze)) {
                    const generator = new MazeGenerator(MAZE_SIZE.width, MAZE_SIZE.height);
                    maze = generator.generate();
                    
                    // Send maze data immediately if we're the host
                    if (multiplayerManager && multiplayerManager.isHost) {
                        console.log('Host sending initial maze data:', maze);
                        multiplayerManager.socket.send(JSON.stringify({
                            type: 'maze_data',
                            maze: maze
                        }));
                    }
                }
                
                if (!maze) {
                    throw new Error('No maze data available');
                }

                // Set starting position based on role
                if (playerRole === 'monster') {
                    // Place monster at a random position
                    const randomCell = getRandomEmptyCell(maze);
                    camera.position.set(
                        randomCell.x * maze.cellSize,
                        1.5,
                        randomCell.z * maze.cellSize
                    );
                    console.log('Monster spawned at:', camera.position);

                    // Add monster UI overlay
                    const monsterInstructions = document.createElement('div');
                    monsterInstructions.style.cssText = `
                        position: fixed;
                        top: 20px;
                        left: 20px;
                        color: #ff0000;
                        font-size: 18px;
                        text-shadow: 0 0 5px rgba(255, 0, 0, 0.5);
                        z-index: 1000;
                    `;
                    monsterInstructions.innerHTML = `
                        Monster View - Find and catch the player before they escape!<br>
                        Use WASD to move and mouse to look around<br>
                        The player appears as a green cylinder
                    `;
                    document.body.appendChild(monsterInstructions);
                } else {
                    // Set player starting position
                    camera.position.set(
                        maze.startPosition.x,
                        1.5,
                        maze.startPosition.z
                    );
                    console.log('Player spawned at:', camera.position);
                }

                // Make sure guide view is hidden for both player and monster
                const guideView = document.getElementById('guideView');
                if (guideView) {
                    guideView.style.display = 'none';
                }
                
                // Generate maze geometry
                mazeGroup = new THREE.Group();
                generateNewMaze();
                
                // Set up controls and start animation
                controls = setupControls();
                gameStarted = true;
                animate();
                
                // Request pointer lock for both player and monster
                renderer.domElement.requestPointerLock();
                
                console.log('Game initialized in mode:', gameMode, 'role:', playerRole, 'with first-person view');
            } catch (error) {
                console.error('Error initializing game:', error);
                document.body.innerHTML = '<div style="color: red; text-align: center; margin-top: 50px;">Error: Failed to initialize game. Please try refreshing the page.</div>';
            }
        }

        function generateNewMaze() {
            if (mazeGroup) {
                // Remove all objects from the scene
                while(scene.children.length > 0){ 
                    scene.remove(scene.children[0]); 
                }
                mazeGroup = new THREE.Group();
            }

            // Initialize maze.wallPositions array
            if (!maze.wallPositions) {
                maze.wallPositions = [];
            }

            mazeGroup = new THREE.Group();
            
            // Add static lights in a sparser grid pattern
            const mazeWidth = MAZE_SIZE.width * maze.cellSize;
            const mazeHeight = MAZE_SIZE.height * maze.cellSize;
            
            // Calculate positions for a few strategic lights
            const lights = [
                // Center light
                {x: 0, z: 0, intensity: 8.0, distance: 70},
                
                // Four quadrant lights
                {x: -mazeWidth/4, z: -mazeHeight/4, intensity: 6.0, distance: 50},
                {x: mazeWidth/4, z: -mazeHeight/4, intensity: 6.0, distance: 50},
                {x: -mazeWidth/4, z: mazeHeight/4, intensity: 6.0, distance: 50},
                {x: mazeWidth/4, z: mazeHeight/4, intensity: 6.0, distance: 50},
                
                // Additional corner lights
                {x: -mazeWidth/2, z: -mazeHeight/2, intensity: 5.0, distance: 40},
                {x: mazeWidth/2, z: -mazeHeight/2, intensity: 5.0, distance: 40},
                {x: -mazeWidth/2, z: mazeHeight/2, intensity: 5.0, distance: 40},
                {x: mazeWidth/2, z: mazeHeight/2, intensity: 5.0, distance: 40}
            ];
            
            // Add brighter ambient light for better overall visibility
            const ambientLight = new THREE.AmbientLight(0xffffff, 3.0);
            scene.add(ambientLight);
            
            // Add all lights
            lights.forEach(light => {
                const pointLight = new THREE.PointLight(0xffffff, light.intensity, light.distance);
                pointLight.position.set(light.x, 3.5, light.z);
                scene.add(pointLight);
            });

            // Load textures
            const wallTexture = textureLoader.load('wall.jpg');
            wallTexture.wrapS = wallTexture.wrapT = THREE.RepeatWrapping;
            wallTexture.repeat.set(1, 1);

            // Create wall geometry and material only once for better performance
            const wallGeometry = new THREE.BoxGeometry(maze.cellSize, maze.wallHeight, maze.cellSize);
            const wallMaterial = new THREE.MeshPhongMaterial({
                map: wallTexture,
                color: 0xcccccc,
                specular: 0x222222,
                shininess: 10,
                transparent: false,
                opacity: 1.0,
                side: THREE.FrontSide,
                depthWrite: true,
                depthTest: true
            });

            // Clear existing walls array
            maze.wallPositions = [];

            function addWall(x, z) {
                const wall = new THREE.Mesh(wallGeometry, wallMaterial);
                wall.position.set(x * maze.cellSize, maze.wallHeight / 2, z * maze.cellSize);
                wall.castShadow = true;
                wall.receiveShadow = true;
                wall.matrixAutoUpdate = false; // Optimize performance
                wall.updateMatrix();
                mazeGroup.add(wall);
                
                maze.wallPositions.push({ x: x * maze.cellSize, z: z * maze.cellSize });
            }

            // Clear existing walls
            while(mazeGroup.children.length > 0) {
                const obj = mazeGroup.children[0];
                obj.geometry.dispose();
                obj.material.dispose();
                mazeGroup.remove(obj);
            }

            // Add maze walls
            for (let y = 0; y < MAZE_SIZE.height; y++) {
                for (let x = 0; x < MAZE_SIZE.width; x++) {
                    if (maze.maze[y][x] === 1) {
                        addWall(x, y);
                    }
                }
            }

            // Add boundary walls
            for (let x = -1; x <= MAZE_SIZE.width; x++) {
                addWall(x, -1);
                addWall(x, MAZE_SIZE.height);
            }

            for (let z = -1; z <= MAZE_SIZE.height; z++) {
                addWall(-1, z);
                addWall(MAZE_SIZE.width, z);
            }

            // Add floor
            const floorGeometry = new THREE.PlaneGeometry(
                (MAZE_SIZE.width + 2) * maze.cellSize,
                (MAZE_SIZE.height + 2) * maze.cellSize
            );
            const floorMaterial = new THREE.MeshPhongMaterial({
                color: 0x808080,  // Lighter floor color
                specular: 0x222222,
                shininess: 10,
                side: THREE.FrontSide,
                depthWrite: true
            });
            const floor = new THREE.Mesh(floorGeometry, floorMaterial);
            floor.rotation.x = -Math.PI / 2;
            floor.position.set(
                (MAZE_SIZE.width * maze.cellSize) / 2,
                0,
                (MAZE_SIZE.height * maze.cellSize) / 2
            );
            mazeGroup.add(floor);

            // Add end marker with improved material
            const endMarkerGeometry = new THREE.CylinderGeometry(0.4, 0.4, 0.1, 32);
            const endMarkerMaterial = new THREE.MeshPhongMaterial({ 
                color: 0x00ff00,
                emissive: 0x00ff00,
                emissiveIntensity: 0.5,
                transparent: false,
                opacity: 1.0,
                depthWrite: true
            });
            const endMarker = new THREE.Mesh(endMarkerGeometry, endMarkerMaterial);
            
            // Place end marker at the correct world position (don't multiply by cellSize again)
            endMarker.position.set(
                maze.endPosition.x,
                0.05,
                maze.endPosition.z
            );
            
            // Add point light to end marker for glow
            const endLight = new THREE.PointLight(0x00ff00, 1, 5);
            endLight.position.copy(endMarker.position);
            endLight.position.y = 1;
            
            mazeGroup.add(endMarker);
            mazeGroup.add(endLight);

            // Add the entire maze group to the scene
            scene.add(mazeGroup);
        }

        function checkCollision(position) {
            if (!maze || !maze.wallPositions || !Array.isArray(maze.wallPositions)) {
                console.log('Maze or wall positions not properly initialized');
                return { x: false, z: false };
            }

            const playerRadius = 0.4; // Collision radius for the player
            const wallBuffer = 0.2; // Increased buffer zone to prevent glitching
            let collisionX = false;
            let collisionZ = false;
            
            for (const wall of maze.wallPositions) {
                const dx = position.x - wall.x;
                const dz = position.z - wall.z;
                const distance = Math.sqrt(dx * dx + dz * dz);
                
                // If we're close enough to collide
                if (distance < maze.cellSize / 2 + playerRadius + wallBuffer) {
                    // Calculate the angle of approach
                    const approachAngle = Math.atan2(Math.abs(dz), Math.abs(dx));
                    
                    // Determine collision based on approach angle with wider detection zones
                    if (approachAngle < Math.PI / 3) { // 60 degree zone for X collision
                        collisionX = true;
                    }
                    if (approachAngle > Math.PI / 6) { // 30 degree zone for Z collision
                        collisionZ = true;
                    }
                    
                    // If we're very close, block both axes to prevent corner glitches
                    if (distance < (maze.cellSize / 2 + playerRadius) * 0.7) {
                        collisionX = true;
                        collisionZ = true;
                    }
                }
            }
            
            return { x: collisionX, z: collisionZ };
        }

        function setupControls() {
            const moveSpeed = playerRole === 'monster' ? 0.1 : 0.15; // Slow down monster
            const turnSpeed = 0.06;  // Added for camera panning
            let lastTime = performance.now();
            let isPointerLocked = false;
            
            const controls = {
                enabled: true,
                update: null
            };
            
            const keys = {
                forward: false,
                backward: false,
                left: false,
                right: false
            };

            // Remove any existing listeners
            if (keydownListener) document.removeEventListener('keydown', keydownListener);
            if (keyupListener) document.removeEventListener('keyup', keyupListener);

            // Mouse movement handler
            function onMouseMove(event) {
                if (isPointerLocked && gameStarted && (playerRole === 'player' || playerRole === 'monster')) {
                    camera.rotation.y -= event.movementX * 0.002;
                }
            }

            // Pointer lock change handler
            function onPointerLockChange() {
                isPointerLocked = document.pointerLockElement === renderer.domElement;
            }

            // Pointer lock error handler
            function onPointerLockError() {
                console.error('Pointer lock error');
            }

            // Add pointer lock event listeners
            document.addEventListener('pointerlockchange', onPointerLockChange);
            document.addEventListener('pointerlockerror', onPointerLockError);
            document.addEventListener('mousemove', onMouseMove);

            // Handle click to start pointer lock
            if (renderer && renderer.domElement) {
                renderer.domElement.addEventListener('click', () => {
                    // Remove pointer lock request
                });
            }

            // Handle ESC key to exit pointer lock
            document.addEventListener('keydown', (e) => {
                if (e.key === 'Escape' && isPointerLocked) {
                    document.exitPointerLock();
                }
            });

            keydownListener = (e) => {
                switch(e.key.toLowerCase()) {
                    case 'w':
                    case 'arrowup':
                        keys.forward = true;
                        break;
                    case 's':
                    case 'arrowdown':
                        keys.backward = true;
                        break;
                    case 'a':
                    case 'arrowleft':
                        keys.left = true;
                        break;
                    case 'd':
                    case 'arrowright':
                        keys.right = true;
                        break;
                }
            };

            keyupListener = (e) => {
                switch(e.key.toLowerCase()) {
                    case 'w':
                    case 'arrowup':
                        keys.forward = false;
                        break;
                    case 's':
                    case 'arrowdown':
                        keys.backward = false;
                        break;
                    case 'a':
                    case 'arrowleft':
                        keys.left = false;
                        break;
                    case 'd':
                    case 'arrowright':
                        keys.right = false;
                        break;
                }
            };

            // Add event listeners
            document.addEventListener('keydown', keydownListener);
            document.addEventListener('keyup', keyupListener);

            controls.update = function updateControls() {
                if (!controls.enabled || !camera || !maze) return;

                const moveSpeed = playerRole === 'monster' ? 0.1 : 0.15; // Slow down monster
                const turnSpeed = 0.06;  // Added for camera panning
                const newPosition = camera.position.clone();
                const oldPosition = camera.position.clone();

                // Calculate movement vector
                let moveVector = new THREE.Vector3(0, 0, 0);
                if (keys.forward) {
                    moveVector.x -= Math.sin(camera.rotation.y) * moveSpeed;
                    moveVector.z -= Math.cos(camera.rotation.y) * moveSpeed;
                }
                if (keys.backward) {
                    moveVector.x += Math.sin(camera.rotation.y) * moveSpeed;
                    moveVector.z += Math.cos(camera.rotation.y) * moveSpeed;
                }
                if (keys.left) {
                    camera.rotation.y += turnSpeed;
                }
                if (keys.right) {
                    camera.rotation.y -= turnSpeed;
                }

                // Check collisions by testing each axis separately with a small step
                const stepSize = 0.1;
                const steps = Math.ceil(Math.max(Math.abs(moveVector.x), Math.abs(moveVector.z)) / stepSize);
                
                if (steps > 0) {
                    const stepX = moveVector.x / steps;
                    const stepZ = moveVector.z / steps;
                    
                    for (let i = 0; i < steps; i++) {
                        const nextPos = newPosition.clone();
                        nextPos.x += stepX;
                        nextPos.z += stepZ;
                        
                        const collision = checkCollision(nextPos);
                        
                        if (!collision.x) {
                            newPosition.x += stepX;
                        }
                        if (!collision.z) {
                            newPosition.z += stepZ;
                        }
                        
                        // If we hit a wall, stop checking further steps
                        if (collision.x && collision.z) {
                            break;
                        }
                    }
                }

                // Update position and send update if changed
                camera.position.copy(newPosition);
                
                if (camera.position.x !== oldPosition.x || camera.position.z !== oldPosition.z) {
                    if (multiplayerManager && multiplayerManager.connected) {
                        multiplayerManager.sendPosition(camera.position, camera.rotation);
                    }
                }
            };

            return controls;
        }

        function showWinScreen() {
            document.getElementById('winScreen').style.display = 'block';
            // Reset game state
            gameStarted = false;
        }

        // Show the multiplayer menu
        function showMultiplayerMenu() {
            console.log('Showing multiplayer menu');
            if (gameStarted) {
                console.log('Game in progress, cleaning up first');
                cleanupRenderer();
                cleanupMultiplayer();
            }
            
            gameStarted = false;
            gameMode = 'single'; // Reset game mode
            hideAllMenus();
            document.getElementById('multiplayerMenu').style.display = 'block';
            document.getElementById('createRoomButton').style.display = 'block';
            document.getElementById('joinRoomButton').style.display = 'block';
        }

        // Show join room input
        function showJoinRoom() {
            document.getElementById('createRoomButton').style.display = 'none';
            document.getElementById('joinRoomButton').style.display = 'none';
            document.getElementById('roomCodeInput').style.display = 'block';
            document.getElementById('roomCodeInput').value = '';
        }

        function joinRoom() {
            const roomCode = document.getElementById('roomCodeInput').value.trim().toUpperCase();
            if (!roomCode) {
                alert('Please enter a room code');
                return;
            }

            showLoadingScreen('Joining Room...');
            console.log('Attempting to join room:', roomCode);
            
            // Initialize multiplayer manager
            multiplayerManager = new MultiplayerManager();
            
            // Set up callbacks
            multiplayerManager.onConnectionSuccess = () => {
                console.log('Successfully connected to server, attempting to join room:', roomCode);
                multiplayerManager.joinRoom(roomCode);
            };

            multiplayerManager.onRoomJoined = () => {
                console.log('Successfully joined room:', roomCode);
                hideLoadingScreen();
                
                // Hide all menus
                document.getElementById('startScreen').style.display = 'none';
                document.getElementById('multiplayerMenu').style.display = 'none';
                document.getElementById('roomCodeInput').style.display = 'none';
                
                // Set the game mode
                gameMode = 'multiplayer';
                
                // Initialize view based on role - this was the bug, we were always initializing guide view
                if (playerRole === 'guide') {
                    // Wait for maze data before initializing guide view
                    console.log('Guide role assigned, waiting for maze data');
                } else if (playerRole === 'monster') {
                    // Monster should get 3D view
                    console.log('Monster role assigned, will initialize 3D view when maze data arrives');
                    document.getElementById('guideView').style.display = 'none';
                } else {
                    // Player should get 3D view
                    console.log('Player role assigned, will initialize 3D view when maze data arrives');
                    document.getElementById('guideView').style.display = 'none';
                }
            };

            multiplayerManager.onError = (error) => {
                console.error('Error joining room:', error);
                hideLoadingScreen();
                alert('Error joining room: ' + error);
                showMultiplayerMenu();
            };

            // Start connection
            multiplayerManager.connect();
        }

        function showLoadingScreen(message = 'Loading Game...') {
            document.getElementById('loadingMessage').textContent = message;
            document.getElementById('loadingScreen').style.display = 'block';
        }

        function hideLoadingScreen() {
            document.getElementById('loadingScreen').style.display = 'none';
        }

        function setupMultiplayer() {
            console.log('Setting up multiplayer components with role:', playerRole);
            
            // Create other player representation based on role
            if (playerRole === 'player' || playerRole === 'monster') {
                let otherPlayerMesh;
                if (playerRole === 'monster') {
                    // Create player representation for monster's view
                    const playerGeometry = new THREE.Group();
                    
                    // Main body - taller and brighter cylinder
                    const body = new THREE.Mesh(
                        new THREE.CylinderGeometry(0.4, 0.4, 2.5, 8),
                        new THREE.MeshPhongMaterial({ 
                            color: 0x00ff00,
                            emissive: 0x00ff00,
                            emissiveIntensity: 0.5
                        })
                    );
                    playerGeometry.add(body);
                    
                    // Add glowing ring at the top
                    const ring = new THREE.Mesh(
                        new THREE.TorusGeometry(0.5, 0.1, 8, 16),
                        new THREE.MeshPhongMaterial({
                            color: 0xffff00,
                            emissive: 0xffff00,
                            emissiveIntensity: 0.7
                        })
                    );
                    ring.position.y = 1.5;
                    ring.rotation.x = Math.PI / 2;
                    playerGeometry.add(ring);
                    
                    otherPlayerMesh = playerGeometry;
                } else {
                    // Monster representation for player's view
                    otherPlayerMesh = new THREE.Mesh(
                        new THREE.CylinderGeometry(0.3, 0.3, 2, 8),
                        new THREE.MeshPhongMaterial({ 
                            color: 0xff0000,
                            emissive: 0xff0000,
                            emissiveIntensity: 0.5
                        })
                    );
                }
                
                otherPlayers[multiplayerManager.playerId] = otherPlayerMesh;
                otherPlayers[multiplayerManager.playerId].position.set(0, 1, 0);
                otherPlayers[multiplayerManager.playerId].visible = true;
                scene.add(otherPlayers[multiplayerManager.playerId]);
            }

            // Set up multiplayer event handlers
            multiplayerManager.onPlayerJoined = (playerId, role) => {
                console.log('Player joined:', playerId, 'as', role);
                if (!otherPlayers[playerId] && (playerRole === 'player' || playerRole === 'monster')) {
                    console.log('Creating representation for player:', playerId, 'with role:', role);
                    
                    // Create a more visible representation for players
                    let playerMesh;
                    if (role === 'monster') {
                        // Monster representation
                        playerMesh = new THREE.Mesh(
                            new THREE.CylinderGeometry(0.3, 0.3, 2, 8),
                            new THREE.MeshPhongMaterial({ 
                                color: 0xff0000,
                                emissive: 0xff0000,
                                emissiveIntensity: 0.5
                            })
                        );
                    } else {
                        // Player representation - more visible for monster
                        const playerGeometry = new THREE.Group();
                        
                        // Main body - taller and brighter cylinder
                        const body = new THREE.Mesh(
                            new THREE.CylinderGeometry(0.4, 0.4, 2.5, 8),
                            new THREE.MeshPhongMaterial({ 
                                color: 0x00ff00,
                                emissive: 0x00ff00,
                                emissiveIntensity: 0.5
                            })
                        );
                        playerGeometry.add(body);
                        
                        // Add glowing ring at the top
                        const ring = new THREE.Mesh(
                            new THREE.TorusGeometry(0.5, 0.1, 8, 16),
                            new THREE.MeshPhongMaterial({
                                color: 0xffff00,
                                emissive: 0xffff00,
                                emissiveIntensity: 0.7
                            })
                        );
                        ring.position.y = 1.5;
                        ring.rotation.x = Math.PI / 2;
                        playerGeometry.add(ring);
                        
                        playerMesh = playerGeometry;
                    }
                    
                    otherPlayers[playerId] = playerMesh;
                    otherPlayers[playerId].position.set(0, 1, 0);
                    otherPlayers[playerId].visible = true;
                    scene.add(otherPlayers[playerId]);
                    
                    console.log('Added player representation to scene:', playerId);
                }
            };

            multiplayerManager.onPlayerLeft = (playerId) => {
                console.log('Player left:', playerId);
                if (otherPlayers[playerId]) {
                    scene.remove(otherPlayers[playerId]);
                    delete otherPlayers[playerId];
                }
            };

            multiplayerManager.onPlayerMove = (playerId, position, rotation) => {
                console.log('Received player move:', playerId, position, rotation);
                if (otherPlayers[playerId]) {
                    otherPlayers[playerId].visible = true;
                    otherPlayers[playerId].position.set(position.x, position.y, position.z);
                    otherPlayers[playerId].rotation.set(rotation.x, rotation.y, rotation.z);
                }
            };
        }

        function copyRoomCode(element) {
            const code = element.textContent;
            navigator.clipboard.writeText(code).then(() => {
                element.classList.add('copied');
                setTimeout(() => element.classList.remove('copied'), 500);
            });
        }

        function initGuideView(mazeData) {
            try {
                if (!mazeData?.maze) throw new Error('Invalid maze data');

                // Clean up
                if (renderer?.domElement?.parentNode) {
                    renderer.domElement.parentNode.removeChild(renderer.domElement);
                    renderer.dispose();
                }

                // Hide other screens
                ['startScreen', 'multiplayerMenu', 'winScreen', 'loadingScreen'].forEach(id => {
                    const element = document.getElementById(id);
                    if (element) element.style.display = 'none';
                });

                // Setup guide container
                const guideView = document.getElementById('guideView');
                guideView.style.cssText = `
                    position: fixed;
                    top: 0;
                    left: 0;
                    width: 100vw;
                    height: 100vh;
                    display: flex;
                    justify-content: center;
                    align-items: center;
                    background-color: #000000;
                `;
                guideView.style.display = 'block';

                // Setup canvas
                guideCanvas = document.getElementById('guideCanvas');
                guideCtx = guideCanvas.getContext('2d');

                // Calculate optimal size
                const margin = 80;
                const maxWidth = window.innerWidth - margin * 2;
                const maxHeight = window.innerHeight - margin * 2;
                
                // Calculate cell size to maintain aspect ratio
                const mazeWidth = mazeData.maze[0].length;
                const mazeHeight = mazeData.maze.length;
                const cellSizeX = Math.floor(maxWidth / mazeWidth);
                const cellSizeY = Math.floor(maxHeight / mazeHeight);
                const cellSize = Math.min(cellSizeX, cellSizeY);

                // Set canvas size
                guideCanvas.width = mazeWidth * cellSize + margin * 2;
                guideCanvas.height = mazeHeight * cellSize + margin * 2;

                // Store settings globally
                window.guideViewConfig = {
                    cellSize,
                    margin,
                    mazeWidth,
                    mazeHeight,
                    worldCellSize: mazeData.cellSize
                };

                // Initial draw
                drawGuideView(mazeData, null, null);
                gameStarted = true;

            } catch (error) {
                console.error('Guide view error:', error);
                const msg = document.createElement('div');
                msg.style.cssText = 'position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);background:rgba(0,0,0,0.8);color:red;padding:20px;border-radius:10px;text-align:center;';
                msg.innerHTML = `Error: ${error.message}<br><button onclick="location.reload()" style="margin-top:15px;padding:10px;background:white;color:red;border:none;border-radius:5px;cursor:pointer;">Reload</button>`;
                document.body.appendChild(msg);
            }
        }

        function drawGuideView(mazeData, playerPos, monsterPos) {
            console.log('Drawing guide view with:', {
                playerPos: playerPos,
                monsterPos: monsterPos
            });
            
            const config = window.guideViewConfig;
            if (!config || !mazeData?.maze) return;

            const { cellSize, margin, worldCellSize } = config;

            // Clear canvas
            guideCtx.fillStyle = '#000000';
            guideCtx.fillRect(0, 0, guideCanvas.width, guideCanvas.height);

            // Draw floor with lighter color
            guideCtx.fillStyle = '#e0e0e0'; // Light gray
            guideCtx.fillRect(
                margin, 
                margin, 
                mazeData.maze[0].length * cellSize,
                mazeData.maze.length * cellSize
            );

            // Draw walls with darker color - flip the z-axis by using (mazeData.maze.length - 1 - z)
            for (let z = 0; z < mazeData.maze.length; z++) {
                for (let x = 0; x < mazeData.maze[z].length; x++) {
                    if (mazeData.maze[z][x] === 1) {
                        guideCtx.fillStyle = '#1a1a1a'; // Very dark gray
                        guideCtx.fillRect(
                            (mazeData.maze[z].length - 1 - x) * cellSize + margin,
                            (mazeData.maze.length - 1 - z) * cellSize + margin,
                            cellSize,
                            cellSize
                        );
                    }
                }
            }

            // Draw exit - flip both x and z coordinates
            const exitX = Math.floor((mazeData.maze[0].length - 1 - (mazeData.endPosition.x / worldCellSize))) * cellSize + margin;
            const exitZ = Math.floor(mazeData.maze.length - 1 - (mazeData.endPosition.z / worldCellSize)) * cellSize + margin;
            
            // Draw exit marker with glow effect
            guideCtx.shadowColor = '#4CAF50';
            guideCtx.shadowBlur = 20;
            guideCtx.fillStyle = '#4CAF50';
            
            // Draw a larger marker to make it more visible
            const exitMarkerSize = cellSize * 1.2;
            guideCtx.fillRect(
                exitX - (exitMarkerSize - cellSize) / 2,
                exitZ - (exitMarkerSize - cellSize) / 2,
                exitMarkerSize,
                exitMarkerSize
            );
            
            // Draw player marker with improved visibility - flip the x coordinate
            if (playerPos?.x != null && playerPos?.z != null) {
                // Convert world position to grid position (snapped to cells)
                const gridX = Math.round((mazeData.maze[0].length - 1 - playerPos.x / worldCellSize));
                const gridZ = Math.round((mazeData.maze.length - 1 - playerPos.z / worldCellSize));
                
                // Convert grid position back to canvas coordinates
                const canvasX = gridX * cellSize + margin + (cellSize / 2);
                const canvasZ = gridZ * cellSize + margin + (cellSize / 2);

                // Draw blue glow effect
                guideCtx.shadowColor = '#2196F3';
                guideCtx.shadowBlur = 15;
                
                // Draw player marker as a square that fits perfectly in the cell
                const squareSize = cellSize * 0.9; // Make it slightly smaller than the cell for visibility
                guideCtx.fillStyle = '#2196F3';
                guideCtx.fillRect(
                    canvasX - squareSize/2,
                    canvasZ - squareSize/2,
                    squareSize,
                    squareSize
                );
                
                // Add white border
                guideCtx.strokeStyle = '#FFFFFF';
                guideCtx.lineWidth = 2;
                guideCtx.strokeRect(
                    canvasX - squareSize/2,
                    canvasZ - squareSize/2,
                    squareSize,
                    squareSize
                );

                // Draw direction indicator (arrow) with improved stability
                if (playerPos.rotation?.y != null) {
                    const arrowLength = squareSize * 0.8;
                    
                    // Calculate arrow endpoint using player's rotation - adjust for flipped x-axis
                    // Round the rotation value to reduce jitter
                    const roundedRotation = Math.round(playerPos.rotation.y * 100) / 100;
                    const angle = -roundedRotation - Math.PI / 2;
                    
                    // Calculate endpoints with rounded values
                    const endX = Math.round(canvasX - Math.cos(angle) * arrowLength);
                    const endZ = Math.round(canvasZ - Math.sin(angle) * arrowLength);
                    
                    // Draw arrow with thicker lines and anti-aliasing
                    guideCtx.lineCap = 'round';
                    guideCtx.lineJoin = 'round';
                    
                    // Draw arrow line
                    guideCtx.beginPath();
                    guideCtx.moveTo(canvasX, canvasZ);
                    guideCtx.lineTo(endX, endZ);
                    guideCtx.strokeStyle = '#FFEB3B';
                    guideCtx.lineWidth = 4;
                    guideCtx.stroke();
                    
                    // Draw arrow head
                    const headLength = squareSize * 0.4;
                    const headAngle = Math.PI / 6;
                    
                    // Calculate and round head points
                    const head1X = Math.round(endX + headLength * Math.cos(angle - headAngle));
                    const head1Z = Math.round(endZ + headLength * Math.sin(angle - headAngle));
                    const head2X = Math.round(endX + headLength * Math.cos(angle + headAngle));
                    const head2Z = Math.round(endZ + headLength * Math.sin(angle + headAngle));
                    
                    guideCtx.beginPath();
                    guideCtx.moveTo(endX, endZ);
                    guideCtx.lineTo(head1X, head1Z);
                    guideCtx.moveTo(endX, endZ);
                    guideCtx.lineTo(head2X, head2Z);
                    guideCtx.strokeStyle = '#FFEB3B';
                    guideCtx.lineWidth = 4;
                    guideCtx.stroke();
                }
            }

            // Draw monster position if available
            if (monsterPos?.x != null && monsterPos?.z != null) {
                console.log('Drawing monster at:', monsterPos);
                // Convert world position to grid position (snapped to cells)
                const gridX = Math.round((mazeData.maze[0].length - 1 - monsterPos.x / worldCellSize));
                const gridZ = Math.round((mazeData.maze.length - 1 - monsterPos.z / worldCellSize));
                
                // Convert grid position back to canvas coordinates
                const canvasX = gridX * cellSize + margin + (cellSize / 2);
                const canvasZ = gridZ * cellSize + margin + (cellSize / 2);

                // Draw red glow effect for monster
                guideCtx.shadowColor = '#ff0000';
                guideCtx.shadowBlur = 15;
                
                // Draw monster marker as a red diamond
                const diamondSize = cellSize * 0.9;
                guideCtx.fillStyle = '#ff0000';
                guideCtx.beginPath();
                guideCtx.moveTo(canvasX, canvasZ - diamondSize/2); // Top point
                guideCtx.lineTo(canvasX + diamondSize/2, canvasZ); // Right point
                guideCtx.lineTo(canvasX, canvasZ + diamondSize/2); // Bottom point
                guideCtx.lineTo(canvasX - diamondSize/2, canvasZ); // Left point
                guideCtx.closePath();
                guideCtx.fill();
                
                // Add white border to monster marker
                guideCtx.strokeStyle = '#FFFFFF';
                guideCtx.lineWidth = 2;
                guideCtx.stroke();

                // Draw direction indicator for monster if rotation available
                if (monsterPos.rotation?.y != null) {
                    const arrowLength = diamondSize * 0.8;
                    
                    // Calculate arrow endpoint using monster's rotation
                    const angle = -monsterPos.rotation.y - Math.PI / 2;
                    const endX = canvasX - Math.cos(angle) * arrowLength;
                    const endZ = canvasZ - Math.sin(angle) * arrowLength;
                    
                    // Draw arrow line
                    guideCtx.beginPath();
                    guideCtx.moveTo(canvasX, canvasZ);
                    guideCtx.lineTo(endX, endZ);
                    guideCtx.strokeStyle = '#ff6b6b'; // Light red color for visibility
                    guideCtx.lineWidth = 3;
                    guideCtx.stroke();
                    
                    // Draw arrow head
                    const headLength = diamondSize * 0.4;
                    const headAngle = Math.PI / 6; // 30 degrees
                    
                    guideCtx.beginPath();
                    guideCtx.moveTo(endX, endZ);
                    guideCtx.lineTo(
                        endX + headLength * Math.cos(angle - headAngle),
                        endZ + headLength * Math.sin(angle - headAngle)
                    );
                    guideCtx.moveTo(endX, endZ);
                    guideCtx.lineTo(
                        endX + headLength * Math.cos(angle + headAngle),
                        endZ + headLength * Math.sin(angle + headAngle)
                    );
                    guideCtx.strokeStyle = '#ff6b6b';
                    guideCtx.lineWidth = 3;
                    guideCtx.stroke();
                }
            }

            // Reset shadow
            guideCtx.shadowBlur = 0;
        }

        function animate() {
            requestAnimationFrame(animate);
            
            if (gameStarted && controls && controls.update) {
                controls.update(); // Call the controls update function
                
                if ((playerRole === 'player' || playerRole === 'monster') && multiplayerManager && multiplayerManager.connected) {
                    const now = Date.now();
                    // Only send position updates at most every 50ms
                    if (now - lastPositionUpdate >= POSITION_UPDATE_INTERVAL) {
                        lastPositionUpdate = now;
                        
                        // Send position update to server
                        const position = {
                            x: camera.position.x,
                            y: camera.position.y,
                            z: camera.position.z
                        };
                        const rotation = {
                            x: camera.rotation.x,
                            y: camera.rotation.y,
                            z: camera.rotation.z
                        };
                        
                        // Send position and rotation update to server with correct type
                        if (multiplayerManager.socket && multiplayerManager.socket.readyState === WebSocket.OPEN) {
                            multiplayerManager.socket.send(JSON.stringify({
                                type: playerRole === 'monster' ? 'monster_position' : 'player_position',
                                position: position,
                                rotation: rotation,
                                roomCode: multiplayerManager.roomCode,
                                sessionId: multiplayerManager.gameState.sessionId
                            }));
                        }
                    }
                }
            }
            
            if (renderer && scene && camera) {
                renderer.render(scene, camera);
            }
        }

        // Event Listeners
        document.getElementById('singlePlayerButton').addEventListener('click', () => {
            console.log('Single player button clicked');
            startGame('single');
        });
        document.getElementById('multiplayerButton').addEventListener('click', () => {
            console.log('Multiplayer button clicked');
            showMultiplayerMenu();
        });
        document.getElementById('createRoomButton').addEventListener('click', () => {
            console.log('Create room button clicked');
            createRoom();
        });
        document.getElementById('joinRoomButton').addEventListener('click', () => {
            console.log('Join room button clicked');
            showJoinRoom();
        });
        document.getElementById('backToMainButton').addEventListener('click', () => {
            document.getElementById('multiplayerMenu').style.display = 'none';
            document.getElementById('startScreen').style.display = 'block';
        });
        document.getElementById('roomCodeInput').addEventListener('keyup', (e) => {
            if (e.key === 'Enter') {
                joinRoom();
            }
        });

        // Add click handler for room code copying
        document.getElementById('roomCode').addEventListener('click', function() {
            copyRoomCode(this);
        });

        // Handle window resizing
        window.addEventListener('resize', () => {
            if (camera && renderer) {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            }
        });

        // Clean up when leaving the game
        window.addEventListener('beforeunload', () => {
            if (multiplayerManager) {
                multiplayerManager.disconnect();
            }
            gameStarted = false;
        });

        // Handle visibility change to prevent reconnection loops
        document.addEventListener('visibilitychange', () => {
            if (document.hidden) {
                console.log('Page hidden, handling cleanup...');
                // Store current game state before going hidden
                if (multiplayerManager && multiplayerManager.gameState.active) {
                    multiplayerManager.gameState.lastKnownState = {
                        roomCode: multiplayerManager.roomCode,
                        role: multiplayerManager.role,
                        isHost: multiplayerManager.isHost,
                        position: playerPosition
                    };
                }
            } else {
                console.log('Page visible, checking game state...');
                if (multiplayerManager && multiplayerManager.gameState.active) {
                    // Verify connection and game state when becoming visible
                    if (!multiplayerManager.connected || multiplayerManager.gameState.reconnecting) {
                        console.log('Connection lost while hidden, attempting to restore...');
                        multiplayerManager.connect();
                    } else {
                        // Send a ping to verify connection is still alive
                        multiplayerManager.socket.send(JSON.stringify({
                            type: 'ping',
                            timestamp: Date.now()
                        }));
                    }
                }
            }
        });

        // Update the MultiplayerManager to handle disconnections better
        MultiplayerManager.prototype.handleDisconnect = function() {
            console.log('Handling disconnection...');
            this.connected = false;
            
            if (gameStarted && !this.disconnecting) {
                // Show a reconnection message
                let reconnectMessage = document.getElementById('reconnectMessage');
                if (!reconnectMessage) {
                    reconnectMessage = document.createElement('div');
                    reconnectMessage.id = 'reconnectMessage';
                    reconnectMessage.style.cssText = `
                        position: fixed;
                        top: 50%;
                        left: 50%;
                        transform: translate(-50%, -50%);
                        background: rgba(0, 0, 0, 0.8);
                        color: white;
                        padding: 20px;
                        border-radius: 10px;
                        z-index: 1000;
                        text-align: center;
                    `;
                    document.body.appendChild(reconnectMessage);
                }
                
                reconnectMessage.innerHTML = `
                    <h3>Connection Lost</h3>
                    <p>Attempting to reconnect...</p>
                    <button onclick="location.reload()" style="margin-top: 10px; padding: 5px 10px;">Restart Game</button>
                `;
                
                // Try to reconnect
                this.reconnect();
                
                // Set a timeout to show the menu if reconnection fails
                setTimeout(() => {
                    if (!this.connected && gameStarted) {
                        console.log('Reconnection failed, showing start screen');
                        hideAllMenus();
                        
                        // Only show start screen if we're completely disconnected
                        if (!this.socket || this.socket.readyState !== WebSocket.CONNECTING) {
                            document.getElementById('startScreen').style.display = 'block';
                            gameStarted = false;
                            
                            // Remove reconnect message
                            if (reconnectMessage) {
                                reconnectMessage.remove();
                            }
                            
                            // Show an error message to the user
                            alert('Lost connection to the game. Please try again.');
                        }
                    }
                }, 15000); // Give even more time for reconnection attempts
            }
        };

        // Modify MultiplayerManager message handling
        const originalHandleMessage = MultiplayerManager.prototype.handleMessage;
        MultiplayerManager.prototype.handleMessage = function(message) {
            console.log('MultiplayerManager received message:', message);
            
            switch (message.type) {
                case 'room_created':
                    console.log('Room created with role:', message.role);
                    playerRole = message.role;
                    this.roomCode = message.roomCode;
                    this.isHost = true;
                    if (this.onRoomCreated) {
                        this.onRoomCreated(message.roomCode);
                    }
                    break;

                case 'room_joined':
                    console.log('Room joined with role:', message.role);
                    playerRole = message.role;
                    this.roomCode = message.roomCode;
                    
                    if (this.onRoomJoined) {
                        this.onRoomJoined();
                    }
                    break;

                case 'game_ready':
                    console.log('Game ready received, all players joined');
                    // Hide room code and waiting messages
                    document.getElementById('roomCode').style.display = 'none';
                    document.getElementById('roomCodeInstructions').style.display = 'none';
                    document.getElementById('multiplayerMenu').style.display = 'none';
                    
                    // Start the game if not already started
                    if (!gameStarted) {
                        gameStarted = true;
                        console.log('Starting game with role:', playerRole);
                        init();
                        animate();
                    }
                    break;

                case 'player_position':
                    if (playerRole === 'guide') {
                        console.log('Guide received player position:', message);
                        if (!message.position || typeof message.position.x !== 'number' || typeof message.position.z !== 'number') {
                            console.error('Invalid player position received:', message.position);
                            return;
                        }
                        
                        playerPosition = {
                            x: message.position.x,
                            y: message.position.y,
                            z: message.position.z,
                            rotation: message.rotation
                        };
                        
                        if (maze && guideCanvas && guideCtx) {
                            console.log('Drawing guide view with updated positions');
                            drawGuideView(maze, playerPosition, monsterPosition);
                        }
                    } else if (playerRole === 'monster' && message.playerId) {
                        // Monster sees player position
                        console.log('Monster received player position:', message);
                        if (otherPlayers[message.playerId]) {
                            otherPlayers[message.playerId].position.set(
                                message.position.x,
                                message.position.y,
                                message.position.z
                            );
                            if (message.rotation) {
                                otherPlayers[message.playerId].rotation.set(
                                    message.rotation.x,
                                    message.rotation.y,
                                    message.rotation.z
                                );
                            }
                        }
                    }
                    break;

                case 'monster_position':
                    if (playerRole === 'guide') {
                        console.log('Guide received monster position:', message);
                        if (!message.position || typeof message.position.x !== 'number' || typeof message.position.z !== 'number') {
                            console.error('Invalid monster position received:', message.position);
                            return;
                        }
                        
                        monsterPosition = {
                            x: message.position.x,
                            y: message.position.y,
                            z: message.position.z,
                            rotation: message.rotation
                        };
                        
                        if (maze && guideCanvas && guideCtx) {
                            console.log('Drawing guide view with monster at:', {
                                x: monsterPosition.x,
                                z: monsterPosition.z
                            });
                            drawGuideView(maze, playerPosition, monsterPosition);
                        }
                    } else if (playerRole === 'player' && message.playerId) {
                        // Player sees monster position
                        console.log('Player received monster position:', message);
                        if (otherPlayers[message.playerId]) {
                            otherPlayers[message.playerId].position.set(
                                message.position.x,
                                message.position.y,
                                message.position.z
                            );
                            if (message.rotation) {
                                otherPlayers[message.playerId].rotation.set(
                                    message.rotation.x,
                                    message.rotation.y,
                                    message.rotation.z
                                );
                            }
                        }
                    }
                    break;

                case 'maze_data':
                    console.log('Received maze data:', message.maze);
                    maze = message.maze;
                    maze.wallPositions = maze.wallPositions || [];
                    
                    // Initialize the maze for all roles
                    if (playerRole === 'player' || playerRole === 'monster') {
                        generateNewMaze();
                    } else if (playerRole === 'guide') {
                        drawGuideView(maze);
                    }
                    break;

                case 'waiting_for_players':
                    console.log('Waiting for players:', message);
                    const instructionsElement = document.getElementById('roomCodeInstructions');
                    if (instructionsElement) {
                        instructionsElement.textContent = message.message || 'Waiting for more players...';
                        instructionsElement.style.display = 'block';
                    }
                    break;

                case 'host_assigned':
                    console.log('Host assigned:', message);
                    if (message.isHost) {
                        this.isHost = true;
                    }
                    break;

                case 'error':
                    console.error('Server error:', message.error);
                    if (this.onError) {
                        this.onError(message.error);
                    }
                    break;

                case 'player_joined':
                    if (this.onPlayerJoined) {
                        this.onPlayerJoined(message.playerId, message.role);
                    }
                    break;

                case 'player_left':
                    if (this.onPlayerLeft) {
                        this.onPlayerLeft(message.playerId);
                    }
                    break;

                default:
                    console.log('Unhandled message type:', message.type);
                    break;
            }
        };

        function handleMultiplayerMessage(message) {
            console.log('Handling message:', message);
            
            switch (message.type) {
                case 'room_created':
                    roomCode = message.roomCode;
                    playerRole = message.role;
                    document.getElementById('roomCode').textContent = roomCode;
                    document.getElementById('waitingMessage').style.display = 'block';
                    document.getElementById('waitingMessage').textContent = 'Waiting for other players to join...';
                    break;
                    
                case 'room_joined':
                    roomCode = message.roomCode;
                    playerRole = message.role;
                    document.getElementById('roomCode').textContent = roomCode;
                    document.getElementById('waitingMessage').style.display = 'block';
                    document.getElementById('waitingMessage').textContent = 'Waiting for other players...';
                    break;
                    
                case 'waiting_for_players':
                    document.getElementById('waitingMessage').style.display = 'block';
                    document.getElementById('waitingMessage').textContent = message.message;
                    gameStarted = message.canStart;
                    break;
                    
                case 'game_ready':
                    document.getElementById('waitingMessage').style.display = 'none';
                    document.getElementById('multiplayerMenu').style.display = 'none';
                    gameStarted = message.canStart;
                    if (gameStarted) {
                        init(true);
                        animate();
                    }
                    break;
                    
                case 'error':
                    console.log('Server error:', message.error);
                    document.getElementById('errorMessage').textContent = message.error;
                    document.getElementById('errorMessage').style.display = 'block';
                    setTimeout(() => {
                        document.getElementById('errorMessage').style.display = 'none';
                    }, 5000);
                    showMultiplayerMenu();
                    break;
                    
                // ... rest of the cases ...
            }
        }

        function initGame(isMultiplayer = false) {
            if (isMultiplayer && !gameStarted) {
                console.log('Cannot start multiplayer game yet - waiting for players');
                return;
            }
            
            // ... rest of initGame function ...
        }

        function getRandomEmptyCell(maze) {
            const width = maze.maze[0].length;
            const height = maze.maze.length;
            let attempts = 0;
            const maxAttempts = 100;

            while (attempts < maxAttempts) {
                const x = Math.floor(Math.random() * width);
                const z = Math.floor(Math.random() * height);
                
                // Check if this cell is empty (not a wall) and not the start position
                if (!maze.maze[z][x] && 
                    (x !== Math.floor(maze.startPosition.x / maze.cellSize) || 
                     z !== Math.floor(maze.startPosition.z / maze.cellSize))) {
                    return { x: x, z: z };
                }
                attempts++;
            }

            // If no empty cell found after max attempts, return a default position
            return { x: 2, z: 2 };
        }

        function handlePlayerMove(ws, data) {
            console.log('Received player position:', data);
            const room = rooms.get(ws.roomCode);
            if (!room) {
                console.log('Room not found for player position:', ws.roomCode);
                return;
            }

            // Update player position
            room.playerPositions.set(ws.playerId, {
                position: data.position,
                rotation: data.rotation
            });

            // Send position to all guide and monster players
            room.players.forEach((playerWs, playerId) => {
                const role = room.roles.get(playerId);
                if (role === 'guide' || role === 'monster') {
                    console.log(`Sending position to ${role}:`, {
                        position: data.position,
                        playerId: playerId
                    });
                    playerWs.send(JSON.stringify({
                        type: 'player_position',
                        position: data.position,
                        rotation: data.rotation
                    }));
                }
            });
        }

        // Add these new functions for monster features
        function updateDistanceIndicator(distance) {
            let indicator = document.getElementById('distanceIndicator');
            if (!indicator) {
                indicator = document.createElement('div');
                indicator.id = 'distanceIndicator';
                indicator.style.cssText = `
                    position: fixed;
                    top: 60px;
                    left: 20px;
                    color: #ff0000;
                    font-size: 16px;
                    text-shadow: 0 0 5px rgba(255, 0, 0, 0.5);
                    z-index: 1000;
                `;
                document.body.appendChild(indicator);
            }
            indicator.textContent = `Distance to player: ${Math.round(distance)} units`;
        }

        function handleMonsterCatch() {
            // Create catch notification
            const notification = document.createElement('div');
            notification.style.cssText = `
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: rgba(255, 0, 0, 0.8);
                color: white;
                padding: 20px;
                border-radius: 10px;
                font-size: 24px;
                text-align: center;
                z-index: 1000;
            `;
            notification.textContent = 'You caught the player!';
            document.body.appendChild(notification);

            // Remove notification after 3 seconds
            setTimeout(() => {
                notification.remove();
            }, 3000);

            // TODO: Add game end logic here
        }
    </script>
</body>
</html> 